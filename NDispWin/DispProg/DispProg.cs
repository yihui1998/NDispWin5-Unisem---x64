using NSW.Net;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Windows.Forms;
using System.Xml;

using Emgu.CV;
using Emgu.CV.Structure;

namespace NDispWin
{
    enum EGDispCmd { None, New, DOT, LINE_START, LINE_PASS, LINE_END, DOT_START, DOT_END }
    enum ECutTailType { None, Fwd, Bwd, SqFwd, SqBwd, Rev, SqRev };

    public class Stats
    {
        public class Board
        {
            public static int[] UnitCount = new int[2] { 0, 0 };//Board Unit Count by Head
            public static int TotalUnitCount//Board Total Unit Count
            {
                get
                {
                    return UnitCount[0] + UnitCount[1];
                }
            }
            public static void ResetUnitCount()
            {
                UnitCount[0] = 0;
                UnitCount[1] = 0;
            }
            public static int[] ProcUnitCount = new int[2] { 0, 0 };//Board Unit Processed Count by Head
            public static int TotalProcUnitCount//Board Total Unit Count
            {
                get
                {
                    return ProcUnitCount[0] + ProcUnitCount[1];
                }
            }
            public static void ResetProcUnitCount()
            {
                ProcUnitCount[0] = 0;
                ProcUnitCount[1] = 0;
            }

            public static int[] DispCounter = new int[3] { 0, 0, 0 };// Head 1 Resetable counters 
            public static int[] DispCount = new int[2] { 0, 0 };//Board Disp Count by Head
            public static int TotalDispCount//Board Total Unit Count
            {
                get
                {
                    return DispCount[0] + DispCount[1];
                }
            }
            public static void ResetDispCount()
            {
                DispCount[0] = 0;
                DispCount[1] = 0;
                DispCounter[0] = 0;
                DispCounter[1] = 0;
                DispCounter[2] = 0;
            }
        }

        public class ContinueBoard
        {
            //runtime counting unit
            public static int[] UnitCount = new int[2] { 0, 0 };//Unit Count by Head
            public static int[] DispCount = new int[2] { 0, 0 };//Disp Count by Head
            public static int TotalUnitCount
            {
                get { return UnitCount[0] + UnitCount[1]; }
            }
            public static void ResetUnitCount()
            {
                UnitCount[0] = 0;
                UnitCount[1] = 0;
            }
            public static void ResetDispCount()
            {
                DispCount[0] = 0;
                DispCount[1] = 0;
            }
        }

        public static int[] UnitCount = new int[2] { 0, 0 };//Cumulative Unit Count
        public static int TotalUnitCount
        {
            get { return UnitCount[0] + UnitCount[1]; }
        }
        public static void ResetUnitCount()
        {
            UnitCount[0] = 0;
            UnitCount[1] = 0;
        }
        public static void UnitCount_Inc(int HeadNo)
        {
            UnitCount[HeadNo]++;
            Board.UnitCount[HeadNo]++;
            ContinueBoard.UnitCount[HeadNo]++;
        }

        public static int[] DispCount = new int[2] { 0, 0 };//Cumulative Disp Count
        public static int TotalDispCount
        {
            get { return DispCount[0] + DispCount[1]; }
        }
        public static void ResetDispCount()
        {
            DispCount[0] = 0;
            DispCount[1] = 0;
        }
        public static void DispCount_Inc(int headNo, int count)
        {
            DispCount[headNo] += count;
            Board.DispCount[headNo] += count;
            ContinueBoard.DispCount[headNo] += count;
            Maint.Disp.Count[headNo] += count;

            switch (DispProg.Pump_Type)
            {
                case TaskDisp.EPumpType.Vermes:
                case TaskDisp.EPumpType.Vermes1560:
                    break;
                default:
                    Material.Unit.Count[headNo] += count;
                    break;
            }
            if (headNo == 0)
            {
                if (DispProg.FlowRate.EnableAutoCalUnit)
                    AutoFlowRateUnitCounter += count;
                else
                    AutoFlowRateUnitCounter = 0;
            }
            GDefine.SaveDefault();
        }
        public static void DispCount_Inc(int HeadNo)
        {
            DispCount_Inc(HeadNo, 1);
        }

        public static int boardCount;
        public static int StartTime;//ms
        public static int AutoFlowRateFrameCounter = 0;
        public static int AutoFlowRateUnitCounter = 0;

        public static int BoardCount
        {
            set
            {
                boardCount = value;
                if (DispProg.FlowRate.EnableAutoCalFrame)
                    AutoFlowRateFrameCounter++;
                else
                    AutoFlowRateFrameCounter = 0;
            }
            get
            {
                return boardCount;
            }
        }

        public static void Reset()
        {
            Stats.ResetUnitCount();
            Stats.ResetDispCount();
            Stats.BoardCount = 0;
            Stats.StartTime = GDefine.GetTickCount();
        }
    }

    internal class DispProg
    {
        public class Idle
        {
            public static void Create()
            {
                Reset();
            }

            public static bool Purging = false;
            static DateTime dt_LastMove = DateTime.Now;
            static bool atIdle = false;//flag indicate at idle state
            static frm_DispCore_IdlePurge frm = new frm_DispCore_IdlePurge();

            public static void Reset()
            {
                dt_LastMove = DateTime.Now;
                atIdle = false;
            }
            public static bool Idling
            {
                get
                {
                    if (TaskDisp.Option_IdlePurgeTimer == 0) return false;
                    return ((DateTime.Now - dt_LastMove).TotalSeconds > TaskDisp.Option_IdlePurgeTimer);
                }
            }
            public static void IdlePurge()
            {
                Purging = true;
                try
                {
                    int i_HeadSelect = 0;

                    switch (DispProg.Head_Operation)
                    {
                        case TaskDisp.EHeadOperation.Double:
                        case TaskDisp.EHeadOperation.Sync:
                            i_HeadSelect = 3;
                            break;
                        case TaskDisp.EHeadOperation.Single:
                            i_HeadSelect = 1;
                            break;
                    }

                    frm = new frm_DispCore_IdlePurge();
                    frm.i_DispSelect = i_HeadSelect;
                    frm.AutoStart = true;
                    frm.ShowDialog();
                    frm.TopMost = true;
                    Reset();
                }
                catch { }
                finally
                {
                    Purging = false;
                }
            }
            public static void RunIdle()//return true if idle
            {
                if (atIdle) return;

                if (GDefine.Status == EStatus.Ready || GDefine.Status == EStatus.Stop || GDefine.Status == EStatus.EndStop)
                {
                    if (TaskDisp.Option_EnableStartIdle && TaskDisp.Option_IdlePurgeTimer > 0)
                        if ((DateTime.Now - dt_LastMove).TotalSeconds > TaskDisp.Option_IdlePurgeTimer)
                        {
                            Event.OP_IDLE_PURGE_START.Set();
                            TaskDisp.TaskMoveGZZ2Up();
                            TaskDisp.TaskGotoTPos2(TaskDisp.Needle_Purge_Pos);
                            atIdle = true;
                        }
                }
            }
            public static void StopPurge()
            {
                Event.OP_IDLE_PURGE_STOP.Set();
                frm.Close();
            }
        }

        public static bool Initialized = false;//master initialization flag

        public static bool SetupMode = false;//in auto mode

        public static int LastTactTime = 0;
        static int LastStartTickCount = 0;
        public static int LastUPH = 0;

        #region enums and classes
        public class TLine
        {
            public const int MAX_PARA = 100;
            public ECmd Cmd;
            public int ID;
            public string String;
            public int[] IPara;
            public double[] DPara;
            public int[] Index;
            public double[] X;
            public double[] Y;
            public double[] Z;
            public double[] U;
            public double[] A;
            public double[] B;
            public double[] C;
            public double[] D;
            public int[] Cond;
            public void Init()
            {
                this.Cmd = ECmd.NONE;
                this.ID = 0;
                this.String = "";
                this.IPara = new int[TLine.MAX_PARA];
                this.DPara = new double[TLine.MAX_PARA];
                this.Index = new int[TLine.MAX_PARA];
                this.X = new double[TLine.MAX_PARA];
                this.Y = new double[TLine.MAX_PARA];
                this.Z = new double[TLine.MAX_PARA];
                this.U = new double[TLine.MAX_PARA];
                this.A = new double[TLine.MAX_PARA];
                this.B = new double[TLine.MAX_PARA];
                this.C = new double[TLine.MAX_PARA];
                this.D = new double[TLine.MAX_PARA];
                this.Cond = new int[TLine.MAX_PARA];
            }

            public TLine()
            {
                Init();
            }
            public TLine(TLine Line)
            {
                Init();
                this.Copy(Line);
            }
            public void Copy(TLine Line)
            {
                this.Cmd = Line.Cmd;
                this.ID = Line.ID;
                this.String = Line.String;
                for (int i = 0; i < MAX_PARA; i++)
                {
                    this.IPara[i] = Line.IPara[i];
                    this.DPara[i] = Line.DPara[i];
                    this.Index[i] = Line.Index[i];
                    this.X[i] = Line.X[i];
                    this.Y[i] = Line.Y[i];
                    this.Z[i] = Line.Z[i];
                    this.U[i] = Line.U[i];
                    this.A[i] = Line.A[i];
                    this.B[i] = Line.B[i];
                    this.C[i] = Line.C[i];
                    this.D[i] = Line.D[i];
                    this.Cond[i] = Line.Cond[i];
                }
            }
        }
        public class TCmdList
        {
            public const int MAX_CMD = 2048;//512;
            public int Count = 0;
            public TLine[] Line = new TLine[MAX_CMD];
            public TCmdList()
            {
                for (int i = 0; i < MAX_CMD; i++)
                {
                    Line[i] = new TLine();
                }
            }
            public void Copy(TCmdList CmdList)
            {
                Count = CmdList.Count;
                for (int i = 0; i < MAX_CMD; i++)
                {
                    Line[i].Copy(CmdList.Line[i]);
                }
            }
        }
        public enum ECmd
        {
            NONE = 0,
            SUB = 5,

            SEPERATOR = 20,
            COMMENT = 21,
            /*
            IPara[0..9]     [SaveLog,..]
            */

            LAYOUT = 50,
            FOR_LAYOUT = 51,
            END_LAYOUT = 52,
            REPEAT = 53,//repeat previous DOT and MOVE Group
            LAYOUT_PREMAP = 55,

            //COUNTER = 60,
            //CNTR_ACTION = 61,
            //COND_ON = 70,
            //COND_OFF = 71,

            SET_GPOUT = 80,

            DO_REF = 220,
            DO_VISION = 221,
            /*
            ID              VisionID
            IPara[0..9]     [nil,CamID,TYPE,nil,SettleTime,SkipCount,FailAction,InspPrior,..]
            IPara[10..19]   [..]
            IPara[20..29]   [nil,FocusNo,..]
            DPara[0..10]    [nil,XYTol,nil,nil,nil,nil,AcceptTol,..]
            DPara[10..11]   [StartV,DriveV,Accel,..]
            X[0]            [XPos]
            Y[0]            [YPos]
            */
            DO_BDORIENT = 222,
            DO_BDCAPTURE = 225,
            DO_VIS_INSP = 226,
            /*Same as DO_VISION for unit level only. Not position correction.
            ID              VisionID
            IPara[0..9]     [nil,CamID,TYPE,nil,SettleTime,SkipCount,FailAction,InspPrior,..]
            IPara[10..19]   [..]
            IPara[20..29]   [nil,FocusNo,..]
            DPara[0..10]    [nil,XYTol,nil,nil,nil,nil,AcceptTol,..]
            DPara[10..11]   [StartV,DriveV,Accel,..]
            X[0]            [XPos]
            Y[0]            [YPos]
            */
            DO_REF_EDGE = 227,
            DO_REF_CHECK = 228,
            DO_VISION_CHECK = 229,

            DO_UNITMARK = 230,

            SINGULATED_ID = 239,
            READ_ID = 240,

            USE_REF = 250,
            USE_VISION = 251,

            DO_HEIGHT = 300,
            USE_HEIGHT = 350,
            HEIGHT_SET = 370,//perfrom height at next command location, single head only

            DOT = 400,
            //DOT_ARRAY = 401,//remove support from 5.2.87 due to complication for adding OffsetAll
            DOT_MULTI = 402,
            DOTLINE_MULTI = 403,
            DOT_P = 405,
            MOVE = 410,
            LINE = 411,
            //CLINE = 412,
            LINE_MULTI = 415,
            ARC = 420,
            CIRC = 421,
            //SM_CIRC = 422, removed for Unisem
            //SM_CIRC3 = 423, removed for Unisem
            //CARC = 425,
            //CCIRC = 426,
            DWELL = 430,
            WAIT = 440,
            WAIT_START = 445,

            //RECT_FILL = 450, never complete develop, discontinue support
            //FILL_PAT = 451,//remove support from 5.2.87 due to complication for adding OffsetAll
            //SPIRAL_FILL = 452,//remove support from 5.2.87 due to complication for adding OffsetAll

            //GROUP_DISP = 460,//remove support from 5.2.87 due to complication for adding OffsetAll

            VOL_SET_DOTS = 480,//distribute volume to total number of dots.
            PP_VOL_SET_SPEED = 482,//set line speed to match dispense time.

            CLEAN = 500,
            PURGE = 510,
            PURGE_DOT = 511,

            PURGE_STAGE = 515,
            WIPE_STAGE = 516,

            GO_PMAINT = 520,
            GO_MMAINT = 521,
            GO_POS = 525,
            DELAY = 530,

            WEIGHT_CAL = 550,
            //WEIGHT_MEAS = 551,

            PP_FILL = 580,
            PP_RECYCLE_B = 581,
            PP_RECYCLE_N = 582,
            PP_CLEANFILL = 583,
            PP_VOL_COMP = 585,
            PP_VOL_ADJRESET = 590,
            PP_VOL_ADJINC = 591,

            CREATE_MAP = 600,
            INPUT_MAP = 610,
            USE_MAP = 650,
            UNIT_COMPLETE = 660,
            BD_READY = 661,
            UNIT_CONTINUE = 662,//No parameters. Same as UNIT_COMPLETE minus setting unit to complete state.

            EXT_VISION = 700,
            NEEDLE_INSP = 701,

            MEASL_WH = 750,
            MEASL_H = 751,
            MEAS_MENISCUS = 752,
            CHECK_MENISCUS = 753,

            MEAS_TEMP = 780,
            TEMPLOGGER_LOG = 781,

            VIDEO_START = 790,
            VIDEO_STOP = 791,
            IMAGE_SNAP = 795,

            VOLUME_MAP = 850,
            //USE_VOL_MAP = 860,
            VOLUME_OFST = 861,
        }
        #endregion

        #region Mapping
        public class TMaps
        {
            public TMap[] PreMap = new TMap[MAX_IDS];
            public TMap ActivePreMap = new TMap();
            public TMap[] CurrMap = new TMap[MAX_IDS];
            public TMap[] PrevMap = new TMap[MAX_IDS];

            public TMaps()
            {
                for (int i = 0; i < MAX_IDS; i++)
                {
                    PreMap[i] = new TMap();
                    CurrMap[i] = new TMap();
                    PrevMap[i] = new TMap();
                }
            }
        }
        public static TMaps Map = new TMaps();

        public static EMapBin rt_Head1MapBin = EMapBin.None;
        public static EMapBin rt_Head2MapBin = EMapBin.None;
        public static TMapColor MapColor = new TMapColor();


        public static bool ClearMaps()
        {
            for (int ID = 0; ID < rt_LayoutCount; ID++)
            {
                for (int i = 0; i < rt_Layouts[ID].TUCount; i++)
                {
                    Map.CurrMap[ID].Bin[i] = EMapBin.None;
                }
            }
            Map.ActivePreMap.Clear();
            return true;
        }
        /// <summary>
        /// Clears Active Map and update Premap
        /// </summary>
        /// <returns></returns>
        public static bool ResetMaps()
        {
            for (int ID = 0; ID < rt_LayoutCount; ID++)
            {
                Map.PrevMap[ID].Bin = (EMapBin[])Map.CurrMap[ID].Bin.Clone();
                for (int i = 0; i < rt_Layouts[ID].TUCount; i++)
                {
                    Map.CurrMap[ID].Bin[i] = Map.PreMap[ID].Bin[i];
                }
            }
            Map.ActivePreMap.Clear();
            return true;
        }
        public static bool ResumeMap()
        {
            for (int ID = 0; ID < rt_LayoutCount; ID++)
            {
                Map.CurrMap[ID].Bin = (EMapBin[])DispProg.Map.PrevMap[ID].Bin.Clone();

                for (int i = 0; i < rt_Layouts[ID].TUCount; i++)
                {
                    if (Map.CurrMap[ID].Bin[i] >= EMapBin.Complete)
                        Map.CurrMap[ID].Bin[i] = EMapBin.Bypass;
                    else
                        Map.CurrMap[ID].Bin[i] = EMapBin.None;
                }
            }

            return true;
        }
        public static bool CurrMapMask(EMapBin[] SecondMapBin)
        {
            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
            {
                if (SecondMapBin[i] > Map.CurrMap[rt_LayoutID].Bin[i])
                    Map.CurrMap[rt_LayoutID].Bin[i] = SecondMapBin[i];
            }
            return true;
        }
        public static void UsePreMap(int PreMapNo)
        {
            Map.ActivePreMap = new TMap(Map.PreMap[PreMapNo]);
        }
        #endregion

        public static TaskDisp.EHeadOperation Head_Operation = (TaskDisp.EHeadOperation)0;
        public static TaskDisp.EPumpType Pump_Type = (TaskDisp.EPumpType)0;//.Auto;
        public static double Head_PitchX = 0;
        public static double Head_NeedlePitchY = 0;

        public static bool DispCtrl_ForceTimeMode = true;
        public static bool Options_EnableProcessLog = false;

        public static bool Options_EnableProcessCamera = false;
        //public static bool Options_EnableVideoLogStop = false;
        public static bool Options_WaitCameraReady = false;
        public static int Options_VideoLogDuration = 100;

        public static double Options_CheckBoardYield = 0;


        public const int MAX_STATION_NO = 8;
        public static int StationCount = 1;
        public static TPos3[] OriginBase = new TPos3[MAX_STATION_NO] { new TPos3(0, 0, 0), new TPos3(0, 0, 0), new TPos3(0, 0, 0), new TPos3(0, 0, 0), new TPos3(0, 0, 0), new TPos3(0, 0, 0), new TPos3(0, 0, 0), new TPos3(0, 0, 0) };
        public static TPos3 OriginDrawOfst = new TPos3();
        public static TPos3 Origin(ERunStationNo StationNo)
        {
            TPos3 Pos = new TPos3(OriginBase[(int)StationNo].X, OriginBase[(int)StationNo].Y, OriginBase[(int)StationNo].Z);
            return Pos;
        }

        public const int MAX_FOCUS_POS = 4;
        public static double[] FocusRelPos = new double[MAX_FOCUS_POS] { 0, 0, 0, 0 };

        public static string Message = "";

        public const int MAX_SCRIPT = 4;
        public static TScript[] Script = new TScript[MAX_SCRIPT];

        public static TModelList ModelList = new TModelList();
        public static TCounter Counter = new TCounter();

        internal const int MAX_PUMP = 2;
        internal const int MAX_IDS = 16;

        public static double PP_HeadA_DispBaseVol = 0.5;
        public static double PP_HeadB_DispBaseVol = 0.5;
        public static double PP_HeadA_DispVol_Adj = 0;//unit=ul
        public static double PP_HeadB_DispVol_Adj = 0;//unit=ul
        public static double PP_HeadA_BackSuckVol = 0;
        public static double PP_HeadB_BackSuckVol = 0;
        public static double[] PP_Head_VolumeRatio = new double[2] { 1, 1 };
        public static int PP_Head_DispOffsetTol = 0;//%
        public static double PP_Head_DispAdjustReso = 0.001;//%

        public static double Target_Weight = 1.000;//mg - package weight
        public static double Cal_Meas_Weight = 0;//mg - calibration weight

        public static double Meas_Spec = 0;//mg - measure weight
        public static double Meas_Spec_Tol = 0;//mg - measure weight tol
        public static double Cal_Weight_Tol = 0;//mg - calibration weight tol

        public static double[] Disp_Weight = new double[2] { 1, 1 };

        public static int DotsPerSample_Cal = 0;
        public static TaskWeight.EOutputResult OutputResult_Cal = TaskWeight.EOutputResult.Total;
        public static int DotsPerSample_Meas = 0;
        public static TaskWeight.EOutputResult OutputResult_Meas = TaskWeight.EOutputResult.Total;


        public class FlowRate
        {
            public static int NoToAve = 3;
            public static int Duration = 3;//Unit = second
            public static int Delay = 1;//Unit = second

            public static double MinPressure = 0.1;//MPa
            public static double MaxPressure = 0.3;//MPa

            public static bool EnableTargetFlowRate = false;
            public static double TargetFlowrate = 3;//mg/s
            public static double TargetFlowRateTol = 0.1;//mg/s

            public static bool EnableAutoCalFrame = false;
            public static int AutoCalFrameInterval = 10;
            public static bool EnableAutoCalUnit = false;
            public static int AutoCalUnitInterval = 12;


            public static double MaterialSlope = 0;
            public static double MaterialIntercept = 0;
            public static double TimeCompensate = 0;
        }

        public class WeightMeas
        {
            public static bool EnableTargetWeight = false;
            public static double TargetWeight = 10;
            public static double TargetWeightTol = 1;
            public static double Duration = 3;
            public static double SampleCount = 25;
            public static int Delay = 1;
        }

        public class PurgeStage
        {
            public static int Count = 0;//Purge Count
            public static int Interval = 0;//0-disable
            public static int OnStartCount = 0;//0-disable
        }

        public static double PP_HeadA_Min_Volume = 0;
        public static double PP_HeadB_Min_Volume = 0;
        public static double PP_HeadA_Max_Volume = 0;
        public static double PP_HeadB_Max_Volume = 0;

        public static double HM_HeadA_Disp_RPM = 100;//rpm
        public static double HM_HeadB_Disp_RPM = 100;//rpm
        public static int HM_HeadA_Disp_Time = 0;//rpm
        public static int HM_HeadB_Disp_Time = 0;//rpm
        public static double HM_HeadA_BSuck_RPM = 0;//rpm
        public static double HM_HeadB_BSuck_RPM = 0;//rpm
        public static int HM_HeadA_BSuck_Time = 0;//rpm
        public static int HM_HeadB_BSuck_Time = 0;//rpm

        public static double HM_Disp_RPM_AdjMin = 0;//rpm
        public static double HM_Disp_RPM_AdjMax = 0;//rpm
        public static int HM_Disp_Time_AdjMin = 0;//rpm
        public static int HM_Disp_Time_AdjMax = 0;//rpm

        public static double[] FPress = new double[2] { 2.5, 2.5 };//unit MPa
        public static double[] FPressH = new double[2] { 2.5, 2.5 };//unit MPa
        public static double[] PPress = new double[2] { 2.5, 2.5 };//unit MPa
        public static double FPress_AdjMin = 0;
        public static double FPress_AdjMax = 0;
        public static double PPress_AdjMin = 0;
        public static double PPress_AdjMax = 0;
        public static int FPressH_Timer = 0;

        public static double[] HeaterSV = new double[4] { 0, 0, 0, 0 };
        public static double[] HeaterRange = new double[4] { 0, 0, 0, 0 };

        public static string WeightSetup = "default";

        public class PJ
        {
            public static double[] OpenTime = new double[MAX_PUMP] { 10, 10 };
            public static double[] CloseDelay = new double[MAX_PUMP] { 10, 10 };
            public static int[] Pulse = new int[MAX_PUMP] { 1, 1 };
        }

        public class SP
        {
            public static double[] DispTime = new double[MAX_PUMP] { 10, 10 };
            public static double[] PulseOnDelay = new double[MAX_PUMP] { 0, 0 };//ms
            public static double[] PulseOffDelay = new double[MAX_PUMP] { 0, 0 };//ms
            public static double[] IntPulseOnDelay = new double[MAX_PUMP] { 0, 0 };//s, incorrect unit but working. no change.
            public static double[] IntPulseOffDelay = new double[MAX_PUMP] { 0, 0 };//s, incorrect unit but working. no change.
            public static int[] Pulse = new int[MAX_PUMP] { 1, 1 };
        }

        public static string BiasKernelFile = "";
        public static TBiasKernel BiasKernel = new TBiasKernel();

        public static void LicenseValidation()
        {
            if (GDefine.CheckLic) NDispLicense.TaskDecrypt.UsageExpDelayTime();
        }
        public static void Init()
        {
            Initialized = false;

            Idle.Create();

            string Path = Application.ExecutablePath;
            GDefine.CheckLic = Path.Contains("Lite");

            for (int i = 0; i < MAX_SCRIPT; i++)
            {
                Script[i] = new TScript();
            }

            for (int i = 0; i < MAX_IDS; i++)
            {
                rt_Layouts[i] = new TLayout();
            }

            for (int j = 0; j < TLayout.MAX_UNITS; j++)
            {
                rt_LayoutRelPos[j] = new TPos2();
            }

            for (int j = 0; j < TLayout.MAX_UNITS; j++)
            {
                rt_MapX[j] = new double();
                rt_MapY[j] = new double();
                rt_MapS[j] = new double();
            }

            for (int i = 0; i < MAX_IDS; i++)
            {
                rt_RefDatas[i] = new TRefDatas();
            }

            for (int i = 0; i < MAX_IDS; i++)
                for (int j = 0; j < TLayout.MAX_UNITS; j++)
                {
                    rt_HeightData[i, j] = new THeightData();
                    rt_Read_IDs[i, j] = "";
                }

            for (int i = 0; i < TLayout.MAX_UNITS; i++)
                for (int j = 0; j < MAX_VIS_VI_RESULT_DATA; j++)
                {
                    rt_VisVIResult[i, j] = new List<double>();
                }

            rt_VolumeMap.Clear();

            try
            {
                TaskVision.TaskVisionInit();
            }
            catch
            {
                Initialized = false;
                throw;
            }

            ModelList.LoadSetting(GDefine.ModelSettingFile);

            Initialized = true;
        }
        public static bool CheckInitialized()
        {
            if (Initialized) return true;

            Msg MsgBox = new Msg();
            MsgBox.Show(ErrCode.DISPCORE_NOT_INIT);
            return false;
        }

        public static void NewScript()
        {
            for (int i = 0; i < MAX_SCRIPT; i++)
            {
                Script[i].CmdList = new TCmdList();
            }
            for (int i = 0; i < MAX_IDS; i++)
            {
                Map.PreMap[i].Clear();
            }
            ClearRTDispData();
        }

        public static bool Save(string FullFilename)
        {
            if (FullFilename.EndsWith(GDefine.RecipeExt))
            {
                //return saveXML2(FullFilename);
                //string filename = Path.GetFileNameWithoutExtension(FullFilename);
                //string recipeFilename = GDefine.RecipeDir.FullName + filename + "." + GDefine.RecipeExt;
                return saveXML2(FullFilename);
            }

            if (!CheckInitialized()) return false;

            string _FullFilename = FullFilename;
            if (!_FullFilename.EndsWith(".prg")) _FullFilename = _FullFilename + ".prg";

            string Dir = Path.GetDirectoryName(_FullFilename);
            string Filename = Path.GetFileNameWithoutExtension(_FullFilename);

            GDefine.ProgRecipeName = Filename;

            NSW.Net.IniFile IniFile = new NSW.Net.IniFile();

            IniFile.Create(Dir, Filename + ".prg");
            IniFile.WriteString("Program", "Name", Filename);

            IniFile.WriteInteger("Head", "Operation", (int)Head_Operation);
            IniFile.WriteInteger("Pump", "Type", (int)Pump_Type);
            IniFile.WriteFloat("Head", "PitchX", Head_PitchX);
            IniFile.WriteFloat("Head", "NeedlePitchY", Head_NeedlePitchY);

            IniFile.WriteBool("DispCtrl", "ForceTimeMode", DispCtrl_ForceTimeMode);
            IniFile.WriteBool("Options", "EnableProcessCamera", Options_EnableProcessCamera);
            IniFile.WriteInteger("Options", "VideoLogDuration", Options_VideoLogDuration);
            IniFile.WriteBool("Options", "EnableProcessLog", Options_EnableProcessLog);

            IniFile.WriteFloat("PP", "HeadA_DispBaseVol", PP_HeadA_DispBaseVol);
            IniFile.WriteFloat("PP", "HeadB_DispBaseVol", PP_HeadB_DispBaseVol);
            IniFile.WriteFloat("PP", "HeadA_DispOffsetVol", PP_HeadA_DispVol_Adj);
            IniFile.WriteFloat("PP", "HeadB_DispOffsetVol", PP_HeadB_DispVol_Adj);
            IniFile.WriteFloat("PP", "HeadA_BackSuckVol", PP_HeadA_BackSuckVol);
            IniFile.WriteFloat("PP", "HeadB_BackSuckVol", PP_HeadB_BackSuckVol);
            IniFile.WriteFloat("PP", "HeadA_VolumeRatio", PP_Head_VolumeRatio[0]);
            IniFile.WriteFloat("PP", "HeadB_VolumeRatio", PP_Head_VolumeRatio[1]);
            IniFile.WriteInteger("PP", "Head_DispOffsetTol", PP_Head_DispOffsetTol);
            IniFile.WriteFloat("PP", "Head_DispAdjustReso", PP_Head_DispAdjustReso);

            IniFile.WriteFloat("Pump", "HeadA_Disp_RPM", HM_HeadA_Disp_RPM);
            IniFile.WriteFloat("Pump", "HeadB_Disp_RPM", HM_HeadB_Disp_RPM);
            IniFile.WriteInteger("Pump", "HeadA_Disp_Time", HM_HeadA_Disp_Time);
            IniFile.WriteInteger("Pump", "HeadB_Disp_Time", HM_HeadB_Disp_Time);
            IniFile.WriteFloat("Pump", "HeadA_BSuck_RPM", HM_HeadA_BSuck_RPM);
            IniFile.WriteFloat("Pump", "HeadB_BSuck_RPM", HM_HeadB_BSuck_RPM);
            IniFile.WriteInteger("Pump", "HeadA_BSuck_Time", HM_HeadA_BSuck_Time);
            IniFile.WriteInteger("Pump", "HeadB_BSuck_Time", HM_HeadB_BSuck_Time);

            IniFile.WriteFloat("Pump", "Disp_RPM_AdjMin", HM_Disp_RPM_AdjMin);
            IniFile.WriteFloat("Pump", "Disp_RPM_AdjMax", HM_Disp_RPM_AdjMax);
            IniFile.WriteFloat("Pump", "Disp_Time_AdjMin", HM_Disp_Time_AdjMin);
            IniFile.WriteFloat("Pump", "Disp_Time_AdjMax", HM_Disp_Time_AdjMax);

            IniFile.WriteDouble("Pump", "FPressA", FPress[0]);
            IniFile.WriteDouble("Pump", "FPressB", FPress[1]);
            IniFile.WriteDouble("Pump", "FPressHA", FPressH[0]);
            IniFile.WriteDouble("Pump", "FPressHB", FPressH[1]);
            IniFile.WriteDouble("Pump", "PPressA", PPress[0]);
            IniFile.WriteDouble("Pump", "PPressB", PPress[1]);
            IniFile.WriteFloat("Pump", "FPress_AdjMin", FPress_AdjMin);
            IniFile.WriteFloat("Pump", "FPress_AdjMax", FPress_AdjMax);

            for (int i = 0; i < DispProg.MAX_PUMP; i++)
            {
                IniFile.WriteDouble("Pump", "PJ_OpenTime" + i.ToString(), PJ.OpenTime[i]);
                IniFile.WriteDouble("Pump", "PJ_CloseDelay" + i.ToString(), PJ.CloseDelay[i]);
                IniFile.WriteInteger("Pump", "PJ_Pulse" + i.ToString(), PJ.Pulse[i]);
            }

            for (int i = 0; i < DispProg.MAX_PUMP; i++)
            {
                IniFile.WriteDouble("Pump", "SP_DispTime" + i.ToString(), SP.DispTime[i]);
                IniFile.WriteDouble("Pump", "SP_PulseOnDelay" + i.ToString(), SP.PulseOnDelay[i]);
                IniFile.WriteDouble("Pump", "SP_PulseOffDelay" + i.ToString(), SP.PulseOffDelay[i]);
                IniFile.WriteInteger("Pump", "SP_Pulse" + i.ToString(), SP.Pulse[i]);
            }

            IniFile.WriteFloat("Pump", "Target_Weight", Target_Weight);
            IniFile.WriteFloat("Pump", "Cal_Weight", Cal_Meas_Weight);
            IniFile.WriteFloat("Pump", "Meas_Spec", Meas_Spec);
            IniFile.WriteFloat("Pump", "Meas_Spec_Tol", Meas_Spec_Tol);
            IniFile.WriteFloat("Pump", "Cal_Weight_Tol", Cal_Weight_Tol);

            IniFile.WriteInteger("Pump", "DotsPerSample_Meas", DotsPerSample_Meas);
            IniFile.WriteInteger("Pump", "OutputResult_Meas", (int)OutputResult_Meas);
            IniFile.WriteInteger("Pump", "DotsPerSample_Cal", DotsPerSample_Cal);
            IniFile.WriteInteger("Pump", "OutputResult_Cal", (int)OutputResult_Cal);

            IniFile.WriteInteger("FlowRate", "NoToAve", FlowRate.NoToAve);
            IniFile.WriteInteger("FlowRate", "Duration", FlowRate.Duration);
            IniFile.WriteInteger("FlowRate", "Delay", FlowRate.Delay);
            IniFile.WriteFloat("FlowRate", "MinPressure", FlowRate.MinPressure);
            IniFile.WriteFloat("FlowRate", "MaxPressure", FlowRate.MaxPressure);
            IniFile.WriteFloat("FlowRate", "Target", FlowRate.TargetFlowrate);
            IniFile.WriteFloat("FlowRate", "Tol", FlowRate.TargetFlowRateTol);

            for (int i = 0; i < 4; i++)
            {
                IniFile.WriteDouble("Heater", "SV" + i.ToString(), HeaterSV[i]);
                IniFile.WriteDouble("Heater", "Range" + i.ToString(), HeaterRange[i]);
            }

            IniFile.WriteInteger("PurgeStage", "Count", PurgeStage.Count);
            IniFile.WriteInteger("PurgeStage", "Interval", PurgeStage.Interval);
            IniFile.WriteInteger("PurgeStage", "OnStartCount", PurgeStage.OnStartCount);

            IniFile.WriteString("BiasKernel", "File", BiasKernelFile);

            IniFile.Create(Dir, Filename + ".Product.ini");
            IniFile.WriteInteger("Product", "StationCount", StationCount);
            for (int i = 0; i < DispProg.MAX_STATION_NO; i++)
            {
                IniFile.WriteFloat("Product", "Origin" + i.ToString() + "_X", OriginBase[i].X);
                IniFile.WriteFloat("Product", "Origin" + i.ToString() + "_Y", OriginBase[i].Y);
                IniFile.WriteFloat("Product", "Origin" + i.ToString() + "_Z", OriginBase[i].Z);
            }

            for (int i = 0; i < DispProg.MAX_FOCUS_POS; i++)
            {
                IniFile.WriteFloat("Product", "FocusRelPos" + i.ToString(), FocusRelPos[i]);
            }

            TaskDisp.SaveHPCData(Filename);
            TaskDisp.Vermes3200[0].Save(Filename);
            TaskDisp.Vermes3200[1].Save(Filename);

            for (int i = 0; i < MAX_SCRIPT; i++)
            {
                Script[i].Save(Dir + "\\" + Filename + "_" + i.ToString() + ".ini");
            }
            ModelList.Save(Dir + "\\" + Filename + ".Model.ini");

            TaskVision.SaveTemplates(Dir, Filename);
            TaskVision.SaveBoardImages(Dir, Filename);
            for (int i = 0; i < MAX_IDS; i++)
            {
                Map.PreMap[i].Save(Dir + "\\" + Filename + "_" + i.ToString() + ".PreMap.ini");
            }

            TaskWeight.SaveSetup(DispProg.Pump_Type.ToString());
            TaskDisp.SaveSetup_IOHandShake();

            if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker)
            {
                //TaskVision.frmGenImageView.SaveCamReticles(GDefine.ProgFolder + "\\" + "CamReticles.ini");
            }
            if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2 || GDefine.CameraType[0] is GDefine.ECameraType.MVCGenTL)
                Reticle.SaveCamReticles(GDefine.ProgFolder + "\\" + "CamReticles.ini");

            return true;
        }
        public static bool Save()
        {
            //return SaveProgName(GDefine.ProgRecipeName);
            string fileName = GDefine.ProgPath + "\\" + GDefine.ProgRecipeName + "." + GDefine.ProgExt;
            if (TaskDisp.EnableRecipeFile) fileName = GDefine.RecipeDir.FullName + GDefine.ProgRecipeName + GDefine.RecipeExt;
            return Save(fileName);
        }

        public static bool Load(string fullFilename, bool UpdateDispVol)
        {
            if (!File.Exists(fullFilename))
            {
                Msg MsgBox = new Msg();
                MsgBox.Show("Program File not found.");
                return false;
            }

            string Dir = Path.GetDirectoryName(fullFilename);
            string progName = Path.GetFileNameWithoutExtension(fullFilename);

            Event.OP_DISP_LOAD_DISP_RECIPE.Set("Name", fullFilename);

            //  Check recipe file
            if (fullFilename.EndsWith(GDefine.RecipeExt))
            {
                return loadXML2(fullFilename, UpdateDispVol);
            }

            if (!CheckInitialized()) return false;

            NSW.Net.IniFile IniFile = new NSW.Net.IniFile();

            GDefine.ProgRecipeName = progName;

            IniFile.Create(Dir, progName + ".prg");

            Head_Operation = (TaskDisp.EHeadOperation)IniFile.ReadInteger("Head", "Operation", 0);
            TaskDisp.Head_Operation = Head_Operation;
            Pump_Type = (TaskDisp.EPumpType)IniFile.ReadInteger("Pump", "Type", 0);
            Head_PitchX = IniFile.ReadFloat("Head", "PitchX", 0);
            Head_NeedlePitchY = IniFile.ReadFloat("Head", "NeedlePitchY", 0);

            DispCtrl_ForceTimeMode = IniFile.ReadBool("DispCtrl", "ForceTimeMode", true);
            Options_EnableProcessCamera = IniFile.ReadBool("Options", "EnableProcessCamera", false);
            Options_VideoLogDuration = IniFile.ReadInteger("Options", "VideoLogDuration", 250);
            Options_EnableProcessLog = IniFile.ReadBool("Options", "EnableProcessLog", false);

            if (UpdateDispVol)
            {
                TaskDisp.LoadHPCData(progName);
                TaskDisp.SetDispType(DispProg.Pump_Type);

                TaskDisp.LoadPPDispPara();

                IniFile.Create(Dir, progName + ".prg");
                PP_HeadA_DispBaseVol = IniFile.ReadFloat("PP", "HeadA_DispBaseVol", 0.5);
                PP_HeadB_DispBaseVol = IniFile.ReadFloat("PP", "HeadB_DispBaseVol", 0.5);
                PP_HeadA_DispVol_Adj = IniFile.ReadFloat("PP", "HeadA_DispOffsetVol", 0);
                PP_HeadB_DispVol_Adj = IniFile.ReadFloat("PP", "HeadB_DispOffsetVol", 0);
                PP_HeadA_BackSuckVol = IniFile.ReadFloat("PP", "HeadA_BackSuckVol", 0);
                PP_HeadB_BackSuckVol = IniFile.ReadFloat("PP", "HeadB_BackSuckVol", 0);
                PP_Head_VolumeRatio[0] = IniFile.ReadFloat("PP", "HeadA_VolumeRatio", 1);
                PP_Head_VolumeRatio[1] = IniFile.ReadFloat("PP", "HeadB_VolumeRatio", 1);
                PP_Head_DispOffsetTol = IniFile.ReadInteger("PP", "Head_DispOffsetTol", 5);
                PP_Head_DispAdjustReso = IniFile.ReadFloat("PP", "Head_DispAdjustReso", 0.001);

                HM_HeadA_Disp_RPM = IniFile.ReadFloat("Pump", "HeadA_Disp_RPM", 100);
                HM_HeadB_Disp_RPM = IniFile.ReadFloat("Pump", "HeadB_Disp_RPM", 100);
                HM_HeadA_Disp_Time = IniFile.ReadInteger("Pump", "HeadA_Disp_Time", 0);
                HM_HeadB_Disp_Time = IniFile.ReadInteger("Pump", "HeadB_Disp_Time", 0);
                HM_HeadA_BSuck_RPM = IniFile.ReadFloat("Pump", "HeadA_BSuck_RPM", 0);
                HM_HeadB_BSuck_RPM = IniFile.ReadFloat("Pump", "HeadB_BSuck_RPM", 0);
                HM_HeadA_BSuck_Time = IniFile.ReadInteger("Pump", "HeadA_BSuck_Time", 0);
                HM_HeadB_BSuck_Time = IniFile.ReadInteger("Pump", "HeadB_BSuck_Time", 0);

                HM_Disp_RPM_AdjMin = IniFile.ReadFloat("Pump", "Disp_RPM_AdjMin", 0);
                HM_Disp_RPM_AdjMax = IniFile.ReadFloat("Pump", "Disp_RPM_AdjMax", 0);
                HM_Disp_Time_AdjMin = IniFile.ReadInteger("Pump", "Disp_Time_AdjMin", 0);
                HM_Disp_Time_AdjMax = IniFile.ReadInteger("Pump", "Disp_Time_AdjMax", 0);

                FPress[0] = IniFile.ReadDouble("Pump", "FPressA", 0);
                FPress[1] = IniFile.ReadDouble("Pump", "FPressB", 0);
                FPressH[0] = IniFile.ReadDouble("Pump", "FPressHA", 0);
                FPressH[1] = IniFile.ReadDouble("Pump", "FPressHB", 0);
                PPress[0] = IniFile.ReadDouble("Pump", "PPressA", 0);
                PPress[1] = IniFile.ReadDouble("Pump", "PPressB", 0);
                FPress_AdjMin = IniFile.ReadFloat("Pump", "FPress_AdjMin", 0);
                FPress_AdjMax = IniFile.ReadFloat("Pump", "FPress_AdjMax", 0);

                for (int i = 0; i < 4; i++)
                {
                    HeaterSV[i] = IniFile.ReadDouble("Heater", "SV" + i.ToString(), 0);
                    HeaterRange[i] = IniFile.ReadDouble("Heater", "Range" + i.ToString(), 0);
                }

                for (int i = 0; i < DispProg.MAX_PUMP; i++)
                {
                    PJ.OpenTime[i] = IniFile.ReadDouble("Pump", "PJ_OpenTime" + i.ToString(), 10);
                    PJ.CloseDelay[i] = IniFile.ReadDouble("Pump", "PJ_CloseDelay" + i.ToString(), 10);
                    PJ.Pulse[i] = IniFile.ReadInteger("Pump", "PJ_Pulse" + i.ToString(), 1);
                }

                for (int i = 0; i < DispProg.MAX_PUMP; i++)
                {
                    SP.DispTime[i] = IniFile.ReadDouble("Pump", "SP_DispTime" + i.ToString(), 0);
                    SP.PulseOnDelay[i] = IniFile.ReadDouble("Pump", "SP_PulseOnDelay" + i.ToString(), 0);
                    SP.PulseOffDelay[i] = IniFile.ReadDouble("Pump", "SP_PulseOffDelay" + i.ToString(), 0);
                    SP.Pulse[i] = IniFile.ReadInteger("Pump", "SP_Pulse" + i.ToString(), 1);
                }

                Target_Weight = IniFile.ReadFloat("Pump", "Target_Weight", 0);
                Cal_Meas_Weight = IniFile.ReadFloat("Pump", "Cal_Weight", 0);
                Meas_Spec = IniFile.ReadFloat("Pump", "Meas_Spec", 0);
                Meas_Spec_Tol = IniFile.ReadFloat("Pump", "Meas_Spec_Tol", 0);
                Cal_Weight_Tol = IniFile.ReadFloat("Pump", "Cal_Weight_Tol", 0);

                DotsPerSample_Meas = IniFile.ReadInteger("Pump", "DotsPerSample_Meas", 0);
                OutputResult_Meas = (TaskWeight.EOutputResult)IniFile.ReadInteger("Pump", "OutputResult_Meas", 0);
                DotsPerSample_Cal = IniFile.ReadInteger("Pump", "DotsPerSample_Cal", 0);
                OutputResult_Cal = (TaskWeight.EOutputResult)IniFile.ReadInteger("Pump", "OutputResult_Cal", 0);

                Disp_Weight[0] = Target_Weight;
                Disp_Weight[1] = Target_Weight;

                FlowRate.NoToAve = IniFile.ReadInteger("FlowRate", "NoToAve", 3);
                FlowRate.Duration = IniFile.ReadInteger("FlowRate", "Duration", 2);
                FlowRate.Delay = IniFile.ReadInteger("FlowRate", "Delay", 1);
                FlowRate.MinPressure = IniFile.ReadFloat("FlowRate", "MinPressure", 0.1);
                FlowRate.MaxPressure = IniFile.ReadFloat("FlowRate", "MaxPressure", 0.4);
                FlowRate.TargetFlowrate = IniFile.ReadFloat("FlowRate", "Target", 3.0);
                FlowRate.TargetFlowRateTol = IniFile.ReadFloat("FlowRate", "Tol", 0.1);

                PurgeStage.Count = IniFile.ReadInteger("PurgeStage", "Count", 0);
                PurgeStage.Interval = IniFile.ReadInteger("PurgeStage", "Interval", 0);
                PurgeStage.OnStartCount = IniFile.ReadInteger("PurgeStage", "OnStartCount", 0);

                BiasKernelFile = IniFile.ReadString("BiasKernel", "File", BiasKernelFile);

                switch (DispProg.Pump_Type)
                {
                    case TaskDisp.EPumpType.PP:
                    case TaskDisp.EPumpType.PP2D:
                    case TaskDisp.EPumpType.PPD:
                        {
                            //TaskDisp.Thread_SetDispVolume_Run(true, true, DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj, DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj);
                            //TaskDisp.Thread_SetDispVolume_Wait();
                            TaskDisp.SetDispVolume(true, true, DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj, DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj);
                            TaskDisp.SetBackSuckVolume(true, true, DispProg.PP_HeadA_BackSuckVol, DispProg.PP_HeadB_BackSuckVol);
                            break;
                        }
                    case TaskDisp.EPumpType.HM:
                        {
                            TaskDisp.SetDispSpeed(true, true, DispProg.HM_HeadA_Disp_RPM, DispProg.HM_HeadB_Disp_RPM);
                            TaskDisp.SetBSuckSpeed(true, true, DispProg.HM_HeadA_BSuck_RPM, DispProg.HM_HeadB_BSuck_RPM);
                            TaskDisp.SetBSuckTime(true, true, DispProg.HM_HeadA_BSuck_Time, DispProg.HM_HeadB_BSuck_Time);
                            break;
                        }
                }
            }

            TaskDisp.Vermes3200[0].Load(progName);
            try
            {
                if (TaskDisp.Vermes3200[0].IsOpen)
                {
                    TaskDisp.Vermes3200[0].UpdateHeater();
                    TaskDisp.Vermes3200[0].Set();
                }
            }
            catch (Exception Ex) { MessageBox.Show(Ex.Message.ToString()); }
            TaskDisp.Vermes3200[1].Load(progName);
            try
            {
                if (TaskDisp.Vermes3200[1].IsOpen)
                {
                    {
                        TaskDisp.Vermes3200[1].UpdateHeater();
                        TaskDisp.Vermes3200[1].Set();
                    }
                }
            }
            catch (Exception Ex) { MessageBox.Show(Ex.Message.ToString()); }

            IniFile.Create(Dir, progName + ".Product.ini");
            StationCount = IniFile.ReadInteger("Product", "StationCount", 1);
            for (int i = 0; i < DispProg.MAX_STATION_NO; i++)
            {
                OriginBase[i].X = IniFile.ReadFloat("Product", "Origin" + i.ToString() + "_X", 0);
                OriginBase[i].Y = IniFile.ReadFloat("Product", "Origin" + i.ToString() + "_Y", 0);
                OriginBase[i].Z = IniFile.ReadFloat("Product", "Origin" + i.ToString() + "_Z", 0);
            }
            for (int i = 0; i < DispProg.MAX_FOCUS_POS; i++)
            {
                FocusRelPos[i] = IniFile.ReadFloat("Product", "FocusRelPos" + i.ToString(), 0);
            }

            for (int i = 0; i < MAX_SCRIPT; i++)
            {
                Script[i].Load(Dir + "\\" + progName + "_" + i.ToString() + ".ini");
            }
            ModelList.Load(Dir + "\\" + progName + ".Model.ini");
            TaskVision.LoadTemplates(Dir, progName);
            TaskVision.LoadBoardImages(Dir, progName);
            for (int i = 0; i < MAX_IDS; i++)
            {
                Map.PreMap[i].Load(Dir + "\\" + progName + "_" + i.ToString() + ".PreMap.ini");
            }
            DispProg.ResetMaps();

            if (BiasKernelFile.Length > 0)
            {
                if (!BiasKernel.Load(GDefine.BiasKernelPath + "\\" + BiasKernelFile + ".txt"))
                {
                    Msg MsgBox = new Msg();
                    MsgBox.Show("Load BiasKernel File " + BiasKernelFile + " Fail.");
                    return false;
                }
                else
                    Log.AddToLog("Load BiasKernel File " + BiasKernelFile + ".");
            }

            double d1 = TaskDisp.Head_PitchX;
            double d2 = TaskDisp.Head_NeedlePitchY;
            rt_PromptedSingleHeadRun = false;

            try
            {
                FPressCtrl.SetPress_MPa(FPress);
            }
            catch (Exception Ex)
            {
                MessageBox.Show(Ex.Message.ToString());
            }

            for (int i = 0; i < 4 - 1; i++)
            {
                TempCtrl.Set(i, HeaterSV[i], HeaterRange[i]);
            }
            TempCtrl.Run();


            if (Target_Weight > 0)
                TaskDisp.PP_SetWeight(Disp_Weight, true, false);

            TaskWeight.LoadSetup(DispProg.Pump_Type.ToString());
            TaskDisp.LoadSetup_IOHandShake();

            if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker)
            {
             //   TaskVision.frmGenImageView.LoadCamReticles(GDefine.ProgFolder + "\\" + "CamReticles.ini");
            }
            if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2 || GDefine.CameraType[0] is GDefine.ECameraType.MVCGenTL)
                Reticle.LoadCamReticles(GDefine.ProgFolder + "\\" + "CamReticles.ini");


            string recipeFile = GDefine.RecipeDir.FullName + progName + GDefine.RecipeExt;
            if (TaskDisp.EnableRecipeFile && !File.Exists(recipeFile))
            {
                //saveXML2(FullFilename);
                //string filename = Path.GetFileNameWithoutExtension(FullFilename);
                //string recipeFilename = GDefine.RecipeDir.FullName + filename + "." + GDefine.RecipeExt;
                return saveXML2(recipeFile);
            }

            DispProg.RefreshProg = true;

            return true;
        }
        public static bool LoadProgName(string progName)
        {
            string fileName = GDefine.ProgPath + "\\" + progName + "." + GDefine.ProgExt;
            if (TaskDisp.EnableRecipeFile) fileName = GDefine.RecipeDir.FullName + progName + GDefine.RecipeExt;
            return Load(fileName, true);
        }

        internal static void WriteSubEntry(XmlWriter writer, string subEntryName, string subEntryValue)
        {
            writer.WriteStartElement("subentry");
            writer.WriteAttributeString("name", subEntryName);
            writer.WriteString(subEntryValue);
            writer.WriteEndElement();
        }
        internal static void WriteSubEntry(XmlWriter writer, string subEntryName, double subEntryValue)
        {
            writer.WriteStartElement("subentry");
            writer.WriteAttributeString("name", subEntryName);
            writer.WriteString(subEntryValue.ToString());
            writer.WriteEndElement();
        }
        internal static void WriteSubEntry(XmlWriter writer, string subEntryName, string[] value)
        {
            writer.WriteStartElement("subentry");
            writer.WriteAttributeString("name", subEntryName);
            string val = "";
            for (int i = 0; i < value.Length; i++) val = val + value[i] + ",";
            writer.WriteString(val);
            writer.WriteEndElement();
        }
        internal static void WriteSubEntry(XmlWriter writer, string subEntryName, int[] value)
        {
            writer.WriteStartElement("subentry");
            writer.WriteAttributeString("name", subEntryName);
            string val = "";
            for (int i = 0; i < value.Length; i++) val = val + value[i].ToString() + ",";
            writer.WriteString(val);
            writer.WriteEndElement();
        }
        internal static void WriteSubEntry(XmlWriter writer, string subEntryName, double[] value)
        {
            writer.WriteStartElement("subentry");
            writer.WriteAttributeString("name", subEntryName);
            string val = "";
            for (int i = 0; i < value.Length; i++) val = val + value[i].ToString() + ",";
            writer.WriteString(val);
            writer.WriteEndElement();
        }
        internal static void WriteSubEntry(XmlWriter writer, string subEntryName, Bitmap bmp)
        {
            writer.WriteStartElement("subentry");
            writer.WriteAttributeString("name", subEntryName);
            ImageConverter converter = new ImageConverter();
            byte[] bytes = (byte[])converter.ConvertTo(bmp, typeof(byte[]));
            string datas = Convert.ToBase64String(bytes);
            writer.WriteString(datas);
            writer.WriteEndElement();
        }
        public static bool saveXML2(string fullFilename)
        {
            if (!CheckInitialized()) return false;

            string filename = Path.GetFileNameWithoutExtension(fullFilename);
            GDefine.ProgRecipeName = filename;

            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
            xmlWriterSettings.OmitXmlDeclaration = true;
            xmlWriterSettings.Indent = true;

            XmlWriter writer = XmlWriter.Create(fullFilename, xmlWriterSettings);

            writer.WriteStartDocument();

            writer.WriteStartElement("root");

            #region  chapter = Program
            writer.WriteStartElement("chapter");
            writer.WriteAttributeString("name", "Program");

            #region section = General
            writer.WriteStartElement("section");
            writer.WriteAttributeString("name", "General");

            writer.WriteStartElement("entry");
            writer.WriteAttributeString("name", "General");

            WriteSubEntry(writer, "Name", filename);

            writer.WriteEndElement();//end section
            writer.WriteEndElement();//end entry
            #endregion

            #region section = Setting
            writer.WriteStartElement("section");
            writer.WriteAttributeString("name", "Setting");
            {
                #region section = Head
                writer.WriteStartElement("entry");
                writer.WriteAttributeString("name", "Head");

                WriteSubEntry(writer, "Operation", (int)Head_Operation);
                WriteSubEntry(writer, "PitchX", Head_PitchX.ToString());
                WriteSubEntry(writer, "NeedlePitchY", Head_NeedlePitchY.ToString());

                writer.WriteEndElement();//end entry
                #endregion

                #region section = Pump
                writer.WriteStartElement("entry");
                writer.WriteAttributeString("name", "Pump");

                WriteSubEntry(writer, "Type", (int)Pump_Type);
                WriteSubEntry(writer, "Disp_RPM", new double[2] { HM_HeadA_Disp_RPM, HM_HeadB_Disp_RPM });
                WriteSubEntry(writer, "Disp_Time", new double[2] { HM_HeadA_Disp_Time, HM_HeadB_Disp_Time });
                WriteSubEntry(writer, "BSuck_RPM", new double[2] { HM_HeadA_BSuck_RPM, HM_HeadB_BSuck_RPM });
                WriteSubEntry(writer, "BSuck_Time", new double[2] { HM_HeadA_BSuck_Time, HM_HeadB_BSuck_Time });
                WriteSubEntry(writer, "Disp_RPM_Adj", new double[2] { HM_Disp_RPM_AdjMin, HM_Disp_RPM_AdjMax });
                WriteSubEntry(writer, "Disp_Time_Adj", new double[2] { HM_Disp_Time_AdjMin, HM_Disp_Time_AdjMax });

                WriteSubEntry(writer, "FPress", FPress);
                WriteSubEntry(writer, "FPress_Adj", new double[2] { FPress_AdjMin, FPress_AdjMax });
                WriteSubEntry(writer, "FPressH", FPressH);
                WriteSubEntry(writer, "FPressH_Timer", FPressH_Timer);
                WriteSubEntry(writer, "PPress", PPress);
                WriteSubEntry(writer, "PPress_Adj", new double[2] { PPress_AdjMin, PPress_AdjMax });

                WriteSubEntry(writer, "PJ_OpenTime", PJ.OpenTime);
                WriteSubEntry(writer, "PJ_CloseDelay", PJ.CloseDelay);
                WriteSubEntry(writer, "PJ_Pulse", PJ.Pulse);

                WriteSubEntry(writer, "SP_DispTime", SP.DispTime);
                WriteSubEntry(writer, "SP_PulseOnDelay", SP.PulseOnDelay);
                WriteSubEntry(writer, "SP_PulseOffDelay", SP.PulseOffDelay);
                WriteSubEntry(writer, "SP_Pulse", SP.Pulse);

                WriteSubEntry(writer, "Target_Weight", Target_Weight);
                WriteSubEntry(writer, "Cal_Weight", Cal_Meas_Weight);
                WriteSubEntry(writer, "Meas_Spec", Meas_Spec);
                WriteSubEntry(writer, "Meas_Spec_Tol", Meas_Spec_Tol);
                WriteSubEntry(writer, "Cal_Weight_Tol", Cal_Weight_Tol);

                WriteSubEntry(writer, "DotsPerSample_Meas", DotsPerSample_Meas);
                WriteSubEntry(writer, "OutputResult_Meas", (int)OutputResult_Meas);
                WriteSubEntry(writer, "DotsPerSample_Cal", DotsPerSample_Cal);
                WriteSubEntry(writer, "OutputResult_Cal", (int)OutputResult_Cal);

                writer.WriteEndElement();//end entry
                #endregion

                #region section = Pump
                writer.WriteStartElement("entry");
                writer.WriteAttributeString("name", "Flowrate");

                WriteSubEntry(writer, "NoToAve", FlowRate.NoToAve);
                WriteSubEntry(writer, "Duration", FlowRate.Duration);
                WriteSubEntry(writer, "Delay", FlowRate.Delay);
                WriteSubEntry(writer, "MinPressure", FlowRate.MinPressure);
                WriteSubEntry(writer, "MaxPressure", FlowRate.MaxPressure);
                WriteSubEntry(writer, "EnableTargetFlowrate", FlowRate.EnableTargetFlowRate?1:0);
                WriteSubEntry(writer, "Target", FlowRate.TargetFlowrate);
                WriteSubEntry(writer, "Tol", FlowRate.TargetFlowRateTol);
                WriteSubEntry(writer, "EnableAutoCalFrame", FlowRate.EnableAutoCalFrame ? 1 : 0);
                WriteSubEntry(writer, "AutoCalFrameInterval", FlowRate.AutoCalFrameInterval);
                WriteSubEntry(writer, "EnableAutoCalUnit", FlowRate.EnableAutoCalUnit ? 1 : 0);
                WriteSubEntry(writer, "AutoCalUnitInterval", FlowRate.AutoCalUnitInterval);
                WriteSubEntry(writer, "MaterialSlope", FlowRate.MaterialSlope);
                WriteSubEntry(writer, "MaterialIntercept", FlowRate.MaterialIntercept);
                WriteSubEntry(writer, "TimeCompensate", FlowRate.TimeCompensate);

                writer.WriteEndElement();//end entry
                #endregion

                #region section = DispCtrl
                writer.WriteStartElement("entry");
                writer.WriteAttributeString("name", "DispCtrl");

                WriteSubEntry(writer, "ForceTimeMode", DispCtrl_ForceTimeMode.ToString());

                writer.WriteEndElement();//end entry
                #endregion

                #region section = PP
                writer.WriteStartElement("entry");
                writer.WriteAttributeString("name", "PP");

                WriteSubEntry(writer, "DispBaseVol", new double[2] { PP_HeadA_DispBaseVol, PP_HeadB_DispBaseVol });
                WriteSubEntry(writer, "DispVol_Adj", new double[2] { PP_HeadA_DispVol_Adj, PP_HeadB_DispVol_Adj });
                WriteSubEntry(writer, "BackSuckVol", new double[2] { PP_HeadA_BackSuckVol, PP_HeadB_BackSuckVol });
                WriteSubEntry(writer, "VolumeRatio", PP_Head_VolumeRatio);
                WriteSubEntry(writer, "DispOffsetTol", PP_Head_DispOffsetTol);
                WriteSubEntry(writer, "DispAdjustReso", PP_Head_DispAdjustReso);

                writer.WriteEndElement();//end entry
                #endregion


                #region section = Options
                writer.WriteStartElement("entry");
                writer.WriteAttributeString("name", "Options");

                WriteSubEntry(writer, "EnableProcessLog", Options_EnableProcessLog.ToString());
                WriteSubEntry(writer, "EnableProcessCamera", Options_EnableProcessCamera.ToString());
                WriteSubEntry(writer, "VideoLogDuration", Options_VideoLogDuration.ToString());
                WriteSubEntry(writer, "WaitCameraReady", Options_WaitCameraReady.ToString());
                WriteSubEntry(writer, "CheckBoardYield", Options_CheckBoardYield.ToString());

                writer.WriteEndElement();//end entry
                #endregion

                #region section = Heater
                writer.WriteStartElement("entry");
                writer.WriteAttributeString("name", "Heater");

                WriteSubEntry(writer, "SV", HeaterSV);
                WriteSubEntry(writer, "Range", HeaterRange);

                writer.WriteEndElement();//end entry
                #endregion

                #region section = PurgeStage
                writer.WriteStartElement("entry");
                writer.WriteAttributeString("name", "PurgeStage");

                WriteSubEntry(writer, "Count", PurgeStage.Count);
                WriteSubEntry(writer, "Interval", PurgeStage.Interval);
                WriteSubEntry(writer, "OnStartCount", PurgeStage.OnStartCount);

                writer.WriteEndElement();//end entry
                #endregion

                #region section = BiasKernel
                writer.WriteStartElement("entry");
                writer.WriteAttributeString("name", "BiasKernel");

                WriteSubEntry(writer, "File", BiasKernelFile);

                writer.WriteEndElement();//end entry
                #endregion
            }
            writer.WriteEndElement();//end section
            #endregion

            #region section = Product
            writer.WriteStartElement("section");
            writer.WriteAttributeString("name", "Product");
            {
                #region entry = Station
                writer.WriteStartElement("entry");
                writer.WriteAttributeString("name", "Station");

                WriteSubEntry(writer, "Count", StationCount.ToString());

                writer.WriteEndElement();//end entry
                #endregion

                #region entry = Origin
                writer.WriteStartElement("entry");
                writer.WriteAttributeString("name", "Origin");
                for (int i = 0; i < DispProg.MAX_STATION_NO; i++)
                {
                    WriteSubEntry(writer, i.ToString(), new double[] { OriginBase[i].X, OriginBase[i].Y, OriginBase[i].Z });
                }

                writer.WriteEndElement();//end entry
                #endregion

                #region entry = Product
                writer.WriteStartElement("entry");
                writer.WriteAttributeString("name", "Product");

                WriteSubEntry(writer, "FocusRelPos", FocusRelPos);

                writer.WriteEndElement();//end entry
                #endregion
            }
            writer.WriteEndElement();//end section
            #endregion

            if (GDefine.DispCtrlType[0] == GDefine.EDispCtrlType.HPC15)
            {
                try
                {
                    if (TaskDisp.HPC_15[0].IsOpen)
                    {
                        writer.WriteStartElement("section");
                        writer.WriteAttributeString("name", "HPC_Ctrl");
                        TaskDisp.HPC_15[0].saveRecipeXML(writer);
                        writer.WriteEndElement();//end section
                    }
                }
                catch { };
            }
            if (GDefine.DispCtrlType[1] == GDefine.EDispCtrlType.HPC15)
            {
                try
                {
                    if (TaskDisp.HPC_15[1].IsOpen)
                    {
                        writer.WriteStartElement("section");
                        writer.WriteAttributeString("name", "HPC_Ctrl1");
                        TaskDisp.HPC_15[1].saveRecipeXML(writer);
                        writer.WriteEndElement();//end section
                    }
                }
                catch { };
            }

            writer.WriteStartElement("section");
            writer.WriteAttributeString("name", "Vermes");
            TaskDisp.Vermes3200[0].saveXML(writer);
            writer.WriteEndElement();//end section

            writer.WriteStartElement("section");
            writer.WriteAttributeString("name", "Vermes2");
            TaskDisp.Vermes3200[1].saveXML(writer);
            writer.WriteEndElement();//end section

            if (GDefine.DispCtrlType[0] == GDefine.EDispCtrlType.Vermes1560 || GDefine.DispCtrlType[1] == GDefine.EDispCtrlType.Vermes1560)
            {
                try
                {
                    writer.WriteStartElement("section");
                    writer.WriteAttributeString("name", "Vermes1560");
                    writer.WriteStartElement("entry");

                    if (GDefine.DispCtrlType[0] == GDefine.EDispCtrlType.Vermes1560)
                    {
                        writer.WriteAttributeString("name", "Ctrl0");
                        WriteSubEntry(writer, "OT", TaskDisp.Vermes1560[0].OT);
                        WriteSubEntry(writer, "CT", TaskDisp.Vermes1560[0].CT);
                        WriteSubEntry(writer, "NP", TaskDisp.Vermes1560[0].NP);
                        WriteSubEntry(writer, "Target", TaskDisp.Vermes1560[0].Target);
                    }

                    if (GDefine.DispCtrlType[1] == GDefine.EDispCtrlType.Vermes1560)
                    {
                        writer.WriteAttributeString("name", "Ctrl1");
                        WriteSubEntry(writer, "OT", TaskDisp.Vermes1560[1].OT);
                        WriteSubEntry(writer, "CT", TaskDisp.Vermes1560[1].CT);
                        WriteSubEntry(writer, "NP", TaskDisp.Vermes1560[1].NP);
                        WriteSubEntry(writer, "Target", TaskDisp.Vermes1560[1].Target);
                    }

                    writer.WriteEndElement();
                    writer.WriteEndElement();
                }
                catch { };
            }

            if (GDefine.DispHeaterType[0] == GDefine.EDispHeaterType.Vermes_HC48)
            {
                try
                {
                    writer.WriteStartElement("section");
                    writer.WriteAttributeString("name", "Vermes_HC48");
                    writer.WriteStartElement("entry");

                    writer.WriteAttributeString("name", "Ctrl0");
                    WriteSubEntry(writer, "Target", TaskDisp.Vermes_HC48[0].Target);
                    WriteSubEntry(writer, "Tolerance", TaskDisp.Vermes_HC48[0].Tolerance);

                    writer.WriteEndElement();
                    writer.WriteEndElement();
                }
                catch { };
            }
            
            for (int i = 0; i < MAX_SCRIPT; i++)
            {
                writer.WriteStartElement("section");
                writer.WriteAttributeString("name", "Script" + i.ToString());
                Script[i].SaveXML(writer);
                writer.WriteEndElement();//end section
            }

            writer.WriteStartElement("section");
            writer.WriteAttributeString("name", "Model");
            ModelList.SaveXML(writer);
            writer.WriteEndElement();//end section

            writer.WriteStartElement("section");
            writer.WriteAttributeString("name", "Vision");
            TaskVision.SaveTemplatesXML(writer);
            writer.WriteEndElement();//end section

            writer.WriteStartElement("section");
            writer.WriteAttributeString("name", "Script");
            writer.WriteStartElement("entry");
            writer.WriteAttributeString("name", "Premap");
            int maxUnit = 0;
            for (int i = 0; i < MAX_IDS; i++)
            {
                maxUnit = Math.Max(maxUnit, rt_Layouts[i].TUCount);
            }
            for (int i = 0; i < MAX_IDS; i++)
            {
                if (TaskDisp.Preference == TaskDisp.EPreference.Lumileds)
                    Map.PreMap[i].SaveXML(writer, i, maxUnit);
                else
                    Map.PreMap[i].SaveXML(writer, i, rt_Layouts[i].TUCount);
            }
            writer.WriteEndElement();//end entry
            writer.WriteEndElement();//end section

            writer.WriteEndElement();//end chapter
            #endregion

            #region  chapter = NVision
            writer.WriteStartElement("chapter");
            writer.WriteAttributeString("name", "NVision");
            for (int i = 0; i < MAX_IDS; i++)
            {
                VisionTools[i].SaveXML(writer, i.ToString());
            }
            writer.WriteEndElement();//end chapter
            #endregion

            if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2 || GDefine.CameraType[0] is GDefine.ECameraType.MVCGenTL)
                Reticle.saveCamReticlesXML(writer);

            writer.WriteEndDocument();
            writer.Close();

            if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker)
            {
                //TaskVision.frmGenImageView.saveCamReticlesXML(fullFilename, "Program", "Vision");
            }
            TaskWeight.SaveSetup(DispProg.Pump_Type.ToString());
            TaskDisp.SaveSetup_IOHandShake();
            TaskFlowRate.SaveDefault();

            return true;
        }

        internal static string ReadSubEntry(XmlReader reader, string defValue)
        {
            reader.Read();
            string res = defValue;
            try
            {
                res = reader.Value;
                res = res.Trim();
            }
            catch { };
            return res;
        }
        internal static int ReadSubEntry(XmlReader reader, int defValue)
        {
            reader.Read();
            int res = defValue;
            try
            {
                res = Convert.ToInt32(reader.Value);
            }
            catch { };
            return res;
        }
        internal static double ReadSubEntry(XmlReader reader, double defValue)
        {
            reader.Read();
            double res = defValue;
            try
            {
                res = Convert.ToDouble(reader.Value);
            }
            catch { };
            return res;
        }
        internal static string[] ReadSubEntry(XmlReader reader, string[] defValue)
        {
            reader.Read();
            string sVal = reader.Value;

            string[] res = (string[])defValue.Clone();
            string[] val = sVal.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
            for (int i = 0; i < Math.Min(val.Length, res.Length); i++)
            {
                res[i] = val[i];
            }
            return res;
        }
        internal static int[] ReadSubEntry(XmlReader reader, int[] defValue)
        {
            reader.Read();
            string sVal = reader.Value;

            int[] res = (int[])defValue.Clone();
            string[] val = sVal.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
            for (int i = 0; i < Math.Min(val.Length, res.Length); i++)
            {
                try
                {
                    res[i] = int.Parse(val[i]);
                }
                catch { };
            }
            return res;
        }
        internal static double[] ReadSubEntry(XmlReader reader, double[] defValue)
        {
            reader.Read();
            string sVal = reader.Value;

            double[] res = (double[])defValue.Clone();
            string[] val = sVal.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
            for (int i = 0; i < Math.Min(val.Length, res.Length); i++)
            {
                try
                {
                    res[i] = double.Parse(val[i]);
                }
                catch { };
            }
            return res;
        }
        internal static Bitmap ReadSubEntry(XmlReader reader, Bitmap defValue)
        {
            reader.Read();
            byte[] res = Convert.FromBase64String(reader.Value);
            if (res.Length == 0) return defValue;
            using (MemoryStream ms = new MemoryStream(res))
            {
                return new Bitmap(ms);
            }
        }
        public static bool loadXML2(string FullFilename, bool UpdateDispVol)
        {
            if (!CheckInitialized()) return false;

            string _FullFilename = FullFilename;

            string Filename = Path.GetFileNameWithoutExtension(_FullFilename);

            GDefine.ProgRecipeName = Filename;

            string recipeFile = FullFilename;

            if (!File.Exists(FullFilename))
            {
                Msg MsgBox = new Msg();
                MsgBox.Show("Recipe file not found.");
                return false;
            }

            Head_Operation = TaskDisp.EHeadOperation.Single;
            Head_PitchX = 0;
            Head_NeedlePitchY = 0;
            DispCtrl_ForceTimeMode = false;

            using (XmlReader reader = XmlReader.Create(_FullFilename))
            {
                while (reader.Read())
                {
                    // Only detect start elements.
                    //if (reader.IsStartElement())
                    {
                        #region chapter = Program
                        if (reader.Name == "chapter" && reader["name"] == "Program")
                        {
                            while (reader.Read())
                            {
                                if (reader.Name == "chapter" && reader.MoveToContent() == XmlNodeType.EndElement) break;
                                string attValue = reader["name"];

                                #region section = Setting
                                if (reader.Name == "section" && reader["name"] == "Setting")
                                {
                                    while (reader.Read())
                                    {
                                        if (reader.Name == "section" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                        #region entry = Head
                                        if (reader.Name == "entry" && reader["name"] == "Head")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    switch (attName)
                                                    {
                                                        case "Operation":
                                                            try
                                                            {
                                                                reader.Read();
                                                                Head_Operation = (TaskDisp.EHeadOperation)Convert.ToInt32(reader.Value);
                                                            }
                                                            catch { };
                                                            TaskDisp.Head_Operation = Head_Operation;
                                                            break;
                                                        case "PitchX":
                                                            try
                                                            {
                                                                reader.Read();
                                                                Head_PitchX = Convert.ToDouble(reader.Value);
                                                            }
                                                            catch { };
                                                            break;

                                                        case "NeedlePitchY":
                                                            try
                                                            {
                                                                reader.Read();
                                                                Head_NeedlePitchY = Convert.ToDouble(reader.Value);
                                                            }
                                                            catch { };
                                                            break;
                                                    }
                                                }
                                            }
                                        }
                                        #endregion
                                        #region entry = DispCtrl
                                        if (reader.Name == "entry" && reader["name"] == "DispCtrl")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    switch (attName)
                                                    {
                                                        case "ForceTimeMode":
                                                            try
                                                            {
                                                                reader.Read();
                                                                DispCtrl_ForceTimeMode = Convert.ToBoolean(reader.Value);
                                                            }
                                                            catch { };
                                                            break;
                                                    }
                                                }
                                            }
                                        }
                                        #endregion

                                        #region entry = Options
                                        if (reader.Name == "entry" && reader["name"] == "Options")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    switch (attName)
                                                    {
                                                        case "EnableProcessLog":
                                                            try
                                                            {
                                                                reader.Read();
                                                                Options_EnableProcessLog = Convert.ToBoolean(reader.Value);
                                                            }
                                                            catch { };
                                                            break;
                                                        case "EnableProcessCamera":
                                                            try
                                                            {
                                                                reader.Read();
                                                                Options_EnableProcessCamera = Convert.ToBoolean(reader.Value);
                                                            }
                                                            catch { };
                                                            break;
                                                        case "WaitCameraReady":
                                                            try
                                                            {
                                                                reader.Read();
                                                                Options_WaitCameraReady = Convert.ToBoolean(reader.Value);
                                                            }
                                                            catch { };
                                                            break;
                                                        case "VideoLogDuration":
                                                            try
                                                            {
                                                                reader.Read();
                                                                Options_VideoLogDuration = Convert.ToInt32(reader.Value);
                                                            }
                                                            catch { };
                                                            break;
                                                        case "CheckBoardYield":
                                                            try
                                                            {
                                                                reader.Read();
                                                                Options_CheckBoardYield = Convert.ToDouble(reader.Value);
                                                            }
                                                            catch { };
                                                            break;
                                                    }
                                                }
                                            }
                                        }
                                        #endregion

                                        #region entry = PP
                                        if (UpdateDispVol && reader.Name == "entry" && reader["name"] == "PP")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    double[] d = new double[2];
                                                    switch (attName)
                                                    {
                                                        case "DispBaseVol":
                                                            d = ReadSubEntry(reader, new double[2] { 0.5, 0.5 });
                                                            PP_HeadA_DispBaseVol = d[0];
                                                            PP_HeadB_DispBaseVol = d[1];
                                                            break;
                                                        case "DispVol_Adj":
                                                            d = ReadSubEntry(reader, new double[2] { 0, 0 });
                                                            PP_HeadA_DispVol_Adj = d[0];
                                                            PP_HeadB_DispVol_Adj = d[1];
                                                            break;
                                                        case "BackSuckVol":
                                                            d = ReadSubEntry(reader, new double[2] { 0, 0 });
                                                            PP_HeadA_BackSuckVol = d[0];
                                                            PP_HeadB_BackSuckVol = d[1];
                                                            break;
                                                        case "VolumeRatio":
                                                            PP_Head_VolumeRatio = ReadSubEntry(reader, new double[2] { 1, 1 });
                                                            break;
                                                        case "DispOffsetTol":
                                                            PP_Head_DispOffsetTol = ReadSubEntry(reader, 5);
                                                            break;
                                                        case "DispAdjustReso":
                                                            PP_Head_DispAdjustReso = ReadSubEntry(reader, 0.001);
                                                            break;
                                                    }
                                                }
                                            }
                                        }
                                        #endregion
                                        #region entry = Pump
                                        if (UpdateDispVol && reader.Name == "entry" && reader["name"] == "Pump")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    double[] d = new double[2];
                                                    int[] iVal = new int[2];
                                                    switch (attName)
                                                    {
                                                        case "Type":
                                                            Pump_Type = TaskDisp.EPumpType.None;
                                                            try
                                                            {
                                                                Pump_Type = (TaskDisp.EPumpType)ReadSubEntry(reader, (int)Pump_Type);
                                                            }
                                                            catch { };
                                                            break;
                                                        case "Disp_RPM":
                                                            d = ReadSubEntry(reader, new double[2] { 100, 100 });
                                                            HM_HeadA_Disp_RPM = d[0];
                                                            HM_HeadB_Disp_RPM = d[1];
                                                            break;
                                                        case "Disp_Time":
                                                            iVal = ReadSubEntry(reader, new int[2] { 0, 0 });
                                                            HM_HeadA_Disp_Time = iVal[0];
                                                            HM_HeadB_Disp_Time = iVal[1];
                                                            break;
                                                        case "BSuck_RPM":
                                                            d = ReadSubEntry(reader, new double[2] { 0, 0 });
                                                            HM_HeadA_BSuck_RPM = d[0];
                                                            HM_HeadB_BSuck_RPM = d[1];
                                                            break;
                                                        case "BSuck_Time":
                                                            iVal = ReadSubEntry(reader, new int[2] { 0, 0 });
                                                            HM_HeadA_BSuck_Time = iVal[0];
                                                            HM_HeadB_BSuck_Time = iVal[1];
                                                            break;
                                                        case "Disp_RPM_Adj":
                                                            d = ReadSubEntry(reader, new double[2] { 0, 0 });
                                                            HM_Disp_RPM_AdjMin = d[0];
                                                            HM_Disp_RPM_AdjMax = d[1];
                                                            break;
                                                        case "Disp_Time_Adj":
                                                            iVal = ReadSubEntry(reader, new int[2] { 0, 0 });
                                                            HM_Disp_Time_AdjMin = iVal[0];
                                                            HM_Disp_Time_AdjMax = iVal[1];
                                                            break;
                                                        case "FPress":
                                                            FPress = ReadSubEntry(reader, new double[2] { 0, 0 });
                                                            break;
                                                        case "FPress_Adj":
                                                            d = ReadSubEntry(reader, new double[2] { 0, 0 });
                                                            FPress_AdjMin = d[0];
                                                            FPress_AdjMax = d[1];
                                                            break;
                                                        case "FPressH":
                                                            FPressH = ReadSubEntry(reader, new double[2] { 0, 0 });
                                                            break;
                                                        case "FPressH_Timer":
                                                            FPressH_Timer = ReadSubEntry(reader, 0);
                                                            break;
                                                        case "PPress":
                                                            PPress = ReadSubEntry(reader, new double[2] { 0, 0 });
                                                            break;
                                                        case "PPress_Adj":
                                                            d = ReadSubEntry(reader, new double[2] { 0, 0 });
                                                            PPress_AdjMin = d[0];
                                                            PPress_AdjMax = d[1];
                                                            break;

                                                        case "PJ_OpenTime":
                                                            PJ.OpenTime = ReadSubEntry(reader, new double[2] { 10, 10 });
                                                            break;
                                                        case "PJ_CloseDelay":
                                                            PJ.CloseDelay = ReadSubEntry(reader, new double[2] { 10, 10 });
                                                            break;
                                                        case "PJ_Pulse":
                                                            PJ.Pulse = ReadSubEntry(reader, new int[2] { 1, 1 });
                                                            break;

                                                        case "SP_DispTime":
                                                            SP.DispTime = ReadSubEntry(reader, new double[2] { 5, 5 });
                                                            break;
                                                        case "SP_PulseOnDelay":
                                                            SP.PulseOnDelay = ReadSubEntry(reader, new double[2] { 0, 0 });
                                                            break;
                                                        case "SP_PulseOffDelay":
                                                            SP.PulseOffDelay = ReadSubEntry(reader, new double[2] { 0, 0 });
                                                            break;
                                                        case "SP_Pulse":
                                                            SP.Pulse = ReadSubEntry(reader, new int[2] { 1, 1 });
                                                            break;

                                                        case "Target_Weight":
                                                            Target_Weight = ReadSubEntry(reader, (double)0);
                                                            Disp_Weight[0] = Target_Weight;
                                                            Disp_Weight[1] = Target_Weight;
                                                            break;
                                                        case "Cal_Weight":
                                                            Cal_Meas_Weight = ReadSubEntry(reader, (double)0); break;
                                                        case "Meas_Spec":
                                                            Meas_Spec = ReadSubEntry(reader, (double)0); break;
                                                        case "Meas_Spec_Tol":
                                                            Meas_Spec_Tol = ReadSubEntry(reader, (double)0); break;
                                                        case "Cal_Weight_Tol":
                                                            Cal_Weight_Tol = ReadSubEntry(reader, (double)0); break;

                                                        case "DotsPerSample_Meas":
                                                            DotsPerSample_Meas = ReadSubEntry(reader, 0); break;
                                                        case "OutputResult_Meas":
                                                            OutputResult_Meas = TaskWeight.EOutputResult.Total;
                                                            try
                                                            {
                                                                OutputResult_Meas = (TaskWeight.EOutputResult)ReadSubEntry(reader, 0);
                                                            }
                                                            catch { };
                                                            break;
                                                        case "DotsPerSample_Cal":
                                                            DotsPerSample_Cal = ReadSubEntry(reader, 0); break;
                                                        case "OutputResult_Cal":
                                                            OutputResult_Cal = TaskWeight.EOutputResult.Total;
                                                            try
                                                            {
                                                                OutputResult_Cal = (TaskWeight.EOutputResult)ReadSubEntry(reader, 0);
                                                            }
                                                            catch { };
                                                            break;
                                                    }
                                                }
                                            }
                                        }
                                        #endregion
                                        #region entry = FlowRate
                                        if (reader.Name == "entry" && reader["name"] == "Flowrate")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    switch (attName)
                                                    {
                                                        case "NoToAve":
                                                            FlowRate.NoToAve = ReadSubEntry(reader, 3);
                                                            break;
                                                        case "Duration":
                                                            FlowRate.Duration = ReadSubEntry(reader, 3);
                                                            break;
                                                        case "Delay":
                                                            FlowRate.Delay = ReadSubEntry(reader, 1);
                                                            break;
                                                        case "MinPressure":
                                                            FlowRate.MinPressure = ReadSubEntry(reader, 0.01);
                                                            break;
                                                        case "MaxPressure":
                                                            FlowRate.MaxPressure = ReadSubEntry(reader, 0.45);
                                                            break;
                                                        case "EnableTargetFlowrate":
                                                            int i = ReadSubEntry(reader, 0);
                                                            FlowRate.EnableTargetFlowRate = i > 0;
                                                            break;
                                                        case "Target":
                                                            FlowRate.TargetFlowrate = ReadSubEntry(reader, 1.0);
                                                            break;
                                                        case "Tol":
                                                            FlowRate.TargetFlowRateTol = ReadSubEntry(reader, 0.1);
                                                            break;
                                                        case "EnableAutoCalFrame":
                                                            FlowRate.EnableAutoCalFrame = ReadSubEntry(reader, 0) > 0;
                                                            break;
                                                        case "AutoCalFrameInterval":
                                                            FlowRate.AutoCalFrameInterval = ReadSubEntry(reader, 10);
                                                            break;
                                                        case "EnableAutoCalUnit":
                                                            FlowRate.EnableAutoCalUnit = ReadSubEntry(reader, 0) > 0;
                                                            break;
                                                        case "AutoCalUnitInterval":
                                                            FlowRate.AutoCalUnitInterval = ReadSubEntry(reader, 12);
                                                            break;
                                                        case "MaterialSlope":
                                                            FlowRate.MaterialSlope = ReadSubEntry(reader, (double)0);
                                                            break;
                                                        case "MaterialIntercept":
                                                            FlowRate.MaterialIntercept = ReadSubEntry(reader, (double)0);
                                                            break;
                                                        case "TimeCompensate":
                                                            FlowRate.TimeCompensate = ReadSubEntry(reader, (double)0);
                                                            break;
                                                    }
                                                }
                                            }
                                        }
                                        #endregion
                                        #region entry = Heater,PurgeStage,BiasKernel
                                        if (reader.Name == "entry" && reader["name"] == "Heater")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    double[] d = new double[4];
                                                    switch (attName)
                                                    {
                                                        case "SV":
                                                            HeaterSV = ReadSubEntry(reader, new double[4] { 0, 0, 0, 0 }); break;
                                                        case "Range":
                                                            HeaterRange = ReadSubEntry(reader, new double[4] { 0, 0, 0, 0 }); break;
                                                    }
                                                }
                                            }
                                        }

                                        if (reader.Name == "entry" && reader["name"] == "PurgeStage")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    switch (attName)
                                                    {
                                                        case "Count":
                                                            PurgeStage.Count = ReadSubEntry(reader, 0); break;
                                                        case "Interval":
                                                            PurgeStage.Interval = ReadSubEntry(reader, 0); break;
                                                        case "OnStartCount":
                                                            PurgeStage.OnStartCount = ReadSubEntry(reader, 0); break;
                                                    }
                                                }
                                            }
                                        }

                                        if (reader.Name == "entry" && reader["name"] == "BiasKernel")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    switch (attName)
                                                    {
                                                        case "File":

                                                            BiasKernelFile = ReadSubEntry(reader, ""); break;
                                                    }
                                                }
                                            }
                                        }
                                        #endregion
                                    }
                                }
                                #endregion
                                #region section = Product
                                if (reader.Name == "section" && reader["name"] == "Product")
                                {
                                    string sectionAtt = reader["name"];

                                    while (reader.Read())
                                    {
                                        if (reader.Name == "section" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                        if (reader.Name == "entry" && reader["name"] == "Station")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    switch (attName)
                                                    {
                                                        case "Count":
                                                            StationCount = ReadSubEntry(reader, 1); break;
                                                    }
                                                }
                                            }
                                        }

                                        if (reader.Name == "entry" && reader["name"] == "Origin")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    double[] d_arr3 = new double[3] { 0, 0, 0 };
                                                    switch (attName)
                                                    {
                                                        case "0":
                                                            d_arr3 = ReadSubEntry(reader, d_arr3);
                                                            OriginBase[0].X = d_arr3[0];
                                                            OriginBase[0].Y = d_arr3[1];
                                                            OriginBase[0].Z = d_arr3[2];
                                                            break;
                                                        case "1":
                                                            d_arr3 = ReadSubEntry(reader, d_arr3);
                                                            OriginBase[1].X = d_arr3[0];
                                                            OriginBase[1].Y = d_arr3[1];
                                                            OriginBase[1].Z = d_arr3[2];
                                                            break;
                                                        case "2":
                                                            d_arr3 = ReadSubEntry(reader, d_arr3);
                                                            OriginBase[2].X = d_arr3[0];
                                                            OriginBase[2].Y = d_arr3[1];
                                                            OriginBase[2].Z = d_arr3[2];
                                                            break;
                                                        case "3":
                                                            d_arr3 = ReadSubEntry(reader, d_arr3);
                                                            OriginBase[3].X = d_arr3[0];
                                                            OriginBase[3].Y = d_arr3[1];
                                                            OriginBase[3].Z = d_arr3[2];
                                                            break;
                                                        case "4":
                                                            d_arr3 = ReadSubEntry(reader, d_arr3);
                                                            OriginBase[4].X = d_arr3[0];
                                                            OriginBase[4].Y = d_arr3[1];
                                                            OriginBase[4].Z = d_arr3[2];
                                                            break;
                                                        case "5":
                                                            d_arr3 = ReadSubEntry(reader, d_arr3);
                                                            OriginBase[5].X = d_arr3[0];
                                                            OriginBase[5].Y = d_arr3[1];
                                                            OriginBase[5].Z = d_arr3[2];
                                                            break;
                                                        case "6":
                                                            d_arr3 = ReadSubEntry(reader, d_arr3);
                                                            OriginBase[6].X = d_arr3[0];
                                                            OriginBase[6].Y = d_arr3[1];
                                                            OriginBase[6].Z = d_arr3[2];
                                                            break;
                                                        case "7":
                                                            d_arr3 = ReadSubEntry(reader, d_arr3);
                                                            OriginBase[7].X = d_arr3[0];
                                                            OriginBase[7].Y = d_arr3[1];
                                                            OriginBase[7].Z = d_arr3[2];
                                                            break;
                                                    }
                                                }
                                            }
                                        }

                                        if (reader.Name == "entry" && reader["name"] == "Product")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    switch (attName)
                                                    {
                                                        case "FocusRelPos":
                                                            FocusRelPos = ReadSubEntry(reader, new double[4] { 0, 0, 0, 0 });
                                                            break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                #endregion

                                #region section = HPC_Ctrl Vermes
                                if (UpdateDispVol && reader.Name == "section" && reader["name"] == "HPC_Ctrl")
                                {
                                    if (GDefine.DispCtrlType[0] == GDefine.EDispCtrlType.HPC15)
                                        try
                                        {
                                            if (TaskDisp.HPC_15[0].IsOpen)
                                            {
                                                TaskDisp.HPC_15[0].loadRecipeXML(reader);
                                                TaskDisp.HPC_15[0].UploadToCtrl();

                                                TaskDisp.HM_Max_RPM = TaskDisp.HPC_15[0].HM_Max_RPM;
                                            }
                                        }
                                        catch { };
                                }
                                if (UpdateDispVol && reader.Name == "section" && reader["name"] == "HPC_Ctrl1")
                                {
                                    if (GDefine.DispCtrlType[1] == GDefine.EDispCtrlType.HPC15)
                                        try
                                        {
                                            if (TaskDisp.HPC_15[1].IsOpen)
                                            {
                                                TaskDisp.HPC_15[1].loadRecipeXML(reader);
                                                TaskDisp.HPC_15[1].UploadToCtrl();

                                                TaskDisp.HM_Max_RPM = TaskDisp.HPC_15[1].HM_Max_RPM;
                                            }
                                        }
                                        catch { };
                                }

                                if (reader.Name == "section" && reader["name"] == "Vermes")
                                {
                                    TaskDisp.Vermes3200[0].loadXML(reader);
                                    try
                                    {
                                        if (TaskDisp.Vermes3200[0].IsOpen)
                                        {
                                            TaskDisp.Vermes3200[0].UpdateHeater();
                                            TaskDisp.Vermes3200[0].Set();
                                        }
                                    }
                                    catch (Exception Ex) { MessageBox.Show(Ex.Message.ToString()); }
                                }
                                if (reader.Name == "section" && reader["name"] == "Vermes2")
                                {
                                    TaskDisp.Vermes3200[1].loadXML(reader);
                                    try
                                    {
                                        if (TaskDisp.Vermes3200[1].IsOpen)
                                        {
                                            TaskDisp.Vermes3200[1].UpdateHeater();
                                            TaskDisp.Vermes3200[1].Set();
                                        }
                                    }
                                    catch (Exception Ex) { MessageBox.Show(Ex.Message.ToString()); }
                                }
                                if (reader.Name == "section" && reader["name"] == "Vermes1560")
                                {
                                    while (reader.Read())
                                    {
                                        if (reader.Name == "section" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                        if (reader.Name == "entry" && reader["name"] == "Ctrl0")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    switch (attName)
                                                    {
                                                        case "OT":
                                                            TaskDisp.Vermes1560[0].OT = ReadSubEntry(reader, TaskDisp.Vermes1560[0].OT); break;
                                                        case "CT":
                                                            TaskDisp.Vermes1560[0].CT = ReadSubEntry(reader, TaskDisp.Vermes1560[0].CT); break;
                                                        case "NP":
                                                            TaskDisp.Vermes1560[0].NP = ReadSubEntry(reader, TaskDisp.Vermes1560[0].NP); break;
                                                        case "Target":
                                                            TaskDisp.Vermes1560[0].Target = ReadSubEntry(reader, TaskDisp.Vermes1560[0].Target); break;
                                                    }
                                                }
                                            }
                                        }
                                        if (reader.Name == "entry" && reader["name"] == "Ctrl1")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    switch (attName)
                                                    {
                                                        case "OT":
                                                            TaskDisp.Vermes1560[1].OT = ReadSubEntry(reader, TaskDisp.Vermes1560[1].OT); break;
                                                        case "CT":
                                                            TaskDisp.Vermes1560[1].CT = ReadSubEntry(reader, TaskDisp.Vermes1560[1].CT); break;
                                                        case "NP":
                                                            TaskDisp.Vermes1560[1].NP = ReadSubEntry(reader, TaskDisp.Vermes1560[1].NP); break;
                                                        case "Target":
                                                            TaskDisp.Vermes1560[1].Target = ReadSubEntry(reader, TaskDisp.Vermes1560[1].Target); break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    try
                                    {
                                        if (TaskDisp.Vermes1560[0].IsOpen)
                                        {
                                            TaskDisp.Vermes1560[0].UpdateSetup();
                                            TaskDisp.Vermes1560[0].SetTarget();
                                        }
                                    }
                                    catch (Exception Ex) { MessageBox.Show(Ex.Message.ToString()); }
                                    try
                                    {
                                        if (TaskDisp.Vermes1560[1].IsOpen)
                                        {
                                            TaskDisp.Vermes1560[1].UpdateSetup();
                                            TaskDisp.Vermes1560[1].SetTarget();
                                        }
                                        }
                                    catch (Exception Ex) { MessageBox.Show(Ex.Message.ToString()); }
                                }
                                if (reader.Name == "section" && reader["name"] == "Vermes_HC48")
                                {
                                    while (reader.Read())
                                    {
                                        if (reader.Name == "section" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                        if (reader.Name == "entry" && reader["name"] == "Ctrl0")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    switch (attName)
                                                    {
                                                        case "Target":
                                                            TaskDisp.Vermes_HC48[0].Target = ReadSubEntry(reader, TaskDisp.Vermes_HC48[0].Target); break;
                                                        case "Tolerance":
                                                            TaskDisp.Vermes_HC48[0].Tolerance = ReadSubEntry(reader, TaskDisp.Vermes_HC48[0].Tolerance); break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    try
                                    {
                                        if (TaskDisp.Vermes_HC48[0].IsOpen)
                                            TaskDisp.Vermes_HC48[0].SetTarget(TaskDisp.Vermes_HC48[0].Target);
                                    }
                                    catch (Exception Ex) { MessageBox.Show(Ex.Message.ToString()); }
                                }
                                #endregion

                                string section = reader["name"];

                                if (reader.Name == "section" && reader["name"] == "Script0") Script[0].LoadXML(reader);
                                if (reader.Name == "section" && reader["name"] == "Script1") Script[1].LoadXML(reader);
                                if (reader.Name == "section" && reader["name"] == "Script2") Script[2].LoadXML(reader);
                                if (reader.Name == "section" && reader["name"] == "Script3") Script[3].LoadXML(reader);

                                if (reader.Name == "section" && reader["name"] == "Model") ModelList.LoadXML(reader);

                                if (reader.Name == "section" && reader["name"] == "Vision")
                                {
                                    TaskVision.LoadTemplatesXML(reader);
                                }

                                #region section = Script
                                bool bExit = false;
                                if (reader.Name == "section" && reader["name"] == "Script")
                                {
                                    while (reader.Read())
                                    {
                                        if (reader.Name == "section" && reader.MoveToContent() == XmlNodeType.EndElement)
                                        {
                                            bExit = true;
                                            break;
                                        }

                                        if (reader.Name == "entry" && reader["name"] == "Premap")
                                        {
                                            while (reader.Read())
                                            {
                                                if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                                int iNo = -1;
                                                if (reader.Name == "subentry")
                                                {
                                                    string attName = reader["name"];

                                                    switch (attName)
                                                    {
                                                        case "0":
                                                        case "1":
                                                        case "2":
                                                        case "3":
                                                        case "4":
                                                        case "5":
                                                        case "6":
                                                        case "7":
                                                        case "8":
                                                        case "9":
                                                        case "10":
                                                        case "11":
                                                        case "12":
                                                        case "13":
                                                        case "14":
                                                        case "15":
                                                            iNo = int.Parse(attName);
                                                            break;
                                                    }

                                                    if (iNo >= 0) Map.PreMap[iNo].LoadXML(reader, iNo);
                                                }
                                            }
                                        }
                                    }
                                }
                                #endregion
                                if (bExit) break;
                            }
                        }
                        #endregion

                        if (reader.Name == "chapter" && reader["name"] == "NVision")
                        {
                            for (int i = 0; i < MAX_IDS; i++)
                            {
                                VisionTools[i].LoadXML(reader, i.ToString());
                            }
                        }

                        if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2 || GDefine.CameraType[0] is GDefine.ECameraType.MVCGenTL)
                        {
                            if (reader.Name == "chapter" && reader["name"] == "Vision")
                                Reticle.loadCamReticlesXML(reader);
                        }
                    }
                }
            }

            if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker)
            {
                //TaskVision.frmGenImageView.loadCamReticlesXML(recipeFile, "Program", "Vision");
            }

            if (UpdateDispVol)
            {
                TaskDisp.SetDispType(DispProg.Pump_Type);
                TaskDisp.LoadPPDispPara();

                switch (DispProg.Pump_Type)
                {
                    case TaskDisp.EPumpType.PP:
                    case TaskDisp.EPumpType.PP2D:
                    case TaskDisp.EPumpType.PPD:
                        {
                            //TaskDisp.Thread_SetDispVolume_Run(true, true, DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj, DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj);
                            //TaskDisp.Thread_SetDispVolume_Wait();
                            TaskDisp.SetDispVolume(true, true, DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj, DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj);
                            TaskDisp.SetBackSuckVolume(true, true, DispProg.PP_HeadA_BackSuckVol, DispProg.PP_HeadB_BackSuckVol);
                            break;
                        }
                    case TaskDisp.EPumpType.HM:
                        {
                            TaskDisp.SetDispSpeed(true, true, DispProg.HM_HeadA_Disp_RPM, DispProg.HM_HeadB_Disp_RPM);
                            TaskDisp.SetBSuckSpeed(true, true, DispProg.HM_HeadA_BSuck_RPM, DispProg.HM_HeadB_BSuck_RPM);
                            TaskDisp.SetBSuckTime(true, true, DispProg.HM_HeadA_BSuck_Time, DispProg.HM_HeadB_BSuck_Time);
                            break;
                        }
                }
            }

            DispProg.ResetMaps();

            if (BiasKernelFile.Length > 0)
            {
                if (!BiasKernel.Load(GDefine.BiasKernelPath + "\\" + BiasKernelFile + ".txt"))
                {
                    Msg MsgBox = new Msg();
                    MsgBox.Show("Load BiasKernel File " + BiasKernelFile + " Fail.");
                    DispProg.RefreshProg = true;
                    return false;
                }
                else
                    Log.AddToLog("Load BiasKernel File " + BiasKernelFile + ".");
            }

            double d1 = TaskDisp.Head_PitchX;
            double d2 = TaskDisp.Head_NeedlePitchY;
            rt_PromptedSingleHeadRun = false;

            //if (UpdateDispVol)
            //    LogPump.LoadProgram(LogPump.ELoadProgType.Manual);
            //else
            //    LogPump.LoadProgram(LogPump.ELoadProgType.Auto);

            try
            {
                FPressCtrl.SetPress_MPa(FPress);
            }
            catch (Exception Ex)
            {
                MessageBox.Show(Ex.Message.ToString());
            }

            for (int i = 0; i < 4 - 1; i++)
            {
                TempCtrl.Set(i, HeaterSV[i], HeaterRange[i]);
            }
            TempCtrl.Run();

            if (Target_Weight > 0)
                TaskDisp.PP_SetWeight(Disp_Weight, true, false);

            TaskWeight.LoadSetup(DispProg.Pump_Type.ToString());
            TaskDisp.LoadSetup_IOHandShake();
            TaskFlowRate.LoadDefault();

            DispProg.RefreshProg = true;

            return true;
        }


        public static ERunMode RunMode = ERunMode.Camera;
        public static ERunStationNo rt_StationNo = ERunStationNo.Station1;
        public static ERunRegion rt_RunRegion = ERunRegion.All;

        public static bool BdReady = false;
        public static EBoardStatus BdStatus = EBoardStatus.None;

        static ERunStationNo LastRunStationNo = ERunStationNo.Station1;

        public static void OnStop()
        {
        }

        public static bool TR_Run()
        {
            if (Idle.Purging) Idle.StopPurge();

            Log.AddToLog("DispCore TR_Run.");
            string EMsg = "DispCore TR_Run.";

            if (GDefine.Status == EStatus.ErrorInit) return false;
            if (Script[0].IsBusy) return false;

            if (LastRunStationNo != rt_StationNo) ClearRTDispData();
            LastRunStationNo = rt_StationNo;

            BdReady = false;

            TaskDisp.TaskMoveCamOffsetHeadNo = -1;

            int cycles = 0;
            switch (DispProg.Pump_Type)
            {
                case TaskDisp.EPumpType.None:
                case TaskDisp.EPumpType.Single:
                case TaskDisp.EPumpType.TP:
                case TaskDisp.EPumpType.TPRV:
                    break;
                default:
                    if (!TaskDisp.DispCtrlOpened(0)) TaskDisp.OpenDispCtrl(0);
                    break;
            }
            if (TaskDisp.Vermes3200[0].IsOpen) cycles = TaskDisp.Vermes3200[0].ValveCycles;
            if (TaskDisp.Vermes1560[0].IsOpen) cycles = TaskDisp.Vermes1560[0].ValveCycles;

            TaskDisp.FPressOn(new bool[2] { true, TaskDisp.Head_Operation == TaskDisp.EHeadOperation.Sync });

            try
            {
                TaskDisp.TaskMoveGZZ2Up();

                if (!Script[0].IsBusy)
                    if (!Script[0].Run(RunMode, Origin(rt_StationNo).X, Origin(rt_StationNo).Y, Origin(rt_StationNo).Z, false, false))// goto _Stop;
                    {
                        TR_Pause();
                        return false;
                    }

                if (GDefine.Status == EStatus.Stop) return false;
            }
            catch (Exception Ex)
            {
                try
                {
                    TaskDisp.TaskMoveGZZ2Up();
                }
                catch { };

                GDefine.Status = EStatus.ErrorInit;
                TR_Cancel();

                EMsg = EMsg + (char)13 + Ex.Message.ToString();
                Msg MsgBox = new Msg();
                MsgBox.Show(ErrCode.UNKNOWN_EX_ERR, EMsg);
                return false;
            }
            finally
            {
                if (TaskDisp.Vermes3200[0].IsOpen)
                {
                    int runCycles = TaskDisp.Vermes3200[0].ValveCycles - cycles;
                    NDispWin.Material.Unit.Count[0] += runCycles;
                }
                if (TaskDisp.Vermes1560[0].IsOpen)
                {
                    int runCycles = TaskDisp.Vermes1560[0].ValveCycles - cycles;
                    NDispWin.Material.Unit.Count[0] += runCycles;
                }

                TaskDisp.FPressOff();
            }
            if (!TaskDisp.TaskMoveGZFocus(0)) return false;
            return true;
        }
        public static bool TR_Pause()
        {
            Log.AddToLog("DispCore TR_Pause.");

            string EMsg = "StopScript";
            try
            {
                for (int i = MAX_SCRIPT - 1; i >= 0; i--)                {
                    DispProg.Script[i].Pause();
                }
            }
            catch (Exception Ex)
            {
                EMsg = EMsg + (char)13 + Ex.Message.ToString();
                Msg MsgBox = new Msg();
                MsgBox.Show(ErrCode.UNKNOWN_EX_ERR, EMsg);
                return false;
            }
            return true;
        }
        public static bool TR_Cancel()
        {
            Log.AddToLog("DispCore TR_Cancel.");

            string EMsg = "StopScript";
            try
            {
                for (int i = MAX_SCRIPT - 1; i >= 0; i--)
                {
                    DispProg.Script[i].Stop();
                }
                ClearRTDispData();
            }
            catch (Exception Ex)
            {
                EMsg = EMsg + (char)13 + Ex.Message.ToString();
                Msg MsgBox = new Msg();
                MsgBox.Show(ErrCode.UNKNOWN_EX_ERR, EMsg);
                return false;
            }
            return true;
        }
        public static bool TR_IsBusy()
        {
            return DispProg.Script[0].IsBusy;
        }

        public static bool rt_PromptedSingleHeadRun = false;

        static bool[] rtLoopActive = new bool[MAX_IDS];
        static int[] rtLoopLineNo = new int[MAX_IDS];

        public static TLayout[] rt_Layouts = new TLayout[MAX_IDS];
        public static int rt_LayoutCount = 1;//no of used rt_Layout 
        public static int rt_LayoutID = 0;//current LayoutID
        public static bool rt_LayoutChanged = true;//need to Refresh Layout

        public static bool rt_SyncHead2 = false;//in SyncHead2 mode

        static TRefDatas[] rt_RefDatas = new TRefDatas[MAX_IDS];
        public static TRefData rt_Head1RefData = new TRefData();
        public static TRefData rt_Head2RefData = new TRefData();

        public static Emgu.CV.Image<Emgu.CV.Structure.Bgr, byte> FoundDoRef1 = null;
        public static double FoundDoRef1_X, FoundDoRef1_Y, FoundDoRef1_S;
        public static bool FoundDoRef1_OK;
        public static Emgu.CV.Image<Emgu.CV.Structure.Bgr, byte> FoundDoRef2 = null;
        public static double FoundDoRef2_X, FoundDoRef2_Y, FoundDoRef2_S;
        public static bool FoundDoRef2_OK;

        static THeightData[,] rt_HeightData = new THeightData[MAX_IDS, TLayout.MAX_UNITS];
        static THeightData rt_Head1HeightData = new THeightData();
        static THeightData rt_Head2HeightData = new THeightData();

        public static bool rt_Singulated = false;
        public static string[,] rt_Read_IDs = new string[MAX_IDS, TLayout.MAX_UNITS];

        static int MAX_VIS_VI_RESULT_DATA = 10;
        static List<double>[,] rt_VisVIResult = new List<double>[TLayout.MAX_UNITS, 10];

        public static int LastLine = -1;
        static bool b_InLoop = false;//if in loop, not allow to stop until NEXT

        static TPos2 rt_Start = new TPos2();
        public static TPos2[] rt_LayoutRelPos = new TPos2[TLayout.MAX_UNITS];
        public static Point rt_RepeatCR = new Point(0, 0);
        static PointF rt_RepeatOfst = new PointF(0, 0);

        static List<double> rt_MeasL_HData = new List<double>();
        static TaskMeasureH.MeasL_H_Data_Arr rt_HDataArr = new TaskMeasureH.MeasL_H_Data_Arr();

        static TaskMeasMen.Datas rt_MeniscusDatas = new TaskMeasMen.Datas();

        public static double rt_Head1VolumeOfst = 0;
        public static double rt_Head2VolumeOfst = 0;
        public static TVolumeMap rt_VolumeMap = new TVolumeMap();
        public static bool rt_VolumeOfst = false;//command exist in program
        public static EVolumeOfstMode rt_VolumeOfst_Mode = EVolumeOfstMode.Manual;
        public static string rt_VolumeOfst_Path = "";
        public static List<int> rt_VolComp = new List<int>();//***store LineNo that consist PP_VolComp

        public static bool b_ForceHead1 = false;
        public static bool b_ForceHead2 = false;

        public static class RunTime
        {
            public static int UIndex = 0;//unit index
            public static int UIndex2 = 0;//head 2 unit index
            public static Point[] Head_CR = new Point[2] { new Point(0, 0), new Point(0, 0) };
            public static Point Bias_Head_CR = new Point(0, 0);//support single head only, invert to match excel orientation
        }

        public static NVision.frm_CameraView frm_CamView = new NVision.frm_CameraView();
        public static NVision.TVisTools[] VisionTools = new NVision.TVisTools[MAX_IDS];
        internal static bool SaveDoVisionImages = false;
        internal static string ImageLocation = @"c:\Image";
        //trace mode
        public static bool RefreshProg = false;
        public static bool TraceMode = false;
        public static int TracedLine = -1;//selected trace line
        public static void SetTracePos()
        {
            if (TracedLine == -1) return;

            //DialogResult dr = MessageBox.Show("Set Trace Position?", "", MessageBoxButtons.YesNo);

            Msg MsgBox = new Msg();
            EMsgRes MsgRes = MsgBox.Show("Set Trace Position?", EMcState.Notice, EMsgBtn.smbOK_Cancel, false);
            if (MsgRes == EMsgRes.smrOK)
            {
                //if (dr == DialogResult.Yes)
                //{
                NSW.Net.Point2D Old = new NSW.Net.Point2D(Script[0].CmdList.Line[TracedLine].X[0], Script[0].CmdList.Line[TracedLine].Y[0]);

                double X = TaskGantry.GXPos();
                double Y = TaskGantry.GYPos();

                Script[0].CmdList.Line[TracedLine].X[0] = X - (DispProg.Origin(DispProg.rt_StationNo).X);// + SubOrigin.X);
                Script[0].CmdList.Line[TracedLine].Y[0] = Y - (DispProg.Origin(DispProg.rt_StationNo).Y);// + SubOrigin.Y);
                RefreshProg = true;

                NSW.Net.Point2D New = new NSW.Net.Point2D(Script[0].CmdList.Line[TracedLine].X[0], Script[0].CmdList.Line[TracedLine].Y[0]);

                Log.OnSet(Script[0].CmdList.Line[TracedLine].Cmd + ", Set Traced XY", Old, New);

                TracedLine = -1;
            }
        }

        public static double[] pressVal = new double[] { 0, 0 };//Current press value
        public static bool fPoolVermes = false;//flag to enable Vermes to pool temp, prevent timeout when vermes is Jetting
        public static double[] progDispVol = new double[] { 0, 0 };//Current program dispense volume press value

        public class TScript
        {
            public TScript()
            {
                for (int i = 0; i < MAX_IDS; i++)
                {
                    rtLoopActive[i] = false;
                    rtLoopLineNo[i] = 0;
                }

                for (int i = 0; i < MAX_IDS; i++)
                {
                    //VisionTools[i] = new NVision.TVisGrpPara();
                    VisionTools[i] = new NVision.TVisTools();
                }
            }

            public void Init()
            {
                rt_RunRegion = ERunRegion.All;
            }

            public void Save(string Filename)
            {
                try
                {
                    FileStream F = new FileStream(Filename, FileMode.Create, FileAccess.Write, FileShare.Write);
                    StreamWriter W = new StreamWriter(F);

                    W.WriteLine(CmdList.Count);

                    for (int lines = 0; lines < CmdList.Count; lines++)
                    {
                        #region
                        TLine Line = new TLine();
                        Line = CmdList.Line[lines];

                        int Cmd = (int)Line.Cmd;
                        int ID = Line.ID;
                        string String = Line.String;

                        string S0 = lines.ToString() + (char)9 + "0" + (char)9 + Cmd.ToString() + (char)9 + ID.ToString() + (char)9 + String + (char)9;
                        W.WriteLine(S0);

                        string S1 = lines.ToString() + (char)9 + "1" + (char)9;
                        W.WriteLine(S1);

                        string S2 = lines.ToString() + (char)9 + "2" + (char)9;
                        for (int i = 0; i < TLine.MAX_PARA; i++)
                        {
                            S2 = S2 + Line.IPara[i].ToString() + (char)9;
                        }
                        W.WriteLine(S2);

                        string S3 = lines.ToString() + (char)9 + "3" + (char)9;
                        for (int i = 0; i < TLine.MAX_PARA; i++)
                        {
                            S3 = S3 + Line.DPara[i].ToString("F4") + (char)9;
                        }
                        W.WriteLine(S3);

                        string S4 = lines.ToString() + (char)9 + "4" + (char)9;
                        for (int i = 0; i < TLine.MAX_PARA; i++)
                        {
                            S4 = S4 + Line.Index[i].ToString() + (char)9;
                        }
                        W.WriteLine(S4);

                        string S5 = lines.ToString() + (char)9 + "5" + (char)9;
                        for (int i = 0; i < TLine.MAX_PARA; i++)
                        {
                            S5 = S5 + Line.X[i].ToString("F4") + (char)9;
                        }
                        W.WriteLine(S5);

                        string S6 = lines.ToString() + (char)9 + "6" + (char)9;
                        for (int i = 0; i < TLine.MAX_PARA; i++)
                        {
                            S6 = S6 + Line.Y[i].ToString("F4") + (char)9;
                        }
                        W.WriteLine(S6);

                        string S7 = lines.ToString() + (char)9 + "7" + (char)9;
                        for (int i = 0; i < TLine.MAX_PARA; i++)
                        {
                            S7 = S7 + Line.Z[i].ToString("F4") + (char)9;
                        }
                        W.WriteLine(S7);

                        string S8 = lines.ToString() + (char)9 + "8" + (char)9;
                        for (int i = 0; i < TLine.MAX_PARA; i++)
                        {
                            S8 = S8 + Line.U[i].ToString("F4") + (char)9;
                        }
                        W.WriteLine(S8);

                        string S9 = lines.ToString() + (char)9 + "9" + (char)9;
                        for (int i = 0; i < TLine.MAX_PARA; i++)
                        {
                            S9 = S9 + Line.A[i].ToString("F4") + (char)9;
                        }
                        W.WriteLine(S9);

                        string S10 = lines.ToString() + (char)9 + "10" + (char)9;
                        for (int i = 0; i < TLine.MAX_PARA; i++)
                        {
                            S10 = S10 + Line.B[i].ToString("F4") + (char)9;
                        }
                        W.WriteLine(S10);

                        string S11 = lines.ToString() + (char)9 + "11" + (char)9;
                        for (int i = 0; i < TLine.MAX_PARA; i++)
                        {
                            S11 = S11 + Line.C[i].ToString("F4") + (char)9;
                        }
                        W.WriteLine(S11);

                        string S12 = lines.ToString() + (char)9 + "12" + (char)9;
                        for (int i = 0; i < TLine.MAX_PARA; i++)
                        {
                            S12 = S12 + Line.D[i].ToString("F4") + (char)9;
                        }
                        W.WriteLine(S12);

                        string S13 = lines.ToString() + (char)9 + "13" + (char)9;
                        for (int i = 0; i < TLine.MAX_PARA; i++)
                        {
                            S13 = S13 + Line.Cond[i].ToString() + (char)9;
                        }
                        W.WriteLine(S13);
                        #endregion
                    }
                    W.Close();

                    string Dir = Path.GetDirectoryName(Filename);
                    string FileName = Path.GetFileNameWithoutExtension(Filename) + "_Vision";

                    for (int i = 0; i < MAX_IDS; i++)
                    {
                        string VisFilename = Dir + "\\" + FileName + "_" + i.ToString() + ".ini";
                        VisionTools[i].Save(VisFilename);
                    }
                }
                catch
                {
                }
            }
            public void SaveXML(string fileName, int scriptNo)
            {
                NUtils.XmlFile xmlFile = new NUtils.XmlFile(fileName, "Recipe");
                try
                {
                    xmlFile.Open();
                    xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), "General", "CmdlistCount", CmdList.Count);

                    for (int lines = 0; lines < CmdList.Count; lines++)
                    {
                        TLine Line = new TLine();
                        Line = CmdList.Line[lines];

                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "Cmd", (int)Line.Cmd);
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "CmdString", Line.Cmd.ToString());
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "ID", Line.ID);
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "String", Line.String);
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "IPara", Line.IPara);
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "DPara", Line.DPara);
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "Index", Line.Index);
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "X", Line.X);
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "Y", Line.Y);
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "Z", Line.Z);
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "U", Line.U);
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "A", Line.A);
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "B", Line.B);
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "C", Line.C);
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "D", Line.D);
                        xmlFile.SetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "Cond", Line.Cond);
                    }
                }
                catch
                {
                }
                finally
                {
                    xmlFile.Save();
                }

                for (int i = 0; i < MAX_IDS; i++)
                {
                    VisionTools[i].SaveXML(fileName, "root", "NVision", i.ToString());
                }
            }
            public void SaveXML(XmlWriter writer)
            {
                writer.WriteStartElement("entry");
                writer.WriteAttributeString("name", "General");
                WriteSubEntry(writer, "CmdlistCount", CmdList.Count);
                writer.WriteEndElement();//endentry

                for (int lines = 0; lines < CmdList.Count; lines++)
                {
                    TLine Line = new TLine();
                    Line = CmdList.Line[lines];

                    writer.WriteStartElement("entry");
                    writer.WriteAttributeString("name", lines.ToString());

                    WriteSubEntry(writer, "Cmd", (int)Line.Cmd);
                    WriteSubEntry(writer, "CmdString", Line.Cmd.ToString());
                    WriteSubEntry(writer, "ID", Line.ID);
                    WriteSubEntry(writer, "String", Line.String);
                    WriteSubEntry(writer, "IPara", Line.IPara);
                    WriteSubEntry(writer, "DPara", Line.DPara);
                    WriteSubEntry(writer, "Index", Line.Index);
                    WriteSubEntry(writer, "X", Line.X);
                    WriteSubEntry(writer, "Y", Line.Y);
                    WriteSubEntry(writer, "Z", Line.Z);
                    WriteSubEntry(writer, "U", Line.U);
                    WriteSubEntry(writer, "A", Line.A);
                    WriteSubEntry(writer, "B", Line.B);
                    WriteSubEntry(writer, "C", Line.C);
                    WriteSubEntry(writer, "D", Line.D);
                    WriteSubEntry(writer, "Cond", Line.Cond);

                    writer.WriteEndElement();//endentry
                }

                //for (int i = 0; i < MAX_IDS; i++)
                //{
                //    VisionTools[i].SaveXML(fileName, "root", "NVision", i.ToString());
                //}
            }

            public bool Load(string Filename)
            {
                if (!File.Exists(Filename)) return false;

                DrawOffset_Reset();

                FileStream F = new FileStream(Filename, FileMode.Open, FileAccess.ReadWrite, FileShare.Write);
                StreamReader R = new StreamReader(F);

                string FileLine = R.ReadToEnd();
                R.Close();

                string[] Lines = FileLine.Split(new char[] { (char)10 }, StringSplitOptions.RemoveEmptyEntries);

                for (int Line = 1; Line < Lines.Count(); Line++)
                {
                    #region
                    string[] s = Lines[Line].Split((char)9);

                    int CmdNo = 0;
                    try
                    {
                        s[0] = s[0].Trim();
                        CmdNo = Convert.ToInt16(s[0]);
                    }
                    catch { }

                    int ParaNo = 0;
                    try
                    {
                        s[1] = s[1].Trim();
                        ParaNo = Convert.ToInt16(s[1]);
                    }
                    catch { }

                    CmdList.Count = CmdNo + 1;

                    string[] S = new string[100];
                    for (int i = 0; i < 100; i++)
                    {
                        if (i < s.Length - 2)
                        {
                            S[i] = s[i + 2];
                        }
                        else
                            S[i] = "";
                    }

                    if (ParaNo == 0)//Cmd.Cmd, Cmd.ID and Cmd.String
                    {
                        #region
                        try
                        {
                            S[0] = S[0].Trim();
                            CmdList.Line[CmdNo].Cmd = (ECmd)Convert.ToInt16(S[0]);
                        }
                        catch { }
                        try
                        {
                            S[1] = S[1].Trim();
                            CmdList.Line[CmdNo].ID = Convert.ToInt16(S[1]);
                        }
                        catch { }
                        try
                        {
                            CmdList.Line[CmdNo].String = S[2];
                        }
                        catch { }
                        #endregion
                    }
                    if (ParaNo == 1)
                    {
                    }
                    if (ParaNo == 2)//Cmd.IPara
                    {
                        #region
                        bool EndOfData = false;
                        for (int j = 0; j < TLine.MAX_PARA; j++)
                        {
                            CmdList.Line[CmdNo].IPara[j] = 0;
                            if (!EndOfData)
                                try
                                {
                                    S[j] = S[j].Trim();
                                    EndOfData = (S[j] == "");
                                    CmdList.Line[CmdNo].IPara[j] = Convert.ToInt32(S[j]);
                                }
                                catch { };
                        }
                        #endregion
                    }
                    if (ParaNo == 3)//Cmd.DPara
                    {
                        #region
                        bool EndOfData = false;
                        for (int j = 0; j < TLine.MAX_PARA; j++)
                        {
                            if (!EndOfData)
                                try
                                {
                                    S[j] = S[j].Trim();
                                    EndOfData = (S[j] == "");
                                    CmdList.Line[CmdNo].DPara[j] = Convert.ToDouble(S[j]);
                                }
                                catch { };
                        }
                        #endregion
                    }
                    if (ParaNo == 4)//Cmd.Index
                    {
                        #region
                        bool EndOfData = false;
                        for (int j = 0; j < TLine.MAX_PARA; j++)
                        {
                            CmdList.Line[CmdNo].Index[j] = 0;
                            if (!EndOfData)
                                try
                                {
                                    S[j] = S[j].Trim();
                                    EndOfData = (S[j] == "");
                                    CmdList.Line[CmdNo].Index[j] = Convert.ToInt16(S[j]);
                                }
                                catch { }
                        }
                        #endregion
                    }
                    if (ParaNo == 5)//Cmd.X
                    {
                        #region
                        bool EndOfData = false;
                        for (int j = 0; j < TLine.MAX_PARA; j++)
                        {
                            CmdList.Line[CmdNo].X[j] = 0;
                            if (!EndOfData)
                                try
                                {
                                    S[j] = S[j].Trim();
                                    EndOfData = (S[j] == "");
                                    CmdList.Line[CmdNo].X[j] = Convert.ToDouble(S[j]);
                                }
                                catch { }
                        }
                        #endregion
                    }
                    if (ParaNo == 6)//Cmd.Y
                    {
                        #region
                        bool EndOfData = false;
                        for (int j = 0; j < TLine.MAX_PARA; j++)
                        {
                            CmdList.Line[CmdNo].Y[j] = 0;
                            if (!EndOfData)
                                try
                                {
                                    S[j] = S[j].Trim();
                                    EndOfData = (S[j] == "");
                                    CmdList.Line[CmdNo].Y[j] = Convert.ToDouble(S[j]);
                                }
                                catch { }
                        }
                        #endregion
                    }
                    if (ParaNo == 7)//Cmd.Z
                    {
                        #region
                        bool EndOfData = false;
                        for (int j = 0; j < TLine.MAX_PARA; j++)
                        {
                            CmdList.Line[CmdNo].Z[j] = 0;
                            if (!EndOfData)
                                try
                                {
                                    S[j] = S[j].Trim();
                                    EndOfData = (S[j] == "");
                                    CmdList.Line[CmdNo].Z[j] = Convert.ToDouble(S[j]);
                                }
                                catch { }
                        }
                        #endregion
                    }
                    if (ParaNo == 8)//Cmd.U
                    {
                        #region
                        bool EndOfData = false;
                        for (int j = 0; j < TLine.MAX_PARA; j++)
                        {
                            CmdList.Line[CmdNo].U[j] = 0;
                            if (!EndOfData)
                                try
                                {
                                    S[j] = S[j].Trim();
                                    EndOfData = (S[j] == "");
                                    CmdList.Line[CmdNo].U[j] = Convert.ToDouble(S[j]);
                                }
                                catch { }
                        }
                        #endregion
                    }
                    if (ParaNo == 9)//Cmd.A
                    {
                        #region
                        bool EndOfData = false;
                        for (int j = 0; j < TLine.MAX_PARA; j++)
                        {
                            CmdList.Line[CmdNo].A[j] = 0;
                            if (!EndOfData)
                                try
                                {
                                    S[j] = S[j].Trim();
                                    EndOfData = (S[j] == "");
                                    CmdList.Line[CmdNo].A[j] = Convert.ToDouble(S[j]);
                                }
                                catch { }
                        }
                        #endregion
                    }
                    if (ParaNo == 10)//Cmd.B
                    {
                        #region
                        bool EndOfData = false;
                        for (int j = 0; j < TLine.MAX_PARA; j++)
                        {
                            CmdList.Line[CmdNo].B[j] = 0;
                            if (!EndOfData)
                                try
                                {
                                    S[j] = S[j].Trim();
                                    EndOfData = (S[j] == "");
                                    CmdList.Line[CmdNo].B[j] = Convert.ToDouble(S[j]);
                                }
                                catch { }
                        }
                        #endregion
                    }
                    if (ParaNo == 11)//Cmd.C
                    {
                        #region
                        bool EndOfData = false;
                        for (int j = 0; j < TLine.MAX_PARA; j++)
                        {
                            CmdList.Line[CmdNo].C[j] = 0;
                            if (!EndOfData)
                                try
                                {
                                    S[j] = S[j].Trim();
                                    EndOfData = (S[j] == "");
                                    CmdList.Line[CmdNo].C[j] = Convert.ToDouble(S[j]);
                                }
                                catch { }
                        }
                        #endregion
                    }
                    if (ParaNo == 12)//Cmd.D
                    {
                        #region
                        bool EndOfData = false;
                        for (int j = 0; j < TLine.MAX_PARA; j++)
                        {
                            CmdList.Line[CmdNo].D[j] = 0;
                            if (!EndOfData)
                                try
                                {
                                    S[j] = S[j].Trim();
                                    EndOfData = (S[j] == "");
                                    CmdList.Line[CmdNo].D[j] = Convert.ToDouble(S[j]);
                                }
                                catch { }
                        }
                        #endregion
                    }
                    if (ParaNo == 13)//Cmd.Cond
                    {
                        #region
                        bool EndOfData = false;
                        for (int j = 0; j < TLine.MAX_PARA; j++)
                        {
                            CmdList.Line[CmdNo].Cond[j] = 0;
                            if (!EndOfData)
                                try
                                {
                                    S[j] = S[j].Trim();
                                    EndOfData = (S[j] == "");
                                    CmdList.Line[CmdNo].Cond[j] = Convert.ToInt32(S[j]);
                                }
                                catch { }
                        }
                        #endregion
                    }
                    #endregion
                }

                string Dir = Path.GetDirectoryName(Filename);
                string FileName = Path.GetFileNameWithoutExtension(Filename) + "_Vision";
                //string VisFilename = Dir + "\\" + FileName + ".ini";

                for (int i = 0; i < MAX_IDS; i++)
                {
                    string VisFilename = Dir + "\\" + FileName + "_" + i.ToString() + ".ini";
                    VisionTools[i].Load(VisFilename);
                }

                ClearRTDispData();
                DispProg.Script[0].Validate(0);
                rt_LayoutChanged = true;

                DispProg.ClearVolumeOffset();

                for (int i = 0; i < CmdList.Count; i++)
                {
                    if (CmdList.Line[i].Cmd == ECmd.VOLUME_OFST)
                    {
                        //DispProg.DoVolumeOfst_Purge(CmdList.Line[i].String);
                        DispProg.DoVolumeOfst_Purge();//CmdList.Line[i].String);
                        break;
                    }
                }

                if (TaskWeight.Cal_RequireOnLoadProgram) TaskWeight.Cal_Status = TaskWeight.EWeightCalStatus.Require;

                return true;
            }
            public bool LoadXML(string fileName, int scriptNo)
            {
                if (!File.Exists(fileName)) return false;

                DrawOffset_Reset();

                NUtils.XmlFile xmlFile = new NUtils.XmlFile(fileName, "Recipe");
                try
                {
                    xmlFile.Open();
                    CmdList.Count = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), "General", "CmdlistCount", 0);

                    for (int lines = 0; lines < CmdList.Count; lines++)
                    {
                        CmdList.Line[lines].Cmd = (ECmd)xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "Cmd", 0);
                        CmdList.Line[lines].ID = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "ID", 0);
                        CmdList.Line[lines].String = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "String", "");

                        CmdList.Line[lines].IPara = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "IPara", new int[TLine.MAX_PARA]);
                        CmdList.Line[lines].DPara = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "DPara", new double[TLine.MAX_PARA]);
                        CmdList.Line[lines].Index = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "Index", new int[TLine.MAX_PARA]);

                        CmdList.Line[lines].X = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "X", new double[TLine.MAX_PARA]);
                        CmdList.Line[lines].Y = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "Y", new double[TLine.MAX_PARA]);
                        CmdList.Line[lines].Z = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "Z", new double[TLine.MAX_PARA]);
                        CmdList.Line[lines].U = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "U", new double[TLine.MAX_PARA]);

                        CmdList.Line[lines].A = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "A", new double[TLine.MAX_PARA]);
                        CmdList.Line[lines].B = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "B", new double[TLine.MAX_PARA]);
                        CmdList.Line[lines].C = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "C", new double[TLine.MAX_PARA]);
                        CmdList.Line[lines].D = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "D", new double[TLine.MAX_PARA]);

                        CmdList.Line[lines].Cond = xmlFile.GetValue("Program", "Script" + scriptNo.ToString(), lines.ToString(), "Cond", new int[TLine.MAX_PARA]);
                    }
                }
                catch
                {
                }
                finally
                {
                    //xmlFile.Save();
                }

                for (int i = 0; i < MAX_IDS; i++)
                {
                    VisionTools[i].LoadXML(fileName, "root", "NVision", i.ToString());
                }

                ClearRTDispData();
                DispProg.Script[0].Validate(0);
                rt_LayoutChanged = true;

                DispProg.ClearVolumeOffset();

                for (int i = 0; i < CmdList.Count; i++)
                {
                    if (CmdList.Line[i].Cmd == ECmd.VOLUME_OFST)
                    {
                        DispProg.DoVolumeOfst_Purge();
                        break;
                    }
                }

                if (TaskWeight.Cal_RequireOnLoadProgram) TaskWeight.Cal_Status = TaskWeight.EWeightCalStatus.Require;

                return true;
            }
            public void LoadXML(XmlReader reader)
            {
                int iCmdNo = -1;
                while (reader.Read())
                {
                    if (reader.Name == "section" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                    if (reader.Name == "entry" && reader["name"] == "General")
                    {
                        while (reader.Read())
                        {
                            if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                            if (reader.Name == "subentry")
                            {
                                string attName = reader["name"];

                                switch (attName)
                                {
                                    case "CmdlistCount":
                                        CmdList.Count = ReadSubEntry(reader, 1); break;
                                }
                            }
                        }
                    }

                    //if (reader.Name == "entry")
                    {
                        //while (reader.Read())
                        {
                            string attName2 = reader["name"];
                            if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) iCmdNo = -1;// break;

                            if (iCmdNo == -1)
                            {
                                try
                                {
                                    iCmdNo = int.Parse(reader["name"]);
                                }
                                catch { }
                            }

                            if (iCmdNo >= 0)
                            {
                                //while (reader.Read())
                                //        {
                                //if (reader.Name == "entry" && reader.MoveToContent() == XmlNodeType.EndElement) break;

                                if (reader.Name == "subentry")
                                {
                                    string attName = reader["name"];

                                    switch (attName)
                                    {
                                        case "Cmd":
                                            CmdList.Line[iCmdNo].Cmd = ECmd.NONE;
                                            try
                                            {
                                                CmdList.Line[iCmdNo].Cmd = (ECmd)ReadSubEntry(reader, 0);
                                            }
                                            catch { };
                                            break;
                                        case "String":
                                            CmdList.Line[iCmdNo].String = ReadSubEntry(reader, "");
                                            break;
                                        case "ID":
                                            CmdList.Line[iCmdNo].ID = ReadSubEntry(reader, 0); break;
                                        case "IPara":
                                            CmdList.Line[iCmdNo].IPara = ReadSubEntry(reader, new int[TLine.MAX_PARA]); break;
                                        case "DPara":
                                            CmdList.Line[iCmdNo].DPara = ReadSubEntry(reader, new double[TLine.MAX_PARA]); break;
                                        case "Index":
                                            CmdList.Line[iCmdNo].Index = ReadSubEntry(reader, new int[TLine.MAX_PARA]); break;
                                        case "X":
                                            CmdList.Line[iCmdNo].X = ReadSubEntry(reader, new double[TLine.MAX_PARA]); break;
                                        case "Y":
                                            CmdList.Line[iCmdNo].Y = ReadSubEntry(reader, new double[TLine.MAX_PARA]); break;
                                        case "Z":
                                            CmdList.Line[iCmdNo].Z = ReadSubEntry(reader, new double[TLine.MAX_PARA]); break;
                                        case "U":
                                            CmdList.Line[iCmdNo].U = ReadSubEntry(reader, new double[TLine.MAX_PARA]); break;
                                        case "A":
                                            CmdList.Line[iCmdNo].A = ReadSubEntry(reader, new double[TLine.MAX_PARA]); break;
                                        case "B":
                                            CmdList.Line[iCmdNo].B = ReadSubEntry(reader, new double[TLine.MAX_PARA]); break;
                                        case "C":
                                            CmdList.Line[iCmdNo].C = ReadSubEntry(reader, new double[TLine.MAX_PARA]); break;
                                        case "D":
                                            CmdList.Line[iCmdNo].D = ReadSubEntry(reader, new double[TLine.MAX_PARA]); break;
                                        case "Cond":
                                            CmdList.Line[iCmdNo].Cond = ReadSubEntry(reader, new int[TLine.MAX_PARA]); break;
                                    }
                                }
                                //}
                            }
                        }
                    }
                }

                ClearRTDispData();
                DispProg.Script[0].Validate(0);
                rt_LayoutChanged = true;

                DispProg.ClearVolumeOffset();

                for (int i = 0; i < CmdList.Count; i++)
                {
                    if (CmdList.Line[i].Cmd == ECmd.VOLUME_OFST)
                    {
                        DispProg.DoVolumeOfst_Purge();
                        break;
                    }
                }

                if (TaskWeight.Cal_RequireOnLoadProgram) TaskWeight.Cal_Status = TaskWeight.EWeightCalStatus.Require;
            }

            public void Delete(ref int Index)
            {
                if (CmdList.Count == 0) return;

                if (Index == CmdList.Count) return;

                Log.OnAction("Delete", Index.ToString("d3") + " " + CmdList.Line[Index].Cmd.ToString());
                for (int i = Index; i < CmdList.Count - 1; i++)
                {
                    CmdList.Line[i].Copy(CmdList.Line[i + 1]);
                }

                CmdList.Count--;

                if (Index >= CmdList.Count) Index = CmdList.Count - 1;
            }
            public void Insert(ref int Index, ECmd Cmd)
            {
                if (CmdList.Count >= TCmdList.MAX_CMD) return;

                for (int i = CmdList.Count; i > Index; i--)
                {
                    CmdList.Line[i].Copy(CmdList.Line[i - 1]);
                }

                CmdList.Line[Index] = new TLine();
                CmdList.Line[Index].Cmd = Cmd;
                Log.OnAction("Insert", Index.ToString("d3") + " " + CmdList.Line[Index].Cmd.ToString());

                if (Cmd == DispProg.ECmd.DO_BDCAPTURE)
                {
                    CmdList.Line[Index].IPara[5] = 8000;
                }
                if (Cmd == DispProg.ECmd.PP_RECYCLE_B)
                {
                    CmdList.Line[Index].IPara[2] = 1;
                }
                if (Cmd == DispProg.ECmd.PP_RECYCLE_N)
                {
                    CmdList.Line[Index].IPara[2] = 5;
                }

                if (Cmd == DispProg.ECmd.VOLUME_MAP)
                {
                    CmdList.Line[Index].IPara[2] = 1;
                    CmdList.Line[Index].Index[0] = 1;
                }
                CmdList.Count++;
            }
            public void MoveUp(ref int Index)
            {
                TLine tempLine = new TLine();

                if (Index == 0) return;

                Log.OnAction("MoveUp", Index.ToString("d3") + " " + CmdList.Line[Index].Cmd.ToString());
                tempLine.Copy(CmdList.Line[Index - 1]);
                CmdList.Line[Index - 1].Copy(CmdList.Line[Index]);
                CmdList.Line[Index].Copy(tempLine);
                Index--;
            }
            public void MoveDn(ref int Index)
            {
                TLine tempLine = new TLine();

                if (Index == CmdList.Count - 1) return;

                Log.OnAction("MoveDn", Index.ToString("d3") + " " + CmdList.Line[Index].Cmd.ToString());
                tempLine.Copy(CmdList.Line[Index + 1]);
                CmdList.Line[Index + 1].Copy(CmdList.Line[Index]);
                CmdList.Line[Index].Copy(tempLine);
                Index++;
            }

            /// <summary>
            /// Validate Program
            /// </summary>
            /// <param name="NewLine">New line, Use ID for previous Do ID</param>
            public void Validate(int NewLine)
            {
                int[] LayoutID = new int[MAX_IDS];
                int LayoutNo = 0;

                int[] ForID = new int[MAX_IDS];

                int DoRefNo = 0;
                int DoHeightNo = 0;

                int SyncHeadID = 0;

                for (int i = 0; i < CmdList.Count; i++)
                {
                    if (CmdList.Line[i].Cmd == ECmd.LAYOUT)
                    {
                        CmdList.Line[i].ID = LayoutNo;

                        //if (LayoutNo == 0)//update first Layout to rt
                        //***update to Layouts
                        rt_Layouts[LayoutNo] = new TLayout(CmdList.Line[i]);

                        rt_LayoutCount = LayoutNo + 1;
                        LayoutNo++;
                    }
                    if (CmdList.Line[i].Cmd == ECmd.FOR_LAYOUT)
                    {
                        CmdList.Line[i].ID = 0;
                        for (int j = i; j > 0; j--)
                        {
                            if (CmdList.Line[j].Cmd == ECmd.LAYOUT)
                            {
                                CmdList.Line[i].ID = CmdList.Line[j].ID;
                                break;
                            }
                        }
                    }
                    if (CmdList.Line[i].Cmd == ECmd.END_LAYOUT)
                    {
                        CmdList.Line[i].ID = 0;
                        for (int j = i; j > 0; j--)
                        {
                            if (CmdList.Line[j].Cmd == ECmd.LAYOUT)
                            {
                                CmdList.Line[i].ID = CmdList.Line[j].ID;
                                break;
                            }
                        }
                    }
                    if (CmdList.Line[i].Cmd == ECmd.DO_REF || CmdList.Line[i].Cmd == ECmd.DO_REF_EDGE)
                    {
                        //auto assign ID
                        CmdList.Line[i].ID = DoRefNo;
                        DoRefNo++;
                    }
                    if (CmdList.Line[i].Cmd == ECmd.USE_REF)
                    {
                        if (NewLine == i)
                        {
                            CmdList.Line[i].ID = 0;
                            for (int j = i; j > 0; j--)
                            {
                                if (CmdList.Line[j].Cmd == ECmd.DO_REF || CmdList.Line[i].Cmd == ECmd.DO_REF_EDGE)
                                {
                                    CmdList.Line[i].ID = CmdList.Line[j].ID;
                                    break;
                                }
                            }
                        }
                    }
                    if (CmdList.Line[i].Cmd == ECmd.DO_HEIGHT)
                    {
                        //auto assign ID
                        //CmdList.Line[i].ID = DoHeightNo;
                        //DoHeightNo++;
                    }
                    if (CmdList.Line[i].Cmd == ECmd.USE_HEIGHT)
                    {
                        if (NewLine == i)
                        {
                            CmdList.Line[i].ID = 0;
                            for (int j = i; j > 0; j--)
                            {
                                if (CmdList.Line[j].Cmd == ECmd.DO_HEIGHT)
                                {
                                    CmdList.Line[i].ID = CmdList.Line[j].ID;
                                    break;
                                }
                            }
                        }
                    }
                    if (CmdList.Line[i].Cmd == ECmd.SUB)
                    {
                        if (CmdList.Line[i].ID == 0) CmdList.Line[i].ID = 1;
                    }

                    if (CmdList.Line[i].Cmd == ECmd.DOT ||
                        CmdList.Line[i].Cmd == ECmd.MOVE ||
                        CmdList.Line[i].Cmd == ECmd.LINE ||
                        CmdList.Line[i].Cmd == ECmd.ARC ||
                        CmdList.Line[i].Cmd == ECmd.CIRC ||

                        CmdList.Line[i].Cmd == ECmd.DWELL ||
                        CmdList.Line[i].Cmd == ECmd.WAIT ||
                        CmdList.Line[i].Cmd == ECmd.PURGE_DOT ||
                        CmdList.Line[i].Cmd == ECmd.DOT_MULTI
                        )
                    {
                        if (CmdList.Line[i].ID == 0) CmdList.Line[i].ID = 1;
                        {
                            if (SyncHeadID == 0)
                            {
                                SyncHeadID = CmdList.Line[i].ID;
                            }
                            else
                            {
                                if (SyncHeadID == 3) CmdList.Line[i].ID = SyncHeadID;
                                if (SyncHeadID != 3 && CmdList.Line[i].ID == 3) CmdList.Line[i].ID = SyncHeadID;
                            }
                        }
                    }
                    if (CmdList.Line[i].Cmd == ECmd.LINE ||
                        CmdList.Line[i].Cmd == ECmd.ARC ||
                        CmdList.Line[i].Cmd == ECmd.CIRC)
                    {
                        int Cont = CmdList.Line[i].IPara[10];
                        int Blend = CmdList.Line[i].IPara[11];
                        for (int j = i; j < CmdList.Count; j++)
                        {
                            if (CmdList.Line[j].Cmd == ECmd.LINE || CmdList.Line[j].Cmd == ECmd.ARC || CmdList.Line[j].Cmd == ECmd.CIRC)
                            {
                                CmdList.Line[j].IPara[10] = Cont;
                                CmdList.Line[j].IPara[11] = Blend;
                            }
                            else
                                break;
                        }
                    }
                    if (CmdList.Line[i].Cmd == ECmd.DO_BDCAPTURE ||
                        CmdList.Line[i].Cmd == ECmd.DO_BDORIENT ||
                        CmdList.Line[i].Cmd == ECmd.DO_HEIGHT ||
                        CmdList.Line[i].Cmd == ECmd.DO_REF ||
                        CmdList.Line[i].Cmd == ECmd.DO_UNITMARK)
                    {
                        if (CmdList.Line[i].IPara[4] == 0) CmdList.Line[i].IPara[4] = 150;
                    }
                }

                rt_VolumeMap.Enabled = false;
                for (int i = 0; i < CmdList.Count; i++)
                {
                    if (CmdList.Line[i].Cmd == ECmd.VOLUME_MAP)
                    {
                        rt_VolumeMap.Enabled = true;
                        VolumeMap(CmdList.Line[i]);
                        break;
                    }
                }

                rt_VolumeOfst = false;
                rt_VolComp.Clear();
                for (int i = 0; i < CmdList.Count; i++)
                {
                    if (CmdList.Line[i].Cmd == ECmd.VOLUME_OFST)
                    {
                        rt_VolumeOfst = true;
                        rt_VolumeOfst_Path = CmdList.Line[i].String;
                        rt_VolumeOfst_Mode = (EVolumeOfstMode)CmdList.Line[i].IPara[0];
                    }
                    if (CmdList.Line[i].Cmd == ECmd.PP_VOL_COMP)
                    {
                        rt_VolComp.Add(i);
                    }
                }
            }
            public void DrawOffset_Reset()
            {
                OriginDrawOfst.X = 0;
                OriginDrawOfst.Y = 0;
            }
            public void DrawOffset_Update()
            {
                for (int i = 0; i < CmdList.Count; i++)
                {
                    if (CmdList.Line[i].Cmd == ECmd.DOT ||
                        CmdList.Line[i].Cmd == ECmd.MOVE ||
                        CmdList.Line[i].Cmd == ECmd.LINE ||
                        CmdList.Line[i].Cmd == ECmd.ARC ||
                        CmdList.Line[i].Cmd == ECmd.CIRC ||
                        CmdList.Line[i].Cmd == ECmd.SUB)
                    {
                        CmdList.Line[i].X[0] = CmdList.Line[i].X[0] + OriginDrawOfst.X;
                        CmdList.Line[i].Y[0] = CmdList.Line[i].Y[0] + OriginDrawOfst.Y;
                    }
                    if (CmdList.Line[i].Cmd == ECmd.ARC ||
                        CmdList.Line[i].Cmd == ECmd.CIRC)
                    {
                        CmdList.Line[i].X[1] = CmdList.Line[i].X[1] + OriginDrawOfst.X;
                        CmdList.Line[i].Y[1] = CmdList.Line[i].Y[1] + OriginDrawOfst.Y;
                    }
                    if (CmdList.Line[i].Cmd == ECmd.DOT_MULTI)
                    {
                        for (int j = 0; j < CmdList.Line[i].IPara[5]; j++)
                        {
                            CmdList.Line[i].X[j] = CmdList.Line[i].X[j] + OriginDrawOfst.X;
                            CmdList.Line[i].Y[j] = CmdList.Line[i].Y[j] + OriginDrawOfst.Y;
                        }
                    }
                }

                DrawOffset_Reset();
            }

            public bool CheckScript(ref string Message)
            {
                bool b_Layout = false;
                bool b_ForLayoutOpen = false;

                bool b_DoRef = false;
                bool b_UseRef = false;

                bool b_DoVision = false;
                bool b_UseVision = false;

                bool b_DoHeight = false;
                bool b_UseHeight = false;

                for (int i = 0; i < CmdList.Count; i++)
                {
                    switch (CmdList.Line[i].Cmd)
                    {
                        case ECmd.LAYOUT:
                            #region
                            b_Layout = true;
                            break;
                        #endregion
                        case ECmd.FOR_LAYOUT:
                            #region
                            if (!b_Layout)
                            {
                                Message = "FOR_LAYOUT, no LAYOUT defined.";
                                return false;
                            }
                            if (b_ForLayoutOpen)
                            {
                                Message = "FOR_LAYOUT, missing END_LAYOUT.";
                                return false;
                            }
                            b_ForLayoutOpen = true;
                            break;
                        #endregion
                        case ECmd.END_LAYOUT:
                            #region
                            if (!b_ForLayoutOpen)
                            {
                                Message = "END_LAYOUT, missing FOR_LAYOUT.";
                                return false;
                            }
                            b_ForLayoutOpen = false;
                            break;
                        #endregion
                        case ECmd.DO_REF:
                        case ECmd.DO_REF_EDGE:
                            #region
                            b_DoRef = true;
                            break;
                        #endregion
                        case ECmd.DO_VISION:
                            #region
                            b_DoVision = true;
                            break;
                        #endregion
                        case ECmd.USE_REF:
                            #region
                            if (!b_DoRef)
                            {
                                Message = "USE_REF, no DO_REF defined.";
                                return false;
                            }
                            b_UseRef = true;
                            break;
                        #endregion
                        case ECmd.USE_VISION:
                            #region
                            if (!b_DoVision)
                            {
                                Message = "USE_VISION, no DO_VISION defined.";
                                return false;
                            }
                            b_UseVision = true;
                            break;
                        #endregion
                        case ECmd.DO_HEIGHT:
                            #region
                            b_DoHeight = true;
                            break;
                        #endregion
                        case ECmd.USE_HEIGHT:
                            #region
                            if (!b_DoHeight)
                            {
                                Message = "USE_HEIGHT, no DO_HEIGHT defined.";
                                return false;
                            }
                            b_UseHeight = true;
                            break;
                            #endregion
                    }
                }
                if (b_ForLayoutOpen)
                {
                    Message = "FOR_LAYOUT, missing END_LAYOUT.";
                    return false;
                }
                if (b_DoRef && !b_UseRef)
                {
                    Message = "DO_REF, not used.";
                    return false;
                }
                if (b_DoVision && !b_UseVision)
                {
                    Message = "DO_VISION, not used.";
                    return false;
                }
                if (b_DoHeight && !b_UseHeight)
                {
                    Message = "DO_HEIGHT, not used.";
                    return false;
                }

                return true;
            }
            public bool TaskCheckScript()
            {
                if (TaskDisp.Option_EnableScriptCheck)
                {
                    string Msg = "";
                    if (!CheckScript(ref Msg))
                    {
                        return MessageBox.Show(Msg, "", MessageBoxButtons.OKCancel) == DialogResult.OK;
                    }
                }

                if (TaskDisp.Option_EnableScriptCheckUnitMode)
                {
                    bool UnitSelected = true;
                    string Msg = "";
                    for (int i = 0; i < CmdList.Count; i++)
                    {
                        switch (CmdList.Line[i].Cmd)
                        {
                            case ECmd.DO_REF:
                                UnitSelected = CmdList.Line[i].IPara[2] == (int)EAlignType.Unit;
                                Msg = "DO_REF, Align Type of Unit not selected.";
                                break;
                            case ECmd.DO_VISION:
                                UnitSelected = CmdList.Line[i].IPara[2] == (int)EAlignType.Unit;
                                Msg = "DO_VISION, Align Type of Unit not selected.";
                                break;
                            case ECmd.DO_HEIGHT:
                                UnitSelected = CmdList.Line[i].IPara[2] == (int)EAlignType.Unit;
                                Msg = "DO_HEIGHT, Align Type of Unit not selected.";
                                break;
                        }
                        if (!UnitSelected)
                        {
                            return MessageBox.Show(Msg, "", MessageBoxButtons.OKCancel) == DialogResult.OK;
                        }
                    }
                }
                return true;
            }

            public TCmdList CmdList = new TCmdList();

            public bool IsBusy = false;
            private bool Running = false;

            double rt_Layout_Rel_X = 0;
            double rt_Layout_Rel_Y = 0;
            double rt_Layout_Rel_X2 = 0;
            double rt_Layout_Rel_Y2 = 0;


            public TLine rt_CmdLine = new TLine();
            public TLine rt_NextCmdLine = new TLine();
            public TLine rt_PrevCmdLine = new TLine();

            bool b_Flag_ConsecutiveUnit = false;//flag to perfrom PreMoveZ
            bool LastInCluster = false;//flag unit is last in cluster
            bool b_MovePanelGap = true;//flag unit is last to disp, move panel gap
            EMoveLineRev MoveLine_ReverseDir = EMoveLineRev.None;

            bool b_TempCtrlChecked = false;//current run temp is checked

            static bool videoStart = false;
            static bool videoStop = false;

            private bool Run(ERunMode RunMode, double f_origin_x, double f_origin_y, double f_origin_z, double f_flowrate, double f_tweight, bool IsSub)//, bool SyncHead2)
            {
                Idle.Reset();
                pressVal = new double[] { 0, 0 };
                progDispVol = new double[] { 0, 0 };
                videoStart = false;
                videoStop = false;

                b_TempCtrlChecked = false;

                TaskVision.CameraRun = true;
                if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker)
                {
                    //TaskVision.frmGenImageView.Grab();
                }

                IsBusy = true;
                Running = true;

                #region PreRun Check
                switch (RunMode)
                {
                    case ERunMode.Normal:
                        if (TaskWeight.Cal_RequireOnLoadProgram && TaskWeight.Cal_Status == TaskWeight.EWeightCalStatus.Require)
                        {
                            Msg MsgBox = new Msg();
                            EMsgRes MsgRes = MsgBox.Show(ErrCode.WEIGHT_CAL_REQUIRED, EMcState.Notice, EMsgBtn.smbOK_Cancel, false);
                            switch (MsgRes)
                            {
                                case EMsgRes.smrOK:
                                    {
                                        frm_DispCore_WeightCal frm = new frm_DispCore_WeightCal();
                                        frm.ShowDialog();
                                        goto _Pause;
                                    }
                                default:
                                    goto _Pause;
                            }
                        }

                        string Pumps = "";
                        if (Maint.PP.FillCountLimit[0] > 0)
                        {
                            if (Maint.PP.FillCount[0] >= Maint.PP.FillCountLimit[0]) Pumps = "Head A ";
                        }
                        if (GDefine.HeadConfig == GDefine.EHeadConfig.Dual && (DispProg.Head_Operation == TaskDisp.EHeadOperation.Double || DispProg.Head_Operation == TaskDisp.EHeadOperation.Sync))
                        {
                            if (Maint.PP.FillCountLimit[1] > 0)
                                if (Maint.PP.FillCount[1] >= Maint.PP.FillCountLimit[1]) Pumps = Pumps + "Head B ";
                        }
                        if (Pumps.Length > 0)
                        {
                            Msg MsgBox = new Msg();
                            EMsgRes MsgRes = MsgBox.Show(ErrCode.FILL_COUNT_EXCEED_LIMIT, Pumps, EMcState.Notice, EMsgBtn.smbOK_Stop, false);
                            if (MsgRes == EMsgRes.smrStop)
                            {
                                goto _Pause;
                            }
                        }

                        Pumps = "";
                        if (Maint.Disp.CountLimit[0] > 0)
                        {
                            if (Maint.Disp.Count[0] >= Maint.Disp.CountLimit[0]) Pumps = "Head A ";
                        }
                        if (GDefine.HeadConfig == GDefine.EHeadConfig.Dual && (DispProg.Head_Operation == TaskDisp.EHeadOperation.Double || DispProg.Head_Operation == TaskDisp.EHeadOperation.Sync))
                        {
                            if (Maint.Disp.CountLimit[1] > 0)
                                if (Maint.Disp.Count[1] >= Maint.Disp.CountLimit[1]) Pumps = Pumps + "Head B ";
                        }
                        if (Pumps.Length > 0)
                        {
                            Msg MsgBox = new Msg();
                            EMsgRes MsgRes = MsgBox.Show(ErrCode.UNIT_COUNT_EXCEED_LIMIT, Pumps, EMcState.Notice, EMsgBtn.smbOK_Stop, false);
                            if (MsgRes == EMsgRes.smrStop)
                            {
                                goto _Pause;
                            }
                        }
                        break;
                    case ERunMode.Dry:
                    case ERunMode.Camera:
                        break;
                }

                if (TaskDisp.Option_PromptRunSingleHead && !rt_PromptedSingleHeadRun)
                {
                    if ((GDefine.GantryConfig == GDefine.EGantryConfig.XYZ || GDefine.GantryConfig == GDefine.EGantryConfig.XZ_YTABLE)
                        && GDefine.HeadConfig == GDefine.EHeadConfig.Dual)
                    {
                        if (TaskDisp.Head_Operation == TaskDisp.EHeadOperation.Single)
                        {
                            Msg MsgBox = new Msg();
                            EMsgRes MsgRes = MsgBox.Show(ErrCode.SINGLE_HEAD_RUN_CHECK, EMcState.Notice, EMsgBtn.smbOK_Cancel, false);
                            if (MsgRes == EMsgRes.smrCancel)
                            {
                                goto _Pause;
                            }
                            rt_PromptedSingleHeadRun = true;
                        }
                    }
                }

                if (TaskDisp.Material_EnableTimer)
                {
                    if (DateTime.Now > TaskDisp.Material_Life_EndTime)
                    {
                        //MsgInfo.TMsgInfo msgInfo = new MsgInfo.TMsgInfo();
                        //MsgInfo.GetInfo(ErrCode.MATERIAL_TIMER_EXPIRED, ref msgInfo);
                        EMsgBtn msgBtn = EMsgBtn.smbOK_Stop;
                        string extMsg = "";
                        switch (TaskDisp.Preference)
                        {
                            case TaskDisp.EPreference.Analog:
                                extMsg = "Material Already Expired. Please Change the mateial and redo flow rate.";
                                break;
                        }

                        if (TaskDisp.MaterialExpiryForbidContinue) msgBtn = EMsgBtn.smbStop;

                        Msg MsgBox = new Msg();
                        EMsgRes MsgRes = MsgBox.Show(ErrCode.MATERIAL_TIMER_EXPIRED, extMsg, EMcState.Notice, msgBtn, false);
                        if (MsgRes == EMsgRes.smrStop)
                        {
                            goto _Pause;
                        }
                    }
                    else
                    {
                        //if (TaskDisp.Material_ExpiryPreAlertTime > 0)
                        //{
                        //    if (DateTime.Now > TaskDisp.Material_LifePreAlert_Time)
                        //    {
                        //        TaskDisp.Material_LifePreAlert_Time = TaskDisp.Material_Life_EndTime;
                        //        Msg MsgBox = new Msg();
                        //        EMsgRes MsgRes = MsgBox.Show(ErrCode.MATERIAL_EXPIRY_PREALERT, $"Material Expire in {TaskDisp.Material_ExpiryPreAlertTime} minutes.", EMcState.Notice, EMsgBtn.smbOK_Stop, false);
                        //        if (MsgRes == EMsgRes.smrStop)
                        //        {
                        //            goto _Pause;
                        //        }
                        //    }
                        //}
                    }
                }

                if (TaskDisp.Option_EnableMaterialLow)
                {
                    if (TaskGantry.SensMat1Low())
                    {
                        EMsgBtn msgBtn = EMsgBtn.smbOK_Stop;
                        if (TaskDisp.MaterialLowForbidContinue) msgBtn = EMsgBtn.smbStop;
                        Msg MsgBox = new Msg();
                        EMsgRes MsgRes = MsgBox.Show(ErrCode.MATERIAL1_LEVEL_LOW, EMcState.Notice, msgBtn, false);
                        if (MsgRes == EMsgRes.smrStop)
                        {
                            goto _Pause;
                        }
                    }
                    if (TaskDisp.Option_EnableDualMaterial)
                    {
                        if (TaskGantry.SensMat2Low())
                        {
                            EMsgBtn msgBtn = EMsgBtn.smbOK_Stop;
                            if (TaskDisp.MaterialLowForbidContinue) msgBtn = EMsgBtn.smbStop;
                            Msg MsgBox = new Msg();
                            EMsgRes MsgRes = MsgBox.Show(ErrCode.MATERIAL2_LEVEL_LOW, EMcState.Notice, msgBtn, false);
                            if (MsgRes == EMsgRes.smrStop)
                            {
                                goto _Pause;
                            }
                        }
                    }

                    if (GDefine.HeadConfig == GDefine.EHeadConfig.Dual)
                        if (DispProg.Head_Operation == TaskDisp.EHeadOperation.Double || DispProg.Head_Operation == TaskDisp.EHeadOperation.Sync)
                        {
                            if (TaskGantry.SensMat2Low())
                            {
                                EMsgBtn msgBtn = EMsgBtn.smbOK_Stop;
                                if (TaskDisp.MaterialLowForbidContinue) msgBtn = EMsgBtn.smbStop;
                                Msg MsgBox = new Msg();
                                EMsgRes MsgRes = MsgBox.Show(ErrCode.MATERIAL2_LEVEL_LOW, EMcState.Notice, msgBtn, false);
                                if (MsgRes == EMsgRes.smrStop)
                                {
                                    goto _Pause;
                                }
                            }
                        }
                }
                if (Material.EnableUnitCounter && RunMode == ERunMode.Normal)
                {
                    if (Material.Unit.Count[0] > Material.Unit.Limit[0])
                    {
                        Msg MsgBox = new Msg();
                        EMsgRes MsgRes = MsgBox.Show(ErrCode.MATERIAL1_UNIT_RUN_EXCEEDED, EMcState.Notice, EMsgBtn.smbOK_Stop, false);
                        if (MsgRes == EMsgRes.smrStop)
                        {
                            goto _Pause;
                        }
                    }
                    if (Material.Unit.Count[1] > Material.Unit.Limit[1])
                    {
                        Msg MsgBox = new Msg();
                        EMsgRes MsgRes = MsgBox.Show(ErrCode.MATERIAL2_UNIT_RUN_EXCEEDED, EMcState.Notice, EMsgBtn.smbOK_Stop, false);
                        if (MsgRes == EMsgRes.smrStop)
                        {
                            goto _Pause;
                        }
                    }
                }
                #endregion

                if (TaskDisp.Option_EnableChuckVac)
                {
                    TaskGantry.ChuckVac = true;
                    Thread.Sleep(250);
                    if (!TaskGantry.CheckSensChuckVacOn())
                    {
                        TaskGantry.ChuckVac = false;
                        goto _Pause;
                    }
                }

                if (GDefine.OperationSpeed != EOperationSpeed.SlowMo) GDefine.OperationSpeed = EOperationSpeed.Normal;

                Stats.ContinueBoard.ResetUnitCount();
                Stats.ContinueBoard.ResetDispCount();
                switch (RunMode)
                {
                    case ERunMode.Normal:
                        if (PurgeStage.OnStartCount > 0)
                        {
                            if (!TaskDisp.PurgeStage.Execute(PurgeStage.OnStartCount)) goto _Pause;
                        }
                        break;
                    case ERunMode.Dry:
                    case ERunMode.Camera:
                        break;
                }

                if (!Running) goto _Pause;

                BdStatus = EBoardStatus.Busy;
                GDefine.Status = EStatus.Busy;

                if (FlowRate.EnableAutoCalFrame && Stats.AutoFlowRateFrameCounter >= FlowRate.AutoCalFrameInterval)
                {
                    EHeadNo HeadNo = EHeadNo.Head1;
                    if (rt_SyncHead2) HeadNo = EHeadNo.Head12;
                    bool b_Head1 = (HeadNo == EHeadNo.Head1 || HeadNo == EHeadNo.Head12);
                    bool b_Head2 = (HeadNo == EHeadNo.Head2 || HeadNo == EHeadNo.Head12);

                    frmFlowRateCal frm = new frmFlowRateCal(b_Head1, b_Head2);
                    if (frm.ShowDialog() == DialogResult.OK)
                    {
                        Stats.AutoFlowRateFrameCounter = 0;
                        Stats.AutoFlowRateUnitCounter = 0;
                    }
                    else
                        goto _Pause;
                }

                b_Flag_ConsecutiveUnit = false;

                string Msg = "Run";
                string EMsg = Msg;
                try
                {
                    rt_SyncHead2 = TaskDisp.Head_Operation == TaskDisp.EHeadOperation.Sync;

                    bool b_SecondHalf = false;
                    bool b_IsNeedle2 = false;
                    bool b_Head2UnitIsValid = true;

                    double productZ = f_origin_z;

                    int StartLine = LastLine;
                    if (StartLine < 0) StartLine = 0;
                    if (StartLine == 0)
                    {
                        ExecutedLines.Clear();
                        rt_Layout_Rel_X = 0;
                        rt_Layout_Rel_Y = 0;
                        rt_Layout_Rel_X2 = 0;
                        rt_Layout_Rel_Y2 = 0;

                        rt_Singulated = false;

                        #region Recovery Upload
                        if (TaskDisp.Preference == TaskDisp.EPreference.Unisem && TaskDisp.SECSGEMProtocol == TaskDisp.ESECSGEMProtocol.SECSGEMConnect2 && GDefine.sgc2.EnableUploadStripMapE142)
                        {
                            var files = Directory.GetFiles(GDefine.StripMapDir.FullName, "*.txt", SearchOption.TopDirectoryOnly);

                            if (files.Count() > 0)
                            {
                                foreach (string file in files)
                                {
                                    string stripID = Path.GetFileNameWithoutExtension(file);
                                    Event.MAP_RECOVER_PROMPT.Set("StripID", stripID);

                                    Msg MsgBox = new Msg();
                                    EMsgRes MsgRes = MsgBox.Show("Partial process strip map " + stripID + " found. Upload to Server? " +
                                        "@Yes - Upload to server." +
                                        "@No - Skip upload." +
                                        "@Cancel - Delete file.",
                                        EMcState.Notice, EMsgBtn.smbYes | EMsgBtn.smbNo | EMsgBtn.smbCancel, false);
                                    switch (MsgRes)
                                    {
                                        case EMsgRes.smrYes:
                                            TMap map = new TMap();
                                            //Download map first, data need are appended at to the original map
                                            if (!TInputMap.Execute("", stripID, ref map)) goto _Pause;
                                            //Load in process
                                            map.LoadInProcess(file);
                                            //Upload
                                            if (!TInputMap.Upload(stripID, ref map)) goto _Pause;
                                            Event.MAP_RECOVER_UPLOADED.Set("StripID", stripID);
                                            File.Delete(file);
                                            break;
                                        case EMsgRes.smrNo:
                                            Event.MAP_RECOVER_UPLOAD_CANCEL.Set("StripID", stripID);
                                            break;
                                        case EMsgRes.smrCancel:
                                            if (MessageBox.Show($"Confirm delete partial StripID {stripID}?", "Warning", MessageBoxButtons.OKCancel) == DialogResult.Cancel)
                                            {
                                                break;
                                            }
                                            string newFile = GDefine.StripMapDeletedDir.FullName + Path.GetFileName(file);
                                            if (File.Exists(newFile)) File.Delete(newFile);
                                            File.Move(file, newFile);
                                            Event.MAP_RECOVER_DELETED.Set("StripID", stripID);
                                            break;
                                    }
                                }
                                goto _Pause;
                            }
                        }
                        #endregion
                    }

                    int i_TWeight1DotTime = 0;
                    double d_TWeightSpeed = 0;
                    #region TotalWeight: f_tweight > 0 (SubCall only)
                    if (f_tweight > 0)
                    {
                        //b_TWeight = true;

                        int i_DotCount = 0;
                        int i_DrawCount = 0;
                        //int i_CurveCount = 0;
                        for (int i = 0; i < CmdList.Count; i++)
                        {
                            if (CmdList.Line[i].Cmd == ECmd.DOT) i_DotCount++;
                            if ((CmdList.Line[i].Cmd == ECmd.LINE) || (CmdList.Line[i].Cmd == ECmd.ARC) || (CmdList.Line[i].Cmd == ECmd.CIRC)) i_DrawCount++;
                        }
                        if ((i_DotCount > 0) && (i_DrawCount > 0))
                        {
                            Running = false;
                            throw new Exception("SUB CALL weight dispense type conflict");
                        }

                        //dot only
                        if (i_DotCount > 0)
                        {
                            double dt_s = f_tweight / f_flowrate;
                            i_TWeight1DotTime = (int)(dt_s / i_DotCount * 1000);
                        }

                        //line type only
                        if (i_DrawCount > 0)
                        {
                            double Dist = 0;
                            double Time = 0;
                            if (!CalcTotalDistTime(f_origin_x, f_origin_y, ref Dist, ref Time)) throw new Exception("CalcTotalDistTime Error");

                            double dt_s = f_tweight / f_flowrate;
                            if (dt_s < Time / 1000) throw new Exception("Delay Time More than Weight Time");

                            dt_s = dt_s - Time / 1000;
                            d_TWeightSpeed = Dist / dt_s;
                        }
                    }
                    #endregion

                    int i_DoRefSkipCntr = 0;
                    int i_DoHeightSkipCntr = 0;

                    int i_UnitSkipCount = 0;
                    int i_MeniContOOSCntr = 0;

                    int LastUColNo = 0; int LastURowNo = 0; int LastCColNo = 0; int LastCRowNo = 0;

                    double d_LastLaserHeight = 0;

                    if (TaskDisp.VolumeOfst_Protocol == TaskDisp.EVolumeOfstProtocol.Lextar_FrontTestCloseLoop)
                    {
                        if (Lextar_FrontTestCloseLoop.Mode == Lextar_FrontTestCloseLoop.EMode.Auto)
                        {
                        _Retry:
                            double Ofst1 = 0;
                            double Ofst2 = 0;

                            try
                            {
                                if (!DoVolumeOfst(ref Ofst1, ref Ofst2, false)) goto _Pause;
                                double HA_Vol = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj + DispProg.rt_Head1VolumeOfst;
                                double HB_Vol = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj + DispProg.rt_Head2VolumeOfst;
                                TaskDisp.SetDispVolume(true, true, HA_Vol, HB_Vol);
                            }
                            catch (Exception Ex)
                            {
                                Msg MsgBox = new Msg();
                                EMsgRes MsgRes = MsgBox.Show(Ex.Message.ToString(), EMcState.Error, EMsgBtn.smbRetry_Stop, false);
                                switch (MsgRes)
                                {
                                    case EMsgRes.smrStop:
                                        goto _Pause;
                                    case EMsgRes.smrRetry:
                                        goto _Retry;
                                }
                            }
                        }
                        TimeSpan dt = DateTime.Now - Lextar_FrontTestCloseLoop.dt_LastDataUpdate;
                        if (Lextar_FrontTestCloseLoop.Status == Lextar_FrontTestCloseLoop.EStatus.Waiting && dt.Minutes >= Lextar_FrontTestCloseLoop.WaitTimer_m)
                        {
                            Msg MsgBox = new Msg();
                            EMsgRes MsgRes = MsgBox.Show("Wait Volume Offset Data TimeOut.@OK - Continue.", EMcState.Notice, EMsgBtn.smbOK, false);
                            Lextar_FrontTestCloseLoop.dt_LastDataUpdate = DateTime.Now;
                            Lextar_FrontTestCloseLoop.Status = Lextar_FrontTestCloseLoop.EStatus.None;
                        }
                    }

                    for (int Line = StartLine; Line < CmdList.Count; Line++)
                    {
                    _Loop:
                        Idle.Reset();

                        LastLine = Line;
                        TLine ActiveLine = new TLine(CmdList.Line[Line]);

                        rt_CmdLine = new TLine(CmdList.Line[Line]);
                        rt_NextCmdLine = new TLine();
                        rt_NextCmdLine.Cmd = ECmd.NONE;
                        if (Line < CmdList.Count) rt_NextCmdLine = new TLine(CmdList.Line[Line + 1]);
                        rt_PrevCmdLine = new TLine();
                        rt_PrevCmdLine.Cmd = ECmd.NONE;
                        if (Line > 0) rt_PrevCmdLine = new TLine(CmdList.Line[Line - 1]);

                        if (GDefine.TempCtrl_Type == GDefine.ETempCtrl.Autonics_TX_TK)
                        {
                            if (!b_TempCtrlChecked && RunMode == ERunMode.Normal)
                                if (TempCtrl.IsOpen)
                                {
                                    for (int i = 0; i < 4 - 1; i++)
                                    {
                                        if (DispProg.HeaterRange[i] > 0 && TempCtrl.AL1(i))
                                        {
                                            if (TaskDisp.Preference == TaskDisp.EPreference.Lumileds)
                                            {
                                                Msg MsgBox = new Msg();
                                                EMsgRes MsgRes = MsgBox.Show(ErrCode.TEMPCTRL_OUT_OF_RANGE, GDefine.TempCtrl_Module[i] + " " + i.ToString() + ".@Stop - Stop Operation.", EMcState.Notice, EMsgBtn.smbOK, false);
                                                goto _Pause;
                                            }
                                            else
                                            {
                                                Msg MsgBox = new Msg();
                                                EMsgRes MsgRes = MsgBox.Show(ErrCode.TEMPCTRL_OUT_OF_RANGE, GDefine.TempCtrl_Module[i] + " " + i.ToString() + ".@OK - Continue.@Stop - Stop Operation.", EMcState.Notice, EMsgBtn.smbOK_Stop, false);
                                                if (MsgRes == EMsgRes.smrStop)
                                                {
                                                    goto _Pause;
                                                }
                                            }
                                            b_TempCtrlChecked = true;
                                            break;
                                        }
                                    }
                                }
                                else
                                {
                                    Msg MsgBox = new Msg();
                                    EMsgRes MsgRes = MsgBox.Show(ErrCode.TEMPCTRL_NOT_CONNECTED);
                                    goto _Pause;
                                }
                        }

                        if (FlowRate.EnableAutoCalUnit && Stats.AutoFlowRateUnitCounter >= FlowRate.AutoCalUnitInterval)
                        {
                            EHeadNo HeadNo = EHeadNo.Head1;
                            if (rt_SyncHead2) HeadNo = EHeadNo.Head12;
                            bool b_Head1 = (HeadNo == EHeadNo.Head1 || HeadNo == EHeadNo.Head12);
                            bool b_Head2 = (HeadNo == EHeadNo.Head2 || HeadNo == EHeadNo.Head12);

                            frmFlowRateCal frm = new frmFlowRateCal(b_Head1, b_Head2);
                            if (frm.ShowDialog() == DialogResult.OK)
                            {
                                Stats.AutoFlowRateFrameCounter = 0;
                                Stats.AutoFlowRateUnitCounter = 0;
                            }
                            else
                                goto _Pause;
                        }

                        switch (CmdList.Line[Line].Cmd)
                        {
                            #region
                            case ECmd.COMMENT:
                                #region
                                {
                                    bool write = ActiveLine.IPara[0] > 0;
                                    if (write) Log.AddToEventLog($"Comment: {ActiveLine.String}");

                                    break;
                                }
                            #endregion
                            case ECmd.LAYOUT:
                                #region
                                {
                                    EMsg = Msg + " " + Enum.GetName(typeof(ECmd), ECmd.LAYOUT);

                                    TaskDisp.CtrlError.ResetFlag();

                                    rt_LayoutID = ActiveLine.ID;

                                    frm_DispCore_Map.LayoutNo = rt_LayoutID;

                                    rt_Layouts[rt_LayoutID] = new TLayout(ActiveLine);
                                    CurrMapMask(Map.PreMap[rt_LayoutID].Bin);

                                    rt_Start.X = rt_Layouts[rt_LayoutID].StartX;
                                    rt_Start.Y = rt_Layouts[rt_LayoutID].StartY;

                                    RunTime.UIndex = 0;
                                    RunTime.UIndex2 = 0;

                                    rt_RepeatCR = new Point(0, 0);
                                    rt_RepeatOfst = new PointF(0, 0);

                                    RunTime.Bias_Head_CR = new Point(0, 0);
                                    RunTime.Head_CR = new Point[] { new Point(0, 0), new Point(0, 0) };

                                    rt_Layouts[rt_LayoutID].ComputePos(ref rt_LayoutRelPos);
                                    break;
                                }
                            #endregion
                            case ECmd.FOR_LAYOUT:
                                #region
                                {
                                    EMsg = Msg + Enum.GetName(typeof(ECmd), ECmd.FOR_LAYOUT);

                                    if (!Running) goto _Pause;

                                    int LayoutID = CmdList.Line[Line].ID;

                                    if (!rtLoopActive[LayoutID])
                                    {
                                        b_InLoop = true;

                                        rtLoopActive[LayoutID] = true;
                                        rtLoopLineNo[LayoutID] = Line;
                                        RunTime.UIndex = 0;
                                    }

                                    rt_Layout_Rel_X = rt_LayoutRelPos[RunTime.UIndex].X;
                                    rt_Layout_Rel_Y = rt_LayoutRelPos[RunTime.UIndex].Y;

                                    #region 
                                    int ColNo = 0;
                                    int RowNo = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref ColNo, ref RowNo);
                                    int ColCount = rt_Layouts[rt_LayoutID].TColCount;
                                    int RowCount = rt_Layouts[rt_LayoutID].TRowCount;
                                    RunTime.Head_CR[0].X = ColNo + 1;
                                    RunTime.Head_CR[0].Y = RowNo + 1;

                                    if (rt_Layouts[0].MapOrigin == TLayout.EMapOrigin.Right) ColNo = ColCount - 1 - ColNo;
                                    RunTime.Bias_Head_CR.X = ColNo;
                                    RunTime.Bias_Head_CR.Y = RowNo;
                                    #endregion 

                                    rt_Layouts[rt_LayoutID].UnitNoGetHead2UnitNo(RunTime.UIndex, ref RunTime.UIndex2, ref b_Head2UnitIsValid);

                                    int h2ColNo = 0;
                                    int h2RowNo = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex2, ref h2ColNo, ref h2RowNo);
                                    RunTime.Head_CR[1].X = h2ColNo + 1;
                                    RunTime.Head_CR[1].Y = h2RowNo + 1;


                                    if (RunTime.UIndex2 < TLayout.MAX_UNITS)//invalid when exceed MAX_UNITS
                                    {
                                        rt_Layout_Rel_X2 = rt_LayoutRelPos[RunTime.UIndex2].X;
                                        rt_Layout_Rel_Y2 = rt_LayoutRelPos[RunTime.UIndex2].Y;
                                    }
                                    if (rt_SyncHead2)
                                    {
                                        b_SecondHalf = rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex);
                                    }
                                    if (DispProg.Pump_Type == TaskDisp.EPumpType.PP2D)
                                    {
                                        b_IsNeedle2 = rt_Layouts[rt_LayoutID].UnitNoIsNeedle2(RunTime.UIndex);
                                    }

                                    LastInCluster = true;
                                    if (!(b_SecondHalf || b_IsNeedle2))
                                        rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref LastUColNo, ref LastURowNo, ref LastCColNo, ref LastCRowNo);
                                    for (int i = RunTime.UIndex; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                    {
                                        if (i == rt_Layouts[rt_LayoutID].TUCount)
                                        {
                                            break;
                                        }

                                        if (rt_SyncHead2)
                                            if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(i + 1)) continue;
                                        if (DispProg.Pump_Type == TaskDisp.EPumpType.PP2D)
                                        {
                                            if (rt_Layouts[rt_LayoutID].UnitNoIsNeedle2(i + 1)) continue;
                                        }
                                        int NextUColNo = 0; int NextURowNo = 0; int NextCColNo = 0; int NextCRowNo = 0;
                                        rt_Layouts[rt_LayoutID].UnitNoGetRC(i + 1, ref NextUColNo, ref NextURowNo, ref NextCColNo, ref NextCRowNo);

                                        LastInCluster = (NextCColNo != LastCColNo || NextCRowNo != LastCRowNo);
                                        break;
                                    }

                                    break;
                                }
                            #endregion
                            case ECmd.END_LAYOUT:
                                #region
                                {
                                    EMsg = Msg + Enum.GetName(typeof(ECmd), ECmd.END_LAYOUT);

                                    int LayoutID = CmdList.Line[Line].ID;

                                    if (TaskDisp.CtrlError.IsErrorFlag())
                                    #region
                                    {
                                        TaskDisp.CtrlError.ResetFlag();
                                        switch (RunMode)
                                        {
                                            case ERunMode.Normal:
                                                {
                                                    Msg MsgBox = new Msg();
                                                    EMsgRes MsgRes = MsgBox.Show(ErrCode.DISPCTRL_ERR, EMcState.Notice, EMsgBtn.smbOK_Stop, false);
                                                    if (MsgRes == EMsgRes.smrStop) goto _Pause;
                                                    break;
                                                }
                                            default:
                                                break;
                                        }
                                    }
                                    #endregion

                                    if (rtLoopActive[LayoutID])
                                    {
                                        #region Move ZPanelGap
                                        TModelPara Model = new TModelPara(ModelList, 0);
                                        switch (RunMode)
                                        {
                                            case ERunMode.Normal:
                                            case ERunMode.Dry:
                                                {
                                                    if (LastInCluster && b_MovePanelGap && Model.PanelGap != 0)//CMD: END_LAYOUT
                                                    {
                                                        #region Move Panel Gap
                                                        if (!TaskGantry.SetMotionParamGZZ2()) return false;
                                                        if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                                        {
                                                            double Z1 = TaskGantry.GZPos();
                                                            double P1 = 0;
                                                            if (Z1 < 0) P1 = Math.Min(-Z1, Model.PanelGap);

                                                            double Z2 = TaskGantry.GZ2Pos();
                                                            double P2 = 0;
                                                            if (Z2 < 0) P2 = Math.Min(-Z2, Model.PanelGap);

                                                            if (P1 != 0 && P2 != 0)
                                                                if (!TaskGantry.MoveRelGZZ2(P1, P2)) return false;
                                                        }
                                                        else
                                                        {
                                                            double Z1 = TaskGantry.GZPos();
                                                            double P = 0;
                                                            if (Z1 < 0) P = Math.Min(-Z1, Model.PanelGap);

                                                            if (P != 0)

                                                                if (!TaskGantry.MoveRelGZ(P, true)) return false;
                                                        }
                                                        #endregion
                                                    }
                                                    break;
                                                }
                                            case ERunMode.Camera:
                                                {
                                                    break;
                                                }
                                        }
                                        #endregion

                                        RunTime.UIndex++;

                                        if (RunTime.UIndex < rt_Layouts[rt_LayoutID].TUCount)
                                        {
                                            Line = rtLoopLineNo[LayoutID];
                                            ExecutedLines.Clear();
                                            goto _Loop;
                                        }

                                        rtLoopActive[LayoutID] = false;
                                        RunTime.UIndex = 0;
                                        rt_Layout_Rel_X = 0;
                                        rt_Layout_Rel_Y = 0;
                                        rt_Layout_Rel_X2 = 0;
                                        rt_Layout_Rel_Y2 = 0;

                                        b_SecondHalf = false;
                                        b_IsNeedle2 = false;

                                        b_InLoop = false;
                                    }

                                    if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2)
                                    {
                                        TaskVision.flirCamera2[0].GrabCont();
                                    }
                                    if (GDefine.CameraType[0] is GDefine.ECameraType.MVCGenTL)
                                    {
                                        if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[0].StartGrab();
                                    }

                                    if (!Running) goto _Pause;

                                    break;
                                }
                            #endregion
                            case ECmd.REPEAT:
                                #region
                                {
                                    EMsg = Msg + CmdList.Line[Line].Cmd.ToString();

                                    int CCount = ActiveLine.Index[2];
                                    int RCount = ActiveLine.Index[4];

                                    PointF pf_RepeatCPitch = new PointF((float)ActiveLine.DPara[2], (float)ActiveLine.DPara[3]);
                                    PointF pf_RepeatRPitch = new PointF((float)ActiveLine.DPara[4], (float)ActiveLine.DPara[5]);

                                    TLayout.ELoopDir repeatLoopDir = TLayout.ELoopDir.XFZ;
                                    try { repeatLoopDir = (TLayout.ELoopDir)ActiveLine.IPara[1]; } catch { }

                                    switch (repeatLoopDir)
                                    {
                                        default://case TLayout.ELoopDir.XFZ:
                                            {
                                                if (rt_RepeatCR.X >= CCount - 1)
                                                {
                                                    if (rt_RepeatCR.Y >= RCount - 1)//end of repeat
                                                    {
                                                        rt_RepeatCR = new Point(0, 0);
                                                        rt_RepeatOfst = new PointF(0, 0);
                                                        goto _LastUnit;
                                                    }
                                                    else
                                                    {
                                                        rt_RepeatCR.X = 0;
                                                        rt_RepeatCR.Y++;
                                                    }
                                                }
                                                else
                                                    rt_RepeatCR.X++;
                                                break;
                                            }
                                        case TLayout.ELoopDir.XFU:
                                            {
                                                if (rt_RepeatCR.Y % 2 == 0)//even row
                                                {
                                                    if (rt_RepeatCR.X < CCount - 1)
                                                    {
                                                        rt_RepeatCR.X++;
                                                    }
                                                    else
                                                    {
                                                        if (rt_RepeatCR.Y >= RCount - 1)
                                                        {
                                                            rt_RepeatCR = new Point(0, 0);
                                                            rt_RepeatOfst = new PointF(0, 0);
                                                            goto _LastUnit;
                                                        }
                                                        else
                                                            rt_RepeatCR.Y++;
                                                    }
                                                }
                                                else//odd row
                                                {
                                                    if (rt_RepeatCR.X > 0)
                                                    {
                                                        rt_RepeatCR.X--;
                                                    }
                                                    else
                                                    {
                                                        if (rt_RepeatCR.Y >= RCount - 1)
                                                        {
                                                            rt_RepeatCR = new Point(0, 0);
                                                            rt_RepeatOfst = new PointF(0, 0);
                                                            goto _LastUnit;
                                                        }
                                                        else
                                                            rt_RepeatCR.Y++;
                                                    }
                                                }
                                                break;
                                            }
                                        case TLayout.ELoopDir.YFZ:
                                            {
                                                if (rt_RepeatCR.Y >= RCount - 1)
                                                {
                                                    if (rt_RepeatCR.X >= CCount - 1)//end of repeat
                                                    {
                                                        rt_RepeatCR = new Point(0, 0);
                                                        rt_RepeatOfst = new PointF(0, 0);
                                                        goto _LastUnit;
                                                    }
                                                    else
                                                    {
                                                        rt_RepeatCR.Y = 0;
                                                        rt_RepeatCR.X++;
                                                    }
                                                }
                                                else
                                                    rt_RepeatCR.Y++;
                                                break;
                                            }
                                        case TLayout.ELoopDir.YFU:
                                            {
                                                if (rt_RepeatCR.X % 2 == 0)//even row
                                                {
                                                    if (rt_RepeatCR.Y < RCount - 1)
                                                    {
                                                        rt_RepeatCR.Y++;
                                                    }
                                                    else
                                                    {
                                                        if (rt_RepeatCR.X >= CCount - 1)
                                                        {
                                                            rt_RepeatCR = new Point(0, 0);
                                                            rt_RepeatOfst = new PointF(0, 0);
                                                            goto _LastUnit;
                                                        }
                                                        else
                                                            rt_RepeatCR.X++;
                                                    }
                                                }
                                                else//odd row
                                                {
                                                    if (rt_RepeatCR.Y > 0)
                                                    {
                                                        rt_RepeatCR.Y--;
                                                    }
                                                    else
                                                    {
                                                        if (rt_RepeatCR.X >= CCount - 1)
                                                        {
                                                            rt_RepeatCR = new Point(0, 0);
                                                            rt_RepeatOfst = new PointF(0, 0);
                                                            goto _LastUnit;
                                                        }
                                                        else
                                                            rt_RepeatCR.X++;
                                                    }
                                                }
                                                break;
                                            }
                                    }

                                    rt_RepeatOfst.X = (pf_RepeatCPitch.X * rt_RepeatCR.X) + (pf_RepeatRPitch.X * rt_RepeatCR.Y);
                                    rt_RepeatOfst.Y = (pf_RepeatCPitch.Y * rt_RepeatCR.X) + (pf_RepeatRPitch.Y * rt_RepeatCR.Y);

                                    for (int L = Line; L > 0; L--)
                                    {
                                        if (
                                            (CmdList.Line[L].Cmd == ECmd.DOT || CmdList.Line[L].Cmd == ECmd.DOT_P || CmdList.Line[L].Cmd == ECmd.MOVE) &&
                                            !(CmdList.Line[L - 1].Cmd == ECmd.DOT || CmdList.Line[L - 1].Cmd == ECmd.DOT_P || CmdList.Line[L - 1].Cmd == ECmd.MOVE)
                                            )
                                        {
                                            Line = L;
                                            if (!Running)
                                            {
                                                LastLine = L;
                                                goto _Pause;
                                            }
                                            //Thread.Sleep(1);
                                            goto _Loop;
                                        }
                                        if (L == 1) throw new Exception("Incorrect Repeat Usage.");
                                    }

                                    if (!Running) goto _Pause;
                                    _LastUnit:
                                    break;
                                }
                            #endregion

                            case ECmd.LAYOUT_PREMAP:
                                #region
                                int layoutID = CmdList.Line[Line].ID;
                                ClearMaps();
                                CurrMapMask(Map.PreMap[layoutID].Bin);
                                rt_Head1MapBin = rt_Head2MapBin = EMapBin.None;
                                break;
                            #endregion

                            case ECmd.SET_GPOUT:
                                #region
                                {
                                    bool State = ActiveLine.IPara[0] > 0;

                                    switch (ActiveLine.ID)
                                    {
                                        case 1: TaskGantry.GPOut1 = State; break;
                                        case 2: TaskGantry.GPOut2 = State; break;
                                        case 3: TaskGantry.GPOut3 = State; break;
                                        case 4: TaskGantry.GPOut4 = State; break;
                                        case 5: TaskGantry.GPOut5 = State; break;
                                        case 6: TaskGantry.GPOut6 = State; break;
                                        default: throw new Exception("Invalid GPOutNo.");
                                    }
                                    break;
                                }
                            #endregion
                            case ECmd.SUB:
                                #region
                                {
                                    EMsg = Msg + " SUB";

                                    TaskVision.LightingOn(TaskVision.DefLightRGB);

                                    double dx = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[0];
                                    double dy = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[0];
                                    double dz = f_origin_z;

                                    double TWeight = CmdList.Line[Line].DPara[0];

                                    if (!DispProg.Script[CmdList.Line[Line].ID].Run(RunMode, dx, dy, dz, TaskDisp.FlowRateOld, TWeight, true)) Running = false;

                                    break;
                                }
                            #endregion

                            case ECmd.DO_REF:
                                {
                                    EMsg = Msg + Enum.GetName(typeof(ECmd), ECmd.DO_REF);
                                    int RefID = ActiveLine.ID;

                                    #region Get current unit info
                                    int CColNo = 0; int CRowNo = 0; int UColNo = 0; int URowNo = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref UColNo, ref URowNo, ref CColNo, ref CRowNo);
                                    int ColNo = 0; int RowNo = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref ColNo, ref RowNo);
                                    #endregion

                                    TRefData RefData = new TRefData();
                                    double d_Ref_Rel_X = rt_Layout_Rel_X;
                                    double d_Ref_Rel_Y = rt_Layout_Rel_Y;

                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                    {
                                        if (rt_Head2MapBin >= EMapBin.BinNG) goto _End;
                                    }
                                    else
                                        if (rt_Head1MapBin >= EMapBin.BinNG) goto _End;

                                    if (rt_RefDatas[RefID].Data[RunTime.UIndex].Ready) goto _End;

                                    b_Flag_ConsecutiveUnit = false;

                                    switch ((EAlignType)ActiveLine.IPara[2])
                                    {
                                        #region Manage Align Type
                                        case EAlignType.Board:
                                        default:
                                            #region
                                            d_Ref_Rel_X = rt_LayoutRelPos[0].X;
                                            d_Ref_Rel_Y = rt_LayoutRelPos[0].Y;
                                            break;
                                        #endregion
                                        case EAlignType.Clstr:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                if (i_CColNo == CColNo && i_CRowNo == CRowNo && i_UColNo == 0 && i_URowNo == 0)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.ClstrCol:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                if (i_CColNo == CColNo && i_CRowNo == 0 && i_UColNo == 0 && i_URowNo == 0)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.ClstrRow:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                if (i_CColNo == 0 && i_CRowNo == CRowNo && i_UColNo == 0 && i_URowNo == 0)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.Unit:
                                            #region
                                            if (rt_Head1MapBin >= EMapBin.BinNG) goto _End;
                                            break;
                                        #endregion
                                        case EAlignType.UnitCol:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_ColNo = 0; int i_RowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);

                                                if (i_ColNo == ColNo && i_RowNo == 0)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.UnitRow:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_ColNo = 0; int i_RowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);

                                                if (i_ColNo == 0 && i_RowNo == RowNo)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                            #endregion
                                            #endregion
                                    }

                                    TaskVision.LightingOn(TaskVision.LightRGB[RefID]);

                                    #region assign position and do pt1 vision
                                    double dx1 = f_origin_x + d_Ref_Rel_X + ActiveLine.X[0];
                                    double dy1 = f_origin_y + d_Ref_Rel_Y + ActiveLine.Y[0];

                                    double tdx1 = dx1;
                                    double tdy1 = dy1;

                                    if (ActiveLine.ID > 0) TranslatePos(dx1, dy1, rt_Head1RefData, ref dx1, ref dy1);

                                    _RetryRef1:
                                    double v_ox1 = 0;
                                    double v_oy1 = 0;
                                    double v_s1 = 0;
                                    Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> gray_FoundDoRef1 = null;
                                    if (!DoRef(ActiveLine, dx1, dy1, RefID, (int)EVisionRef.No1, out v_ox1, out v_oy1, out v_s1, ref gray_FoundDoRef1)) goto _Error;
                                    v_ox1 = v_ox1 * TaskVision.DistPerPixelX[ActiveLine.IPara[1]];
                                    v_oy1 = v_oy1 * TaskVision.DistPerPixelY[ActiveLine.IPara[1]];
                                    bool OK1 = (Math.Abs(v_ox1) <= ActiveLine.DPara[1]) && (Math.Abs(v_oy1) <= ActiveLine.DPara[1]) && (Math.Abs(v_s1) >= ActiveLine.DPara[0]);

                                    FoundDoRef1 = gray_FoundDoRef1.Convert<Emgu.CV.Structure.Bgr, byte>();
                                    FoundDoRef1_X = v_ox1;
                                    FoundDoRef1_Y = v_oy1;
                                    FoundDoRef1_S = v_s1;
                                    FoundDoRef1_OK = OK1;

                                    if (!OK1)
                                    {
                                        #region
                                        i_DoRefSkipCntr++;
                                        EFailAction FailAction = (EFailAction)ActiveLine.IPara[6];
                                        int SkipCount = CmdList.Line[Line].IPara[5];
                                        if (i_DoRefSkipCntr > SkipCount)
                                        {
                                            i_DoRefSkipCntr = 0;
                                            #region
                                            if (FailAction == EFailAction.AutoReject)
                                            {
                                                BdStatus = EBoardStatus.Reject;
                                                goto _EndBoard;
                                            }

                                            DefineSafety.DoorLock = false;

                                            if (System.IO.File.Exists(GDefine.AppPath + "\\Debug.txt"))
                                            {
                                                frm_DispCore_JogGantryVision frm = new frm_DispCore_JogGantryVision();
                                                frm.Inst = "Position Crosshair to Ref";
                                                frm.ShowVision = true;
                                                frm.Top = 0;
                                                DialogResult dr = frm.ShowDialog();

                                                if (dr == DialogResult.OK)
                                                {
                                                    OK1 = true;
                                                }
                                            }
                                            else
                                            {
                                                frm_DispCore_VisionFailMsg frm = new frm_DispCore_VisionFailMsg();
                                                frm.ShowSkipButton = ActiveLine.IPara[11] > 0;
                                                Log.AddToLog("DO_REF Point 1 fail.");
                                                DialogResult dr = frm.ShowDialog(FailAction,
                                                    TaskVision.RefTemplate[CmdList.Line[Line].ID, (int)EVisionRef.No1].Image.ToBitmap(),
                                                    FoundDoRef1.ToBitmap(),//Bitmap,
                                                    v_s1, v_ox1, v_oy1, 0,
                                                    CmdList.Line[Line].DPara[0], CmdList.Line[Line].DPara[1], 0);

                                                if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2)
                                                {
                                                    Application.OpenForms[0].Invoke(new Action(() =>
                                                    {
                                                        TaskVision.frmCamera.SelectCamera(0);
                                                        TaskVision.frmCamera.Grab();
                                                    }));
                                                }
                                                if (GDefine.CameraType[0] == GDefine.ECameraType.MVCGenTL)
                                                {
                                                    Application.OpenForms[0].Invoke(new Action(() =>
                                                    {
                                                        if (TaskVision.frmMVCGenTLCamera.Visible)
                                                        {
                                                            TaskVision.frmMVCGenTLCamera.SelectCamera(0);
                                                            if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[0].StartGrab();
                                                        }
                                                    }));
                                                }

                                                switch (dr)
                                                {
                                                    #region
                                                    case DialogResult.Retry:
                                                        Log.AddToLog("DO_REF Retry.");
                                                        DefineSafety.DoorLock = true;
                                                        goto _RetryRef1;
                                                    case DialogResult.Ignore://Skip
                                                        OK1 = false;
                                                        Log.AddToLog("DO_REF Skip.");
                                                        DefineSafety.DoorLock = true;
                                                        break;
                                                    case DialogResult.OK://Manual Adjust
                                                        v_ox1 = TaskGantry.GXPos() - dx1;
                                                        v_oy1 = TaskGantry.GYPos() - dy1;
                                                        if (ActiveLine.DPara[7] > 0)//enable Verify Score
                                                        {
                                                            double v_ox = 0;
                                                            double v_oy = 0;
                                                            double v_s = 0;
                                                            if (!DoRef(ActiveLine, dx1, dy1, RefID, (int)EVisionRef.No1, out v_ox, out v_oy, out v_s, ref gray_FoundDoRef1)) goto _Error;

                                                            if (v_s < ActiveLine.DPara[7])
                                                            {
                                                                if (NUtils.UserAcc.Active.GroupID < 2)
                                                                {
                                                                    int i_UserIdx = NUtils.UserAcc.Active.UserIndex;
                                                                    NUtils.UserAcc.Users.LoginDlg();
                                                                    if (NUtils.UserAcc.Active.GroupID < 2)
                                                                    {
                                                                        Log.AddToLog("DO_REF Vision verification fail.");
                                                                        goto _Pause;
                                                                    }
                                                                    Log.AddToLog("DO_REF Vision verification - bypassed by User Level");
                                                                }
                                                                else
                                                                    Log.AddToLog("DO_REF Vision verification bypassed by default User Level");
                                                            }
                                                            else
                                                                Log.AddToLog("DO_REF Vision verification pass.");
                                                        }

                                                        #region Check Offset in Spec
                                                        if (Math.Abs(v_ox1) > ActiveLine.DPara[1] || Math.Abs(v_oy1) > ActiveLine.DPara[1])
                                                        {
                                                            Msg MsgBox = new Msg();
                                                            EMsgRes MsgRes = MsgBox.Show(ErrCode.DO_REF_OFFSET_OOS, EMcState.Warning, EMsgBtn.smbOK_Stop, false);
                                                            if (MsgRes == EMsgRes.smrStop)
                                                            {
                                                                goto _Pause;
                                                            }
                                                        }
                                                        #endregion
                                                        OK1 = true;
                                                        Log.AddToLog("DO_REF Manual OK.");
                                                        DefineSafety.DoorLock = true;
                                                        break;
                                                    case DialogResult.Yes://Accept Position
                                                        OK1 = true;
                                                        Log.AddToLog("DO_REF Accept.");
                                                        DefineSafety.DoorLock = true;
                                                        break;
                                                    case DialogResult.Cancel://Reject
                                                        BdStatus = EBoardStatus.Reject;
                                                        Log.AddToLog("DO_REF Cancel.");
                                                        DefineSafety.DoorLock = true;
                                                        goto _EndBoard;
                                                    default://Stop
                                                        for (int L = Line; L >= 0; L--)
                                                        {
                                                            if (CmdList.Line[L].Cmd == ECmd.FOR_LAYOUT)
                                                            {
                                                                LastLine = L;
                                                                break;
                                                            }
                                                        }
                                                        Log.AddToLog("DO_REF Stop.");
                                                        //if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2)
                                                        //{
                                                        //    Application.OpenForms[0].Invoke(new Action(() =>
                                                        //    {
                                                        //        TaskVision.frmCamera.SelectCamera(0);
                                                        //        TaskVision.frmCamera.Grab();
                                                        //    }));
                                                        //}
                                                        goto _Pause;
                                                        #endregion
                                                }
                                            }
                                            #endregion
                                        }
                                        #endregion
                                    }
                                    else
                                        if (CmdList.Line[Line].IPara[0] != 2) i_DoRefSkipCntr = 0;

                                    double ndx1 = dx1 + v_ox1;
                                    double ndy1 = dy1 + v_oy1;
                                    #endregion

                                    #region assign ref data
                                    RefData.Ready = true;
                                    RefData.DatumX = tdx1;
                                    RefData.DatumY = tdy1;
                                    //RefData.DatumX = dx1;
                                    //RefData.DatumY = dy1;
                                    RefData.NewDatumX = ndx1;
                                    RefData.NewDatumY = ndy1;
                                    RefData.Angle = 0;
                                    RefData.OK = OK1;
                                    //UnTranslatePos(RefData.DatumX, RefData.DatumY, rt_Head1RefData, ref RefData.DatumX, ref RefData.DatumY);
                                    #endregion

                                    if (!OK1) goto _RefEnd;

                                    if (CmdList.Line[Line].IPara[0] == 2)
                                    {
                                        #region assign position and do pt2 vision
                                        //double dx2 = f_origin_x + rt_Layout_Rel_X + ActiveLine.X[1];
                                        //double dy2 = f_origin_y + rt_Layout_Rel_Y + ActiveLine.Y[1];
                                        double dx2 = f_origin_x + d_Ref_Rel_X + ActiveLine.X[1];
                                        double dy2 = f_origin_y + d_Ref_Rel_Y + ActiveLine.Y[1];
                                        if (ActiveLine.ID > 0)
                                            TranslatePos(dx2, dy2, rt_Head1RefData, ref dx2, ref dy2);

                                        double v_ox2 = 0;
                                        double v_oy2 = 0;
                                        double v_s2 = 0;
                                        Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> gray_FoundDoRef2 = null;
                                        //if (!DoVision(ActiveLine, dx2, dy2, RefID, (int)EVisionRef.No2, out v_ox2, out v_oy2, out v_s2, ref FoundDoRef2)) goto _Error;
                                        if (!DoRef(ActiveLine, dx2, dy2, RefID, (int)EVisionRef.No2, out v_ox2, out v_oy2, out v_s2, ref gray_FoundDoRef2)) goto _Error;
                                        v_ox2 = v_ox2 * TaskVision.DistPerPixelX[ActiveLine.IPara[1]];
                                        v_oy2 = v_oy2 * TaskVision.DistPerPixelY[ActiveLine.IPara[1]];
                                        //v_s2 = v_s2;
                                        bool OK2 = (Math.Abs(v_ox2) <= ActiveLine.DPara[1]) && (Math.Abs(v_oy2) <= ActiveLine.DPara[1]) && (Math.Abs(v_s2) >= ActiveLine.DPara[0]);

                                        FoundDoRef2 = gray_FoundDoRef2.Convert<Emgu.CV.Structure.Bgr, byte>();
                                        FoundDoRef2_X = v_ox2;
                                        FoundDoRef2_Y = v_oy2;
                                        FoundDoRef2_S = v_s2;
                                        FoundDoRef2_OK = OK2;

                                        double ndx2 = dx2 + v_ox2;
                                        double ndy2 = dy2 + v_oy2;
                                        #endregion

                                        #region compute pt1 and pt2 angle
                                        Point2D OriPt1 = new Point2D(dx1, dy1);
                                        Point2D OriPt2 = new Point2D(dx2, dy2);
                                        Point2D NewPt1 = new Point2D(ndx1, ndy1);
                                        Point2D NewPt2 = new Point2D(ndx2, ndy2);
                                        double Angle_Rad = (double)NewPt2.Angle(NewPt1, OriPt1, OriPt2);
                                        if (Angle_Rad > Math.PI) Angle_Rad = Angle_Rad - (Math.PI * 2);
                                        double Angle_Deg = (Angle_Rad * 180) / Math.PI;
                                        bool OKA = (Math.Abs(Angle_Rad) <= ActiveLine.DPara[2]);
                                        OK2 = OK2 && OKA;
                                        #endregion

                                        if (!OK2)
                                        {
                                            #region
                                            EFailAction FailAction = (EFailAction)ActiveLine.IPara[6];
                                            i_DoRefSkipCntr++;
                                            int SkipCount = CmdList.Line[Line].IPara[5];
                                            if (i_DoRefSkipCntr > SkipCount)
                                            {
                                                i_DoRefSkipCntr = 0;

                                                if (FailAction == EFailAction.AutoReject)
                                                {
                                                    BdStatus = EBoardStatus.Reject;
                                                    goto _EndBoard;
                                                }

                                                DefineSafety.DoorLock = false;
                                                frm_DispCore_VisionFailMsg frm = new frm_DispCore_VisionFailMsg();
                                                frm.ShowSkipButton = ActiveLine.IPara[11] > 0;
                                                Log.AddToLog("DO_REF Point 2 fail.");
                                                DialogResult dr = frm.ShowDialog(FailAction,
                                                    TaskVision.RefTemplate[CmdList.Line[Line].ID, (int)EVisionRef.No2].Image.ToBitmap(),
                                                    FoundDoRef2.ToBitmap(),
                                                    v_s2, v_ox2, v_oy2, Angle_Rad,
                                                    ActiveLine.DPara[0], ActiveLine.DPara[1], ActiveLine.DPara[2]);

                                                if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2)
                                                {
                                                    Application.OpenForms[0].Invoke(new Action(() =>
                                                    {

                                                        TaskVision.frmCamera.SelectCamera(0);
                                                        TaskVision.frmCamera.Grab();
                                                    }));
                                                }
                                                if (GDefine.CameraType[0] == GDefine.ECameraType.MVCGenTL)
                                                {
                                                    Application.OpenForms[0].Invoke(new Action(() =>
                                                    {
                                                        if (TaskVision.frmMVCGenTLCamera.Visible)
                                                        {
                                                            TaskVision.frmMVCGenTLCamera.SelectCamera(0);
                                                            if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[0].StartGrab();
                                                        }
                                                    }));
                                                }

                                                switch (dr)
                                                {
                                                    case DialogResult.Retry:
                                                        Log.AddToLog("DO_REF Retry.");
                                                        DefineSafety.DoorLock = true;
                                                        goto _RetryRef1;
                                                    case DialogResult.Ignore:
                                                        OK2 = false;
                                                        Log.AddToLog("DO_REF Ignore.");
                                                        DefineSafety.DoorLock = true;
                                                        break;
                                                    case DialogResult.OK:
                                                        v_ox2 = TaskGantry.GXPos() - dx2;
                                                        v_oy2 = TaskGantry.GYPos() - dy2;
                                                        OK2 = true;

                                                        ndx2 = dx2 + v_ox2;
                                                        ndy2 = dy2 + v_oy2;

                                                        NewPt2 = new Point2D(ndx2, ndy2);
                                                        Angle_Rad = (double)NewPt2.Angle(NewPt1, OriPt1, OriPt2);
                                                        Angle_Deg = (Angle_Rad * 180) / Math.PI;

                                                        #region Check Offset and Angle in Spec
                                                        if (Math.Abs(Angle_Deg) > ActiveLine.DPara[2])
                                                        {
                                                            Msg MsgBox = new Msg();
                                                            EMsgRes MsgRes = MsgBox.Show(ErrCode.DO_REF_ANGLE_OOS, EMcState.Warning, EMsgBtn.smbOK_Stop, false);
                                                            if (MsgRes == EMsgRes.smrStop)
                                                            {
                                                                goto _Pause;
                                                            }
                                                        }
                                                        #endregion
                                                        OK2 = true;
                                                        Log.AddToLog("DO_REF Manual OK.");
                                                        DefineSafety.DoorLock = true;
                                                        break;
                                                    case DialogResult.Yes:
                                                        OK2 = true;
                                                        Log.AddToLog("DO_REF Accept.");
                                                        DefineSafety.DoorLock = true;
                                                        break;
                                                    case DialogResult.Cancel://Reject
                                                        BdStatus = EBoardStatus.Reject;
                                                        Log.AddToLog("DO_REF Cancel.");
                                                        DefineSafety.DoorLock = true;
                                                        goto _EndBoard;
                                                    default:
                                                        for (int L = Line; L >= 0; L--)
                                                        {
                                                            if (CmdList.Line[L].Cmd == ECmd.FOR_LAYOUT)
                                                            {
                                                                LastLine = L;
                                                                break;
                                                            }
                                                        }
                                                        Log.AddToLog("DO_REF Stop.");
                                                        goto _Pause;
                                                }
                                            }
                                            #endregion
                                        }
                                        else
                                            i_DoRefSkipCntr = 0;

                                        #region compute pt1 and pt2 distance
                                        {
                                            Polar Ori = new Polar(OriPt1, OriPt2);
                                            Polar New = new Polar(NewPt1, NewPt2);
                                            double Diff = Math.Abs(Ori.R - New.R);
                                            if (ActiveLine.DPara[3] > 0)
                                            {
                                                bool OKD = Diff <= ActiveLine.DPara[3];
                                                OK2 = OK2 && OKD;

                                                if (!OKD)
                                                {
                                                    //if (Math.Abs(Angle_Deg) > ActiveLine.DPara[2])
                                                    //{
                                                    //    DialogResult dr = MessageBox.Show("Point 1 and 2 Distance Difference (" + New.R.ToString("F3") + ") is more than spec (" + Ori.R.ToString("F3") + ")." +
                                                    //        "Continue?", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                                    //    if (dr == DialogResult.OK)
                                                    //    {
                                                    //        goto _Pause;
                                                    //    }
                                                    //}
                                                    Msg MsgBox = new Msg();
                                                    EMsgRes MsgRes = MsgBox.Show(ErrCode.DO_REF_PT1_PT2_DIST_OOS, EMcState.Warning, EMsgBtn.smbOK_Stop, false);
                                                    if (MsgRes == EMsgRes.smrStop)
                                                    {
                                                        goto _Pause;
                                                    }
                                                }
                                            }
                                        }
                                        #endregion

                                        #region assign ref data
                                        RefData.Angle = Angle_Rad;
                                        RefData.OK = OK1 && OK2;
                                        #endregion
                                    }

                                _RefEnd:

                                    #region Write Vision Data
                                    string s_VisionData = "";
                                    if (CmdList.Line[Line].IPara[0] == 2)
                                    {
                                        s_VisionData = s_VisionData + "OX, OY, OA, S, Result" + (char)9 +
                                            v_ox1.ToString("f3") + (char)9 +
                                            v_oy1.ToString("f3") + (char)9 +
                                            (RefData.Angle * 180 / Math.PI).ToString("f3") + (char)9 +
                                            v_s1.ToString("f3") + (char)9 +
                                            RefData.OK.ToString() + (char)9;
                                    }
                                    else
                                    {
                                        s_VisionData = s_VisionData + "OX, OY, S, Result" + (char)9 +
                                            v_ox1.ToString("f3") + (char)9 +
                                            v_oy1.ToString("f3") + (char)9 +
                                            v_s1.ToString("f3") + (char)9 +
                                            OK1.ToString();
                                    }
                                    Log.Vision.WriteByMonthDay("UnitNo " + (char)9 + RunTime.UIndex.ToString() + (char)9 + s_VisionData);
                                    #endregion

                                    if (!b_InLoop)//***update all layout if ref is done outside loop
                                    {
                                        #region
                                        for (int ID = 0; ID < rt_LayoutCount; ID++)
                                        {
                                            for (int i = 0; i < rt_Layouts[ID].TUCount; i++)
                                            {
                                                rt_RefDatas[RefID].Data[i].Copy(RefData);// rt_RefData[RefID, i].Copy(RefData);
                                                if (Map.CurrMap[ID].Bin[i] < EMapBin.BinNG)
                                                {
                                                    if (rt_RefDatas[RefID].Data[i].OK)//if (rt_RefData[RefID, i].OK)
                                                        Map.CurrMap[ID].Bin[i] = EMapBin.RefOK;
                                                    else
                                                        Map.CurrMap[ID].Bin[i] = EMapBin.RefNG;
                                                }
                                            }
                                        }
                                        #endregion
                                    }
                                    else
                                        switch ((EAlignType)ActiveLine.IPara[2])
                                        {
                                            #region Update Unit RefData
                                            case EAlignType.Board:
                                            default:
                                                #region
                                                {
                                                    if (ActiveLine.IPara[7] > 0)//update all layout; eg for net dispense
                                                    {
                                                        for (int ID = rt_LayoutID; ID < rt_LayoutCount; ID++)
                                                        {
                                                            for (int i = 0; i < rt_Layouts[ID].TUCount; i++)
                                                            {
                                                                rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                                if (Map.CurrMap[ID].Bin[i] < EMapBin.BinNG)
                                                                {
                                                                    if (rt_RefDatas[RefID].Data[i].OK)
                                                                        Map.CurrMap[ID].Bin[i] = EMapBin.RefOK;
                                                                    else
                                                                        Map.CurrMap[ID].Bin[i] = EMapBin.RefNG;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else
                                                    {
                                                        for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                        {
                                                            rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                            if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                            {
                                                                if (rt_RefDatas[RefID].Data[i].OK)
                                                                    Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                                else
                                                                    Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.Clstr:
                                                #region
                                                {
                                                    if (ActiveLine.IPara[7] > 0)//update all layout; eg for net dispense
                                                    {
                                                        for (int ID = rt_LayoutID; ID < rt_LayoutCount; ID++)
                                                        {
                                                            for (int i = 0; i < rt_Layouts[ID].TUCount; i++)
                                                            {
                                                                int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                                rt_Layouts[ID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                                if (i_CColNo == CColNo && i_CRowNo == CRowNo)
                                                                {
                                                                    rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                                    if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                                    {
                                                                        if (rt_RefDatas[RefID].Data[i].OK)
                                                                            Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                                        else
                                                                            Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else
                                                    {
                                                        for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                        {
                                                            int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                            rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                            if (i_CColNo == CColNo && i_CRowNo == CRowNo)
                                                            {
                                                                rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                                if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                                {
                                                                    if (rt_RefDatas[RefID].Data[i].OK)
                                                                        Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                                    else
                                                                        Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.ClstrCol:
                                                #region
                                                {
                                                    for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                    {
                                                        int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                        rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                        if (i_CColNo == CColNo)
                                                        {
                                                            rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                            if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                            {
                                                                if (rt_RefDatas[RefID].Data[i].OK)
                                                                    Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                                else
                                                                    Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.ClstrRow:
                                                #region
                                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                {
                                                    int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                    if (i_CRowNo == CRowNo)// && i_UColNo == UColNo && i_URowNo == URowNo)
                                                    {
                                                        rt_RefDatas[RefID].Data[i].Copy(RefData);// rt_RefData[RefID, i].Copy(RefData);
                                                        if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                        {
                                                            if (rt_RefDatas[RefID].Data[i].OK)//if (rt_RefData[RefID, i].OK)
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                            else
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.Unit:
                                                #region
                                                {
                                                    int i = RunTime.UIndex;
                                                    rt_RefDatas[RefID].Data[i].Copy(RefData);// rt_RefData[RefID, i].Copy(RefData);
                                                    if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                    {
                                                        if (rt_RefDatas[RefID].Data[i].OK)//if (rt_RefData[RefID, i].OK)
                                                            Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                        else
                                                            Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.UnitCol:
                                                #region
                                                //if (RowNo == 0)
                                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                {
                                                    int i_ColNo = 0; int i_RowNo = 0;
                                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);

                                                    if (i_ColNo == ColNo)
                                                    {
                                                        rt_RefDatas[RefID].Data[i].Copy(RefData);// rt_RefData[RefID, i].Copy(RefData);
                                                        if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                        {
                                                            if (rt_RefDatas[RefID].Data[i].OK)//if (rt_RefData[RefID, i].OK)
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                            else
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.UnitRow:
                                                #region
                                                //if (ColNo == 0)
                                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                {
                                                    int i_ColNo = 0; int i_RowNo = 0;
                                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);

                                                    if (i_RowNo == RowNo)
                                                    {
                                                        rt_RefDatas[RefID].Data[i].Copy(RefData);// rt_RefData[RefID, i].Copy(RefData);
                                                        if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                        {
                                                            if (rt_RefDatas[RefID].Data[i].OK)//if (rt_RefData[RefID, i].OK)
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                            else
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                        }
                                                    }
                                                }
                                                break;
                                                #endregion
                                                #endregion
                                        }
                                    _End:
                                    break;
                                }
                            case ECmd.DO_REF_EDGE:
                                {
                                    EMsg = Msg + ActiveLine.Cmd.ToString();
                                    int RefID = ActiveLine.ID;

                                    #region Get current unit info
                                    int CColNo = 0; int CRowNo = 0; int UColNo = 0; int URowNo = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref UColNo, ref URowNo, ref CColNo, ref CRowNo);
                                    int ColNo = 0; int RowNo = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref ColNo, ref RowNo);
                                    #endregion

                                    TRefData RefData = new TRefData();
                                    double d_Ref_Rel_X = rt_Layout_Rel_X;
                                    double d_Ref_Rel_Y = rt_Layout_Rel_Y;

                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                    {
                                        if (rt_Head2MapBin >= EMapBin.BinNG) goto _End;
                                    }
                                    else
                                        if (rt_Head1MapBin >= EMapBin.BinNG) goto _End;

                                    if (rt_RefDatas[RefID].Data[RunTime.UIndex].Ready) goto _End;

                                    b_Flag_ConsecutiveUnit = false;

                                    switch ((EAlignType)ActiveLine.IPara[2])
                                    {
                                        #region Manage Align Type
                                        case EAlignType.Board:
                                        default:
                                            #region
                                            d_Ref_Rel_X = rt_LayoutRelPos[0].X;
                                            d_Ref_Rel_Y = rt_LayoutRelPos[0].Y;
                                            break;
                                        #endregion
                                        case EAlignType.Clstr:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                if (i_CColNo == CColNo && i_CRowNo == CRowNo && i_UColNo == 0 && i_URowNo == 0)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.ClstrCol:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                if (i_CColNo == CColNo && i_CRowNo == 0 && i_UColNo == 0 && i_URowNo == 0)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.ClstrRow:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                if (i_CColNo == 0 && i_CRowNo == CRowNo && i_UColNo == 0 && i_URowNo == 0)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.Unit:
                                            #region
                                            if (rt_Head1MapBin >= EMapBin.BinNG) goto _End;
                                            break;
                                        #endregion
                                        case EAlignType.UnitCol:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_ColNo = 0; int i_RowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);

                                                if (i_ColNo == ColNo && i_RowNo == 0)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.UnitRow:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_ColNo = 0; int i_RowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);

                                                if (i_ColNo == 0 && i_RowNo == RowNo)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                            #endregion
                                            #endregion
                                    }

                                    TaskVision.LightingOn(TaskVision.LightRGB[RefID]);

                                    #region assign position and do pt1 vision
                                    double dx1 = f_origin_x + d_Ref_Rel_X + ActiveLine.X[0];
                                    double dy1 = f_origin_y + d_Ref_Rel_Y + ActiveLine.Y[0];

                                    double tdx1 = dx1;
                                    double tdy1 = dy1;

                                    if (ActiveLine.ID > 0) TranslatePos(dx1, dy1, rt_Head1RefData, ref dx1, ref dy1);

                                    _RetryRef1:
                                    double v_ox1_mm = 0;
                                    double v_oy1_mm = 0;
                                    PointF patLoc = new PointF(0, 0);
                                    float ampScore = 0;
                                    float ampScore2 = 0;
                                    int found = 0;
                                    int found2 = 0;
                                    float roundness = 0;
                                    float roundness2 = 0;

                                    bool OK1 = false;
                                    switch (ActiveLine.IPara[8])
                                    {
                                        case 0:
                                            {
                                                PointF ofst_mm = new PointF(0, 0);
                                                if (!DoRefEdge(ActiveLine, 0, dx1, dy1, ref patLoc, ref ofst_mm, ref ampScore)) goto _Error;
                                                v_ox1_mm = ofst_mm.X;
                                                v_oy1_mm = ofst_mm.Y;
                                                OK1 = (Math.Abs(v_ox1_mm) <= ActiveLine.DPara[1]) && (Math.Abs(v_oy1_mm) <= ActiveLine.DPara[1]) && (ampScore > 10);

                                                Graphics g;
                                                g = TaskVision.flirCamera2[0].imgBoxEmgu.CreateGraphics();
                                                Pen p = new Pen(Color.Blue, 10);
                                                p.Color = ampScore > 10 ? Color.Lime : Color.Red;
                                                g.DrawLine(p, patLoc.X, patLoc.Y - 20, patLoc.X, patLoc.Y + 20);
                                                g.DrawLine(p, patLoc.X - 20, patLoc.Y, patLoc.X + 20, patLoc.Y);

                                                FoundDoRef1_X = v_ox1_mm;
                                                FoundDoRef1_Y = v_oy1_mm;
                                                FoundDoRef1_S = ampScore / 255;
                                                FoundDoRef1_OK = OK1;

                                                break;
                                            }
                                        case 1:
                                            {
                                                PointF ofst_mm = new PointF(0, 0);
                                                if (!DoRefCircle(ActiveLine, 0, dx1, dy1, ref patLoc, ref ofst_mm, ref found, ref roundness)) goto _Error;
                                                v_ox1_mm = ofst_mm.X;
                                                v_oy1_mm = ofst_mm.Y;
                                                OK1 = (roundness > 0.85) && (Math.Abs(v_ox1_mm) <= ActiveLine.DPara[1]) && (Math.Abs(v_oy1_mm) <= ActiveLine.DPara[1]);

                                                Graphics g;
                                                g = TaskVision.flirCamera2[0].imgBoxEmgu.CreateGraphics();
                                                Pen p = new Pen(Color.Blue, 10);
                                                p.Color = ampScore > 0.8 ? Color.Lime : Color.Red;
                                                g.DrawLine(p, patLoc.X, patLoc.Y - 20, patLoc.X, patLoc.Y + 20);
                                                g.DrawLine(p, patLoc.X - 20, patLoc.Y, patLoc.X + 20, patLoc.Y);

                                                FoundDoRef1_X = v_ox1_mm;
                                                FoundDoRef1_Y = v_oy1_mm;
                                                FoundDoRef1_S = roundness;
                                                FoundDoRef1_OK = OK1;

                                                break;
                                            }
                                    }


                                    if (!OK1)
                                    {
                                        #region
                                        i_DoRefSkipCntr++;
                                        EFailAction FailAction = (EFailAction)ActiveLine.IPara[6];
                                        int SkipCount = CmdList.Line[Line].IPara[5];
                                        if (i_DoRefSkipCntr > SkipCount)
                                        {
                                            i_DoRefSkipCntr = 0;
                                            #region
                                            if (FailAction == EFailAction.AutoReject)
                                            {
                                                BdStatus = EBoardStatus.Reject;
                                                goto _EndBoard;
                                            }

                                            DefineSafety.DoorLock = false;

                                            if (System.IO.File.Exists(GDefine.AppPath + "\\Debug.txt"))
                                            {
                                                frm_DispCore_JogGantryVision frm = new frm_DispCore_JogGantryVision();
                                                frm.Inst = "Position Crosshair to Ref";
                                                frm.ShowVision = true;
                                                frm.Top = 0;
                                                DialogResult dr = frm.ShowDialog();

                                                if (dr == DialogResult.OK)
                                                {
                                                    OK1 = true;
                                                }
                                            }
                                            else
                                            {
                                                frmVisionFailMsg2 frmV = new frmVisionFailMsg2();
                                                string msg = "Point 1 Fail";
                                                Log.AddToLog(ActiveLine.Cmd.ToString() + " Fail Unit No " + RunTime.UIndex.ToString() + " " + msg);
                                                frmV.Message = msg;
                                                DialogResult dr = frmV.ShowDialog();

                                                switch (dr)
                                                {
                                                    #region
                                                    case DialogResult.Retry:
                                                        Log.AddToLog("0" + (char)9 + "Retry");
                                                        DefineSafety.DoorLock = true;
                                                        Thread.Sleep(100);
                                                        goto _RetryRef1;
                                                    case DialogResult.Cancel://Skip
                                                        Log.AddToLog("0" + (char)9 + "Skip");
                                                        OK1 = false;
                                                        DefineSafety.DoorLock = true;
                                                        Thread.Sleep(100);
                                                        break;
                                                    case DialogResult.OK://Manual Adjust
                                                        Log.AddToLog("0" + (char)9 + "Manual");
                                                        frm_DispProg_View frm = new frm_DispProg_View();

                                                        if (frm.ShowDialog() == DialogResult.OK)
                                                        {
                                                            v_ox1_mm = TaskGantry.GXPos() - dx1;
                                                            v_oy1_mm = TaskGantry.GYPos() - dy1;
                                                            Log.AddToLog("0" + (char)9 + v_ox1_mm.ToString("f3") + "," + v_oy1_mm.ToString("f3"));
                                                            OK1 = true;
                                                        }
                                                        else goto default;
                                                        DefineSafety.DoorLock = true;
                                                        Thread.Sleep(100);
                                                        break;
                                                    default://Stop
                                                        Log.AddToLog("0" + (char)9 + "Stop");
                                                        for (int L = Line; L >= 0; L--)
                                                        {
                                                            if (CmdList.Line[L].Cmd == ECmd.FOR_LAYOUT)
                                                            {
                                                                LastLine = L;
                                                                break;
                                                            }
                                                        }
                                                        Thread.Sleep(100);
                                                        goto _Pause;
                                                        #endregion
                                                }

                                                if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2)
                                                {
                                                    Application.OpenForms[0].Invoke(new Action(() =>
                                                    {
                                                        TaskVision.frmCamera.SelectCamera(0);
                                                        TaskVision.frmCamera.Grab();
                                                    }));
                                                }
                                                if (GDefine.CameraType[0] == GDefine.ECameraType.MVCGenTL)
                                                {
                                                    Application.OpenForms[0].Invoke(new Action(() =>
                                                    {
                                                        if (TaskVision.frmMVCGenTLCamera.Visible)
                                                        {
                                                            TaskVision.frmMVCGenTLCamera.SelectCamera(0);
                                                            if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[0].StartGrab();
                                                        }
                                                    }));
                                                }
                                            }
                                            #endregion
                                        }
                                        #endregion
                                    }
                                    else
                                        if (CmdList.Line[Line].IPara[0] != 2) i_DoRefSkipCntr = 0;

                                    double ndx1 = dx1 + v_ox1_mm;
                                    double ndy1 = dy1 + v_oy1_mm;
                                    #endregion

                                    #region assign ref data
                                    RefData.Ready = true;
                                    RefData.DatumX = tdx1;
                                    RefData.DatumY = tdy1;
                                    RefData.NewDatumX = ndx1;
                                    RefData.NewDatumY = ndy1;
                                    RefData.Angle = 0;
                                    RefData.OK = OK1;
                                    #endregion

                                    if (!OK1) goto _RefEnd;

                                    if (CmdList.Line[Line].IPara[0] == 2)
                                    {
                                        #region assign position and do pt2 vision
                                        double dx2 = f_origin_x + d_Ref_Rel_X + ActiveLine.X[1];
                                        double dy2 = f_origin_y + d_Ref_Rel_Y + ActiveLine.Y[1];
                                        if (ActiveLine.ID > 0) TranslatePos(dx2, dy2, rt_Head1RefData, ref dx2, ref dy2);

                                        double v_ox2_mm = 0;
                                        double v_oy2_mm = 0;
                                        bool OK2 = false;

                                        switch (ActiveLine.IPara[9])
                                        {
                                            case 0:
                                                {
                                                    PointF ofst_mm = new PointF(0, 0);
                                                    if (!DoRefEdge(ActiveLine, 1, dx2, dy2, ref patLoc, ref ofst_mm, ref ampScore2)) goto _Error;
                                                    v_ox2_mm = ofst_mm.X;
                                                    v_oy2_mm = ofst_mm.Y;
                                                    OK2 = (Math.Abs(v_ox2_mm) <= ActiveLine.DPara[1]) && (Math.Abs(v_oy2_mm) <= ActiveLine.DPara[1]) && (ampScore2 > 10);

                                                    Graphics g;
                                                    g = TaskVision.flirCamera2[0].imgBoxEmgu.CreateGraphics();
                                                    Pen p = new Pen(Color.Blue, 10);
                                                    p.Color = ampScore2 > 10 ? Color.Lime : Color.Red;
                                                    g.DrawLine(p, patLoc.X, patLoc.Y - 20, patLoc.X, patLoc.Y + 20);
                                                    g.DrawLine(p, patLoc.X - 20, patLoc.Y, patLoc.X + 20, patLoc.Y);

                                                    FoundDoRef2_X = v_ox2_mm;
                                                    FoundDoRef2_Y = v_oy2_mm;
                                                    FoundDoRef2_S = ampScore2 / 255;
                                                    FoundDoRef2_OK = OK2;
                                                    break;
                                                }
                                            case 1:
                                                {
                                                    PointF ofst_mm = new PointF(0, 0);
                                                    if (!DoRefCircle(ActiveLine, 1, dx2, dy2, ref patLoc, ref ofst_mm, ref found2, ref roundness2)) goto _Error;
                                                    v_ox2_mm = ofst_mm.X;
                                                    v_oy2_mm = ofst_mm.Y;
                                                    OK2 = (roundness2 > 0.85) && (Math.Abs(v_ox2_mm) <= ActiveLine.DPara[1]) && (Math.Abs(v_oy2_mm) <= ActiveLine.DPara[1]);

                                                    Graphics g;
                                                    g = TaskVision.flirCamera2[0].imgBoxEmgu.CreateGraphics();
                                                    Pen p = new Pen(Color.Blue, 10);
                                                    p.Color = ampScore2 > 0.8 ? Color.Lime : Color.Red;
                                                    g.DrawLine(p, patLoc.X, patLoc.Y - 20, patLoc.X, patLoc.Y + 20);
                                                    g.DrawLine(p, patLoc.X - 20, patLoc.Y, patLoc.X + 20, patLoc.Y);

                                                    FoundDoRef2_X = v_ox2_mm;
                                                    FoundDoRef2_Y = v_oy2_mm;
                                                    FoundDoRef2_S = roundness2;
                                                    FoundDoRef2_OK = OK2;

                                                    break;
                                                }
                                        }

                                        double ndx2 = dx2 + v_ox2_mm;
                                        double ndy2 = dy2 + v_oy2_mm;
                                        #endregion

                                        #region compute pt1 and pt2 angle
                                        Point2D OriPt1 = new Point2D(dx1, dy1);
                                        Point2D OriPt2 = new Point2D(dx2, dy2);
                                        Point2D NewPt1 = new Point2D(ndx1, ndy1);
                                        Point2D NewPt2 = new Point2D(ndx2, ndy2);
                                        double Angle_Rad = (double)NewPt2.Angle(NewPt1, OriPt1, OriPt2);
                                        if (Angle_Rad > Math.PI) Angle_Rad = Angle_Rad - (Math.PI * 2);
                                        double Angle_Deg = (Angle_Rad * 180) / Math.PI;
                                        bool OKA = (Math.Abs(Angle_Rad) <= ActiveLine.DPara[2]);
                                        OK2 = OK2 && OKA;
                                        #endregion

                                        if (!OK2)
                                        {
                                            #region
                                            EFailAction FailAction = (EFailAction)ActiveLine.IPara[6];
                                            i_DoRefSkipCntr++;
                                            int SkipCount = CmdList.Line[Line].IPara[5];
                                            if (i_DoRefSkipCntr > SkipCount)
                                            {
                                                i_DoRefSkipCntr = 0;

                                                if (FailAction == EFailAction.AutoReject)
                                                {
                                                    BdStatus = EBoardStatus.Reject;
                                                    goto _EndBoard;
                                                }

                                                if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2)
                                                {
                                                    Application.OpenForms[0].Invoke(new Action(() =>
                                                    {

                                                        TaskVision.frmCamera.SelectCamera(0);
                                                        TaskVision.frmCamera.Grab();
                                                    }));
                                                }
                                                if (GDefine.CameraType[0] == GDefine.ECameraType.MVCGenTL)
                                                {
                                                    Application.OpenForms[0].Invoke(new Action(() =>
                                                    {
                                                        if (TaskVision.frmMVCGenTLCamera.Visible)
                                                        {
                                                            TaskVision.frmMVCGenTLCamera.SelectCamera(0);
                                                            if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[0].StartGrab();
                                                        }
                                                    }));
                                                }

                                                frmVisionFailMsg2 frmV = new frmVisionFailMsg2();
                                                string msg = "Point 2 Fail";
                                                Log.AddToLog(ActiveLine.Cmd.ToString() + " Fail Unit No " + RunTime.UIndex.ToString() + " " + msg);
                                                frmV.Message = msg;
                                                DialogResult dr = frmV.ShowDialog();

                                                switch (dr)
                                                {
                                                    #region
                                                    case DialogResult.Retry:
                                                        Log.AddToLog("0" + (char)9 + "Retry");
                                                        DefineSafety.DoorLock = true;
                                                        Thread.Sleep(100);
                                                        goto _RetryRef1;
                                                    case DialogResult.Cancel://Skip
                                                        Log.AddToLog("0" + (char)9 + "Skip");
                                                        OK2 = false;
                                                        DefineSafety.DoorLock = true;
                                                        Thread.Sleep(100);
                                                        break;
                                                    case DialogResult.OK://Manual Adjust
                                                        Log.AddToLog("0" + (char)9 + "Manual");
                                                        frm_DispProg_View frm = new frm_DispProg_View();

                                                        if (frm.ShowDialog() == DialogResult.OK)
                                                        {
                                                            v_ox2_mm = TaskGantry.GXPos() - dx2;
                                                            v_oy2_mm = TaskGantry.GYPos() - dy2;
                                                            Log.AddToLog("0" + (char)9 + v_ox2_mm.ToString("f3") + "," + v_oy2_mm.ToString("f3"));
                                                            OK2 = true;
                                                        }
                                                        else goto default;
                                                        DefineSafety.DoorLock = true;
                                                        Thread.Sleep(100);
                                                        break;
                                                    default://Stop
                                                        Log.AddToLog("0" + (char)9 + "Stop");
                                                        for (int L = Line; L >= 0; L--)
                                                        {
                                                            if (CmdList.Line[L].Cmd == ECmd.FOR_LAYOUT)
                                                            {
                                                                LastLine = L;
                                                                break;
                                                            }
                                                        }
                                                        Thread.Sleep(100);
                                                        goto _Pause;
                                                        #endregion
                                                }

                                                if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2)
                                                {
                                                    Application.OpenForms[0].Invoke(new Action(() =>
                                                    {
                                                        TaskVision.frmCamera.SelectCamera(0);
                                                        TaskVision.frmCamera.Grab();
                                                    }));
                                                }
                                                if (GDefine.CameraType[0] == GDefine.ECameraType.MVCGenTL)
                                                {
                                                    Application.OpenForms[0].Invoke(new Action(() =>
                                                    {
                                                        if (TaskVision.frmMVCGenTLCamera.Visible)
                                                        {
                                                            TaskVision.frmMVCGenTLCamera.SelectCamera(0);
                                                            if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[0].StartGrab();
                                                        }
                                                    }));
                                                }
                                            }
                                            #endregion
                                        }
                                        else
                                            i_DoRefSkipCntr = 0;

                                        #region compute pt1 and pt2 distance
                                        {
                                            Polar Ori = new Polar(OriPt1, OriPt2);
                                            Polar New = new Polar(NewPt1, NewPt2);
                                            double Diff = Math.Abs(Ori.R - New.R);
                                            if (ActiveLine.DPara[3] > 0)
                                            {
                                                bool OKD = Diff <= ActiveLine.DPara[3];
                                                OK2 = OK2 && OKD;

                                                if (!OKD)
                                                {
                                                    Msg MsgBox = new Msg();
                                                    EMsgRes MsgRes = MsgBox.Show(ErrCode.DO_REF_PT1_PT2_DIST_OOS, EMcState.Warning, EMsgBtn.smbOK_Stop, false);
                                                    if (MsgRes == EMsgRes.smrStop)
                                                    {
                                                        goto _Pause;
                                                    }
                                                }
                                            }
                                        }
                                        #endregion

                                        #region assign ref data
                                        RefData.Angle = Angle_Rad;
                                        RefData.OK = OK1 && OK2;
                                        #endregion
                                    }

                                _RefEnd:

                                    #region Write Vision Data
                                    string s_VisionData = "";
                                    if (CmdList.Line[Line].IPara[0] == 2)
                                    {
                                        s_VisionData = s_VisionData + "OX, OY, OA, AmpScore, Result" + (char)9 +
                                            v_ox1_mm.ToString("f3") + (char)9 +
                                            v_oy1_mm.ToString("f3") + (char)9 +
                                            (RefData.Angle * 180 / Math.PI).ToString("f3") + (char)9 +
                                            ampScore.ToString("f3") + (char)9 +
                                            RefData.OK.ToString();
                                    }
                                    else
                                    {
                                        s_VisionData = s_VisionData + "OX, OY, AmpScore, Result" + (char)9 +
                                            v_ox1_mm.ToString("f3") + (char)9 +
                                            v_oy1_mm.ToString("f3") + (char)9 +
                                            ampScore2.ToString("f3") + (char)9 +
                                            OK1.ToString();
                                    }
                                    Log.Vision.WriteByMonthDay("UnitNo " + (char)9 + RunTime.UIndex.ToString() + (char)9 + s_VisionData);
                                    #endregion

                                    if (!b_InLoop)//***update all layout if ref is done outside loop
                                    {
                                        #region
                                        for (int ID = 0; ID < rt_LayoutCount; ID++)
                                        {
                                            for (int i = 0; i < rt_Layouts[ID].TUCount; i++)
                                            {
                                                rt_RefDatas[RefID].Data[i].Copy(RefData);// rt_RefData[RefID, i].Copy(RefData);
                                                if (Map.CurrMap[ID].Bin[i] < EMapBin.BinNG)
                                                {
                                                    if (rt_RefDatas[RefID].Data[i].OK)//if (rt_RefData[RefID, i].OK)
                                                        Map.CurrMap[ID].Bin[i] = EMapBin.RefOK;
                                                    else
                                                        Map.CurrMap[ID].Bin[i] = EMapBin.RefNG;
                                                }
                                            }
                                        }
                                        #endregion
                                    }
                                    else
                                        switch ((EAlignType)ActiveLine.IPara[2])
                                        {
                                            #region Update Unit RefData
                                            case EAlignType.Board:
                                            default:
                                                #region
                                                {
                                                    if (ActiveLine.IPara[7] > 0)//update all layout; eg for net dispense
                                                    {
                                                        for (int ID = rt_LayoutID; ID < rt_LayoutCount; ID++)
                                                        {
                                                            for (int i = 0; i < rt_Layouts[ID].TUCount; i++)
                                                            {
                                                                rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                                if (Map.CurrMap[ID].Bin[i] < EMapBin.BinNG)
                                                                {
                                                                    if (rt_RefDatas[RefID].Data[i].OK)
                                                                        Map.CurrMap[ID].Bin[i] = EMapBin.RefOK;
                                                                    else
                                                                        Map.CurrMap[ID].Bin[i] = EMapBin.RefNG;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else
                                                    {
                                                        for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                        {
                                                            rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                            if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                            {
                                                                if (rt_RefDatas[RefID].Data[i].OK)
                                                                    Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                                else
                                                                    Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.Clstr:
                                                #region
                                                {
                                                    if (ActiveLine.IPara[7] > 0)//update all layout; eg for net dispense
                                                    {
                                                        for (int ID = rt_LayoutID; ID < rt_LayoutCount; ID++)
                                                        {
                                                            for (int i = 0; i < rt_Layouts[ID].TUCount; i++)
                                                            {
                                                                int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                                rt_Layouts[ID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                                if (i_CColNo == CColNo && i_CRowNo == CRowNo)
                                                                {
                                                                    rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                                    if (Map.CurrMap[ID].Bin[i] < EMapBin.BinNG)
                                                                    {
                                                                        if (rt_RefDatas[RefID].Data[i].OK)
                                                                            Map.CurrMap[ID].Bin[i] = EMapBin.RefOK;
                                                                        else
                                                                            Map.CurrMap[ID].Bin[i] = EMapBin.RefNG;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else
                                                    {
                                                        for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                        {
                                                            int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                            rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                            if (i_CColNo == CColNo && i_CRowNo == CRowNo)
                                                            {
                                                                rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                                if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                                {
                                                                    if (rt_RefDatas[RefID].Data[i].OK)
                                                                        Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                                    else
                                                                        Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.ClstrCol:
                                                #region
                                                {
                                                    for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                    {
                                                        int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                        rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                        if (i_CColNo == CColNo)
                                                        {
                                                            rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                            if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                            {
                                                                if (rt_RefDatas[RefID].Data[i].OK)
                                                                    Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                                else
                                                                    Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.ClstrRow:
                                                #region
                                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                {
                                                    int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                    if (i_CRowNo == CRowNo)// && i_UColNo == UColNo && i_URowNo == URowNo)
                                                    {
                                                        rt_RefDatas[RefID].Data[i].Copy(RefData);// rt_RefData[RefID, i].Copy(RefData);
                                                        if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                        {
                                                            if (rt_RefDatas[RefID].Data[i].OK)//if (rt_RefData[RefID, i].OK)
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                            else
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.Unit:
                                                #region
                                                {
                                                    int i = RunTime.UIndex;
                                                    rt_RefDatas[RefID].Data[i].Copy(RefData);// rt_RefData[RefID, i].Copy(RefData);
                                                    if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                    {
                                                        if (rt_RefDatas[RefID].Data[i].OK)//if (rt_RefData[RefID, i].OK)
                                                            Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                        else
                                                            Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.UnitCol:
                                                #region
                                                //if (RowNo == 0)
                                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                {
                                                    int i_ColNo = 0; int i_RowNo = 0;
                                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);

                                                    if (i_ColNo == ColNo)
                                                    {
                                                        rt_RefDatas[RefID].Data[i].Copy(RefData);// rt_RefData[RefID, i].Copy(RefData);
                                                        if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                        {
                                                            if (rt_RefDatas[RefID].Data[i].OK)//if (rt_RefData[RefID, i].OK)
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                            else
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.UnitRow:
                                                #region
                                                //if (ColNo == 0)
                                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                {
                                                    int i_ColNo = 0; int i_RowNo = 0;
                                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);

                                                    if (i_RowNo == RowNo)
                                                    {
                                                        rt_RefDatas[RefID].Data[i].Copy(RefData);// rt_RefData[RefID, i].Copy(RefData);
                                                        if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                        {
                                                            if (rt_RefDatas[RefID].Data[i].OK)//if (rt_RefData[RefID, i].OK)
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK;
                                                            else
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG;
                                                        }
                                                    }
                                                }
                                                break;
                                                #endregion
                                                #endregion
                                        }
                                    _End:
                                    break;
                                }
                            case ECmd.USE_VISION:
                            case ECmd.USE_REF:
                                {
                                    EMsg = Msg + CmdList.Line[Line].Cmd.ToString();
                                    int RefID = CmdList.Line[Line].ID;

                                    //rt_RefID = RefID;
                                    rt_Head1RefData = rt_RefDatas[RefID].Data[RunTime.UIndex];
                                    rt_Head2RefData = rt_RefDatas[RefID].Data[RunTime.UIndex];
                                    if (rt_SyncHead2)
                                    {
                                        int Head2UnitNo = 0;
                                        bool IsValid = true;
                                        if (rt_Layouts[rt_LayoutID].UnitNoGetHead2UnitNo(RunTime.UIndex, ref Head2UnitNo, ref IsValid))
                                            rt_Head2RefData = rt_RefDatas[RefID].Data[Head2UnitNo];
                                    }
                                    break;
                                }
                            case ECmd.DO_REF_CHECK:
                            case ECmd.DO_VISION_CHECK:
                                #region
                                {
                                    EMsg = Msg + ActiveLine.Cmd.ToString();
                                    int RefID = ActiveLine.ID;

                                    if (!b_InLoop && !Running) goto _Pause;
                                    if (b_SecondHalf || b_IsNeedle2) break;

                                    TConditions Conds = new TConditions(Line, ActiveLine);
                                    if (!Conds.IsTrue) break;
                                    ExecutedLines.Add(Line);

                                    TLine line = null;
                                    switch (ActiveLine.Cmd)
                                    {
                                        case ECmd.DO_REF_CHECK:
                                            line = PrevLine(Line, ECmd.DO_REF);
                                            break;
                                        case ECmd.DO_VISION_CHECK:
                                            line = PrevLine(Line, ECmd.DO_VISION);
                                            break;
                                    }
                                    if (line == null) throw new Exception(ActiveLine.Cmd.ToString() + " not found.");
                                    if (line.IPara[2] != (int)EAlignType.Unit) throw new Exception(ActiveLine.Cmd.ToString() + " not of unit type.");

                                    #region Get current unit info
                                    int CColNo = 0; int CRowNo = 0; int UColNo = 0; int URowNo = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref UColNo, ref URowNo, ref CColNo, ref CRowNo);
                                    int ColNo = 0; int RowNo = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref ColNo, ref RowNo);
                                    #endregion

                                    TRefData RefData = new TRefData();
                                    double d_Ref_Rel_X = rt_Layout_Rel_X;
                                    double d_Ref_Rel_Y = rt_Layout_Rel_Y;

                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                    {
                                        if (rt_Head2MapBin >= EMapBin.BinNG) goto _End;
                                    }
                                    else
                                        if (rt_Head1MapBin >= EMapBin.BinNG) goto _End;

                                    b_Flag_ConsecutiveUnit = false;

                                    TaskVision.LightingOn(TaskVision.LightRGB[RefID]);

                                    #region assign position and check
                                    double dx1 = f_origin_x + d_Ref_Rel_X + line.X[0];
                                    double dy1 = f_origin_y + d_Ref_Rel_Y + line.Y[0];
                                    //if (ActiveLine.ID > 0)
                                    TranslatePos(dx1, dy1, rt_Head1RefData, ref dx1, ref dy1);

                                _Retry:
                                    double v_ox1 = 0;
                                    double v_oy1 = 0;
                                    double v_s1 = 0;
                                    bool OK = false;

                                    switch (ActiveLine.Cmd)
                                    {
                                        case ECmd.DO_REF_CHECK:
                                            Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> gray_FoundDoRef1 = null;
                                            if (!DoRefCheck(line, dx1, dy1, RefID, (int)EVisionRef.No1, out v_ox1, out v_oy1, out v_s1, ref gray_FoundDoRef1)) goto _Error;
                                            OK = true;
                                            break;

                                        case ECmd.DO_VISION_CHECK:
                                            #region Move and settle
                                            if (!TaskDisp.TaskMoveGZFocus(line.IPara[21])) goto _Error;
                                            double StartV = line.DPara[10]; if (StartV == 0) StartV = TaskGantry.GXAxis.Para.StartV;
                                            double DriveV = line.DPara[11]; if (DriveV == 0) DriveV = TaskGantry.GXAxis.Para.FastV;
                                            double Accel = line.DPara[12]; if (Accel == 0) Accel = TaskGantry.GXAxis.Para.Accel;
                                            if (!TaskGantry.SetMotionParamGXY(StartV, DriveV, Accel)) goto _Error;

                                            if (!TaskGantry.MoveAbsGXY(dx1, dy1, true)) return false;

                                            //settle time
                                            int SettleTime = ActiveLine.IPara[4];
                                            int t = GDefine.GetTickCount() + SettleTime;
                                            while (GDefine.GetTickCount() <= t) { Thread.Sleep(1); }
                                            #endregion

                                            Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> Image = null;
                                            string data = "";
                                            double oa = 0;
                                            TaskVision.ExecVision((int)EVisionRef.No1, line.ID, ref v_ox1, ref v_oy1, ref oa, ref v_s1, ref OK, ref data, ref Image);
                                            Image.Dispose();

                                            if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2)
                                            {
                                                Application.OpenForms[0].Invoke(new Action(() =>
                                                {
                                                    TaskVision.frmCamera.SelectCamera(0);
                                                    TaskVision.frmCamera.Grab();
                                                }));
                                            }
                                            if (GDefine.CameraType[0] == GDefine.ECameraType.MVCGenTL)
                                            {
                                                Application.OpenForms[0].Invoke(new Action(() =>
                                                {
                                                    if (TaskVision.frmMVCGenTLCamera.Visible)
                                                    {
                                                        TaskVision.frmMVCGenTLCamera.SelectCamera(0);
                                                        if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[0].StartGrab();
                                                    }
                                                }));
                                            }
                                            break;
                                    }

                                    if (Math.Abs(v_ox1) > ActiveLine.DPara[1]) OK = false;
                                    if (Math.Abs(v_oy1) > ActiveLine.DPara[1]) OK = false;
                                    if (Math.Abs(v_s1) < ActiveLine.DPara[0]) OK = false;
                                    Log.Vision.WriteByMonthDay($"UnitNo\t{RunTime.UIndex} \tOX, OY, S, Result\t{v_ox1:f3}, {v_oy1:f3}, {v_s1:f2}, \t " + ActiveLine.Cmd.ToString() + " " + (OK ? "OK" : "NG"));

                                    if (!OK)
                                    {
                                        #region
                                        DefineSafety.DoorLock = false;

                                        frmVisionFailMsg2 frmV = new frmVisionFailMsg2();
                                        frmV.ShowAccept = true;
                                        frmV.ShowSkip = true;
                                        frmV.ShowManual = false;

                                        frmV.Message = ActiveLine.Cmd.ToString() + '\n' +
                                            $"Detected XY: {v_ox1:f3},{v_oy1:f3},S: {v_s1:f3}" + '\n' +
                                            $"Spec XY: {ActiveLine.DPara[1]},{ActiveLine.DPara[1]},S: {ActiveLine.DPara[0]}";

                                        DialogResult dr = frmV.ShowDialog();

                                        if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2)
                                        {
                                            Application.OpenForms[0].Invoke(new Action(() =>
                                            {
                                                TaskVision.frmCamera.SelectCamera(0);
                                                TaskVision.frmCamera.Grab();
                                            }));
                                        }
                                        if (GDefine.CameraType[0] == GDefine.ECameraType.MVCGenTL)
                                        {
                                            Application.OpenForms[0].Invoke(new Action(() =>
                                            {
                                                if (TaskVision.frmMVCGenTLCamera.Visible)
                                                {
                                                    TaskVision.frmMVCGenTLCamera.SelectCamera(0);
                                                    if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[0].StartGrab();
                                                }
                                            }));
                                        }

                                        switch (dr)
                                        {
                                            #region
                                            case DialogResult.Retry://Retry Button
                                                Log.Vision.WriteByMonthDay($"UnitNo\tRetry");
                                                DefineSafety.DoorLock = true;
                                                Thread.Sleep(100);
                                                goto _Retry;
                                            case DialogResult.Cancel://Skip Button
                                                Log.Vision.WriteByMonthDay($"UnitNo\tSkip");
                                                OK = false;
                                                DefineSafety.DoorLock = true;
                                                Thread.Sleep(100);
                                                break;
                                            case DialogResult.Yes://Accept Button
                                                Log.Vision.WriteByMonthDay($"UnitNo\tAccept");
                                                OK = true;
                                                DefineSafety.DoorLock = true;
                                                Thread.Sleep(100);
                                                break;
                                            case DialogResult.Abort://Stop Button
                                                Log.Vision.WriteByMonthDay($"UnitNo\tStop");
                                                LastLine++;
                                                DefineSafety.DoorLock = true;
                                                Thread.Sleep(100);
                                                goto _Pause;
                                            default:
                                                Log.Vision.WriteByMonthDay($"UnitNo\tDefault");
                                                for (int L = Line; L >= 0; L--)
                                                {
                                                    if (CmdList.Line[L].Cmd == ECmd.FOR_LAYOUT)
                                                    {
                                                        LastLine = L;
                                                        break;
                                                    }
                                                }
                                                Thread.Sleep(100);
                                                goto _Pause;
                                                #endregion
                                        }
                                        #endregion
                                    }
                                #endregion
                                _End:
                                    break;
                                }
                            #endregion
                            case ECmd.DO_VISION:
                                #region
                                {
                                    EMsg = Msg + Enum.GetName(typeof(ECmd), ECmd.DO_VISION);
                                    int RefID = ActiveLine.ID;

                                    #region Get current unit info
                                    int CColNo = 0; int CRowNo = 0; int UColNo = 0; int URowNo = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref UColNo, ref URowNo, ref CColNo, ref CRowNo);
                                    int ColNo = 0; int RowNo = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref ColNo, ref RowNo);
                                    #endregion

                                    TRefData RefData = new TRefData();
                                    double d_Ref_Rel_X = rt_Layout_Rel_X;
                                    double d_Ref_Rel_Y = rt_Layout_Rel_Y;

                                    if (rt_RefDatas[RefID].Data[RunTime.UIndex].Ready) goto _End;

                                    b_Flag_ConsecutiveUnit = false;

                                    switch ((EAlignType)ActiveLine.IPara[2])
                                    {
                                        #region Manage Align Type
                                        case EAlignType.Board:
                                        default:
                                            #region
                                            d_Ref_Rel_X = rt_LayoutRelPos[0].X;
                                            d_Ref_Rel_Y = rt_LayoutRelPos[0].Y;
                                            break;
                                        #endregion
                                        case EAlignType.Clstr:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                if (i_CColNo == CColNo && i_CRowNo == CRowNo && i_UColNo == 0 && i_URowNo == 0)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.ClstrCol:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                if (i_CColNo == CColNo && i_CRowNo == 0 && i_UColNo == 0 && i_URowNo == 0)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.ClstrRow:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                if (i_CColNo == 0 && i_CRowNo == CRowNo && i_UColNo == 0 && i_URowNo == 0)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.Unit:
                                            #region
                                            if (rt_Head1MapBin >= EMapBin.BinNG) goto _End;
                                            break;
                                        #endregion
                                        case EAlignType.UnitCol:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_ColNo = 0; int i_RowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);

                                                if (i_ColNo == ColNo && i_RowNo == 0)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.UnitRow:
                                            #region
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_ColNo = 0; int i_RowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);

                                                if (i_ColNo == 0 && i_RowNo == RowNo)
                                                {
                                                    d_Ref_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Ref_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                            #endregion
                                            #endregion
                                    }

                                    #region assign position and do vision
                                    double dx = f_origin_x + d_Ref_Rel_X + ActiveLine.X[0];
                                    double dy = f_origin_y + d_Ref_Rel_Y + ActiveLine.Y[0];

                                    double odx = dx;
                                    double ody = dy;

                                    if (ActiveLine.ID > 0)
                                        TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);

                                    _RetryRef1:
                                    TaskVision.LightingOn(TaskVision.LightRGB[RefID]);

                                    int ta1 = GDefine.GetTickCount();

                                    #region Move and settle
                                    if (!TaskDisp.TaskMoveGZFocus(ActiveLine.IPara[21])) goto _Error;

                                    double StartV = ActiveLine.DPara[10]; if (StartV == 0) StartV = TaskGantry.GXAxis.Para.StartV;
                                    double DriveV = ActiveLine.DPara[11]; if (DriveV == 0) DriveV = TaskGantry.GXAxis.Para.FastV;
                                    double Accel = ActiveLine.DPara[12]; if (Accel == 0) Accel = TaskGantry.GXAxis.Para.Accel;
                                    if (!TaskGantry.SetMotionParamGXY(StartV, DriveV, Accel)) goto _Error;

                                    TPos2 GXYPos = new TPos2();
                                    GXYPos.X = dx;
                                    GXYPos.Y = dy;
                                    TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                                    GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + TaskDisp.Head2_DefDistX;

                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                    {
                                        if (!TaskGantry.SetMotionParamGX2Y2()) return false;
                                        if (!TaskGantry.MoveAbsGX2Y2(GX2Y2.X, GX2Y2.Y, true)) return false;
                                    }
                                    if (!TaskGantry.MoveAbsGXY(GXYPos.X, GXYPos.Y, true)) return false;

                                    //settle time
                                    int SettleTime = ActiveLine.IPara[4];
                                    int t = GDefine.GetTickCount() + SettleTime;
                                    while (GDefine.GetTickCount() <= t) { Thread.Sleep(1); }
                                    #endregion

                                    int ta2 = GDefine.GetTickCount();

                                    double v_ox = 0;
                                    double v_oy = 0;
                                    double v_oa = 0;
                                    double v_s = 0;
                                    bool v_OK = false;

                                    Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> Image = null;
                                    string data = "";
                                    TaskVision.ExecVision((int)EVisionRef.No1, ActiveLine.ID, ref v_ox, ref v_oy, ref v_oa, ref v_s, ref v_OK, ref data, ref Image);

                                    if (SaveDoVisionImages)
                                    {
                                        string Dir = ImageLocation + @"\" + GDefine.ProgRecipeName;
                                        if (!Directory.Exists(Dir))
                                            try
                                            {
                                                Directory.CreateDirectory(Dir);
                                            }
                                            catch
                                            {
                                                throw new Exception(EMsg + ", SaveImage");
                                            }
                                        Image.Save(Dir + @"\" + "C" + ColNo.ToString() + "_R" + RowNo.ToString() + ".jpg");

                                        string s_InfoFile = Dir + @"\" + "Info.txt";
                                        if (!File.Exists(s_InfoFile))
                                        {
                                            NUtils.IniFile IniFile = new NUtils.IniFile(s_InfoFile);

                                            IniFile.WriteString("Program", "Name", GDefine.ProgRecipeName);
                                            IniFile.WriteString("Info", "DateTime", DateTime.Now.ToString());
                                            IniFile.WriteDouble("Vision", "DistPerPixelX_0", TaskVision.DistPerPixelX[0]);
                                            IniFile.WriteDouble("Vision", "DistPerPixelY_0", TaskVision.DistPerPixelY[0]);
                                        }
                                    }
                                    Image.Dispose();

                                    bool OK = v_OK;

                                    if (Math.Abs(v_ox) > ActiveLine.DPara[1] || Math.Abs(v_oy) > ActiveLine.DPara[1]) OK = false;

                                    Log.Vision.WriteByMonthDay("DoVision, UnitNo," + RunTime.UIndex.ToString() + ",C," + ColNo.ToString() + ",R," + RowNo.ToString() + "," + data);

                                    if (!OK)
                                    {
                                        #region
                                        i_DoRefSkipCntr++;
                                        EFailAction FailAction = (EFailAction)ActiveLine.IPara[6];
                                        int SkipCount = CmdList.Line[Line].IPara[5];
                                        if (i_DoRefSkipCntr > SkipCount)
                                        {
                                            i_DoRefSkipCntr = 0;
                                            #region
                                            if (FailAction == EFailAction.AutoReject)
                                            {
                                                BdStatus = EBoardStatus.Reject;
                                                goto _EndBoard;
                                            }

                                            DefineSafety.DoorLock = false;

                                            frmVisionFailMsg2 frmV = new frmVisionFailMsg2();
                                            string msg = "";
                                            if (Math.Abs(v_ox) > ActiveLine.DPara[1] || Math.Abs(v_oy) > ActiveLine.DPara[1])
                                                msg = "Unit Offset exceed XY Tolerance.";
                                            Log.AddToLog("0" + (char)9 + "DoVision Fail Unit No " + RunTime.UIndex.ToString() + " " + msg);
                                            frmV.Message = msg;
                                            DialogResult dr = frmV.ShowDialog();

                                            if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2)
                                            {
                                                Application.OpenForms[0].Invoke(new Action(() =>
                                                {
                                                    TaskVision.frmCamera.SelectCamera(0);
                                                    TaskVision.frmCamera.Grab();
                                                }));
                                            }
                                            if (GDefine.CameraType[0] == GDefine.ECameraType.MVCGenTL)
                                            {
                                                Application.OpenForms[0].Invoke(new Action(() =>
                                                {
                                                    if (TaskVision.frmMVCGenTLCamera.Visible)
                                                    {
                                                        TaskVision.frmMVCGenTLCamera.SelectCamera(0);
                                                        if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[0].StartGrab();
                                                    }
                                                }));
                                            }

                                            switch (dr)
                                            {
                                                #region
                                                case DialogResult.Retry:
                                                    Log.AddToLog("0" + (char)9 + "Retry");
                                                    DefineSafety.DoorLock = true;
                                                    Thread.Sleep(100);
                                                    goto _RetryRef1;
                                                case DialogResult.Cancel://Skip
                                                    Log.AddToLog("0" + (char)9 + "Skip");
                                                    OK = false;
                                                    DefineSafety.DoorLock = true;
                                                    Thread.Sleep(100);
                                                    break;
                                                case DialogResult.OK://Manual Adjust
                                                    Log.AddToLog("0" + (char)9 + "Manual");
                                                    frm_DispProg_View frm = new frm_DispProg_View();

                                                    if (frm.ShowDialog() == DialogResult.OK)
                                                    {
                                                        v_ox = TaskGantry.GXPos() - dx;
                                                        v_oy = TaskGantry.GYPos() - dy;
                                                        Log.AddToLog("0" + (char)9 + v_ox.ToString("f3") + "," + v_oy.ToString("f3"));
                                                        OK = true;
                                                    }
                                                    else goto default;
                                                    DefineSafety.DoorLock = true;
                                                    Thread.Sleep(100);
                                                    break;
                                                default://Stop
                                                    Log.AddToLog("0" + (char)9 + "Stop");
                                                    for (int L = Line; L >= 0; L--)
                                                    {
                                                        if (CmdList.Line[L].Cmd == ECmd.FOR_LAYOUT)
                                                        {
                                                            LastLine = L;
                                                            break;
                                                        }
                                                    }
                                                    Thread.Sleep(100);
                                                    goto _Pause;
                                                    #endregion
                                            }
                                            #endregion
                                        }
                                        #endregion
                                    }
                                    else
                                    {
                                        if (CmdList.Line[Line].IPara[0] != 2) i_DoRefSkipCntr = 0;

                                        if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2)
                                        {
                                            Application.OpenForms[0].Invoke(new Action(() =>
                                            {
                                                TaskVision.frmCamera.SelectCamera(0);
                                                TaskVision.frmCamera.Grab();
                                            }));
                                        }
                                        if (GDefine.CameraType[0] == GDefine.ECameraType.MVCGenTL)
                                        {
                                            Application.OpenForms[0].Invoke(new Action(() =>
                                            {
                                                if (TaskVision.frmMVCGenTLCamera.Visible)
                                                {
                                                    TaskVision.frmMVCGenTLCamera.SelectCamera(0);
                                                    if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[0].StartGrab();
                                                }
                                            }));
                                        }
                                    }

                                    double ndx = dx + v_ox;
                                    double ndy = dy + v_oy;
                                    #endregion

                                    #region assign ref data
                                    RefData.Ready = true;
                                    RefData.DatumX = odx;
                                    RefData.DatumY = ody;
                                    RefData.NewDatumX = ndx;
                                    RefData.NewDatumY = ndy;
                                    RefData.Angle = v_oa * Math.PI / 180;
                                    RefData.OK = OK;
                                    #endregion

                                    if (!b_InLoop)//***update all layout if ref is done outside loop
                                    {
                                        #region
                                        for (int ID = 0; ID < rt_LayoutCount; ID++)
                                        {
                                            for (int i = 0; i < rt_Layouts[ID].TUCount; i++)
                                            {
                                                rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                if (Map.CurrMap[ID].Bin[i] < EMapBin.BinNG)
                                                {
                                                    if (rt_RefDatas[RefID].Data[i].OK)
                                                        Map.CurrMap[ID].Bin[i] = EMapBin.RefOK2;
                                                    else
                                                        Map.CurrMap[ID].Bin[i] = EMapBin.RefNG2;
                                                }
                                            }
                                        }
                                        #endregion
                                    }
                                    else
                                        switch ((EAlignType)ActiveLine.IPara[2])
                                        {
                                            #region Update Unit RefData
                                            case EAlignType.Board:
                                            default:
                                                #region
                                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                {
                                                    rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                    if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                    {
                                                        if (rt_RefDatas[RefID].Data[i].OK)
                                                            Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK2;
                                                        else
                                                            Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG2;
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.Clstr:
                                                #region
                                                //if (UColNo == 0 && URowNo == 0)
                                                {
                                                    for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                    {
                                                        int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                        rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                        if (i_CColNo == CColNo && i_CRowNo == CRowNo)
                                                        {
                                                            rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                            if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                            {
                                                                if (rt_RefDatas[RefID].Data[i].OK)
                                                                    Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK2;
                                                                else
                                                                    Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG2;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.ClstrCol:
                                                #region
                                                //if (CRowNo == 0 && UColNo == 0 && URowNo == 0)
                                                {
                                                    for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                    {
                                                        int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                        rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                        if (i_CColNo == CColNo)
                                                        {
                                                            rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                            if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                            {
                                                                if (rt_RefDatas[RefID].Data[i].OK)
                                                                    Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK2;
                                                                else
                                                                    Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG2;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.ClstrRow:
                                                #region
                                                //if (CColNo == 0 && UColNo == 0 && URowNo == 0)
                                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                {
                                                    int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                    if (i_CRowNo == CRowNo)
                                                    {
                                                        rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                        if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                        {
                                                            if (rt_RefDatas[RefID].Data[i].OK)
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK2;
                                                            else
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG2;
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.Unit:
                                                #region
                                                {
                                                    int i = RunTime.UIndex;
                                                    rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                    if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                    {
                                                        if (rt_RefDatas[RefID].Data[i].OK)
                                                            Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK2;
                                                        else
                                                            Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG2;
                                                    }
                                                    break;
                                                }
                                            #endregion
                                            case EAlignType.UnitCol:
                                                #region
                                                //if (RowNo == 0)
                                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                {
                                                    int i_ColNo = 0; int i_RowNo = 0;
                                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);

                                                    if (i_ColNo == ColNo)
                                                    {
                                                        rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                        if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                        {
                                                            if (rt_RefDatas[RefID].Data[i].OK)
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK2;
                                                            else
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG2;
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.UnitRow:
                                                #region
                                                //if (ColNo == 0)
                                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                {
                                                    int i_ColNo = 0; int i_RowNo = 0;
                                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);

                                                    if (i_RowNo == RowNo)
                                                    {
                                                        rt_RefDatas[RefID].Data[i].Copy(RefData);
                                                        if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                        {
                                                            if (rt_RefDatas[RefID].Data[i].OK)
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefOK2;
                                                            else
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.RefNG2;
                                                        }
                                                    }
                                                }
                                                break;
                                                #endregion
                                                #endregion
                                        }

                                    int ta4 = GDefine.GetTickCount();
                                _End:
                                    break;

                                }
                            #endregion

                            #region DO_BDORIENT
                            case ECmd.DO_BDORIENT:
                                {
                                    EMsg = Msg + " DO_BDORIENT";

                                    b_Flag_ConsecutiveUnit = false;

                                    TaskVision.LightingOn(TaskVision.BdOrientLightRGB);

                                    #region assign position
                                    double dx = f_origin_x + ActiveLine.X[0];
                                    double dy = f_origin_y + ActiveLine.Y[0];
                                #endregion

                                _Retry:
                                    double ox = 0;
                                    double oy = 0;
                                    double s = 0;
                                    Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> FoundOrient = null;
                                    if (!DoBdOrient(ActiveLine, dx, dy, out ox, out oy, out s, ref FoundOrient)) goto _Error;

                                    double v_ox = ox * TaskVision.DistPerPixelX[ActiveLine.IPara[1]];
                                    double v_oy = oy * TaskVision.DistPerPixelY[ActiveLine.IPara[1]];
                                    double v_s = s;
                                    bool OK = (Math.Abs(v_ox) <= ActiveLine.DPara[1]) && (Math.Abs(v_oy) <= ActiveLine.DPara[1]) && (Math.Abs(v_s) >= ActiveLine.DPara[0]);
                                    if (ActiveLine.IPara[0] > 0) OK = !OK;

                                    if (!OK)
                                    {
                                        #region
                                        EFailAction FailAction = (EFailAction)ActiveLine.IPara[6];
                                        if (FailAction == EFailAction.AutoReject)
                                        {
                                            BdStatus = EBoardStatus.Reject;
                                            goto _EndBoard;
                                        }

                                        DefineSafety.DoorLock = false;
                                        frm_DispCore_VisionFailMsg frm = new frm_DispCore_VisionFailMsg();
                                        frm.ShowSkipButton = ActiveLine.IPara[11] > 0;
                                        DialogResult dr = frm.ShowDialog(FailAction,
                                            TaskVision.BdOrientTemplate.Image.ToBitmap(),
                                            FoundOrient.ToBitmap(),
                                            v_s, v_ox, v_oy, 0,
                                            CmdList.Line[Line].DPara[0], CmdList.Line[Line].DPara[1], 0);
                                        switch (dr)
                                        {
                                            case DialogResult.Retry:
                                                DefineSafety.DoorLock = true;
                                                goto _Retry;
                                            case DialogResult.Ignore://Skip
                                                BdStatus = EBoardStatus.Reject;
                                                DefineSafety.DoorLock = true;
                                                goto _EndBoard;
                                            case DialogResult.OK://Manual
                                                v_ox = TaskGantry.GXPos() - dx;
                                                v_oy = TaskGantry.GYPos() - dy;
                                                DefineSafety.DoorLock = true;
                                                break;
                                            case DialogResult.Yes://Accept
                                                DefineSafety.DoorLock = true;
                                                break;
                                            case DialogResult.Cancel://Reject
                                                BdStatus = EBoardStatus.Reject;
                                                DefineSafety.DoorLock = true;
                                                goto _EndBoard;
                                            default://DialogResult.Abort - Stop
                                                Line = Line--;
                                                BdStatus = EBoardStatus.Stop;
                                                GDefine.Status = EStatus.Stop;
                                                //Intf.DoorLock();
                                                goto _Pause;
                                        }
                                        #endregion
                                    }
                                    break;
                                }
                            #endregion
                            case ECmd.DO_BDCAPTURE:
                                #region
                                {
                                    EMsg = Msg + " DO_BDCAPTURE";

                                    b_Flag_ConsecutiveUnit = false;

                                    TaskVision.LightingOn(TaskVision.BdCaptureLightRGB);

                                    #region assign and translate position
                                    double dx = f_origin_x + CmdList.Line[Line].X[0];
                                    double dy = f_origin_y + CmdList.Line[Line].Y[0];
                                    double dz = f_origin_z;
                                    TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);

                                    double dx2 = f_origin_x + CmdList.Line[Line].X[1];
                                    double dy2 = f_origin_y + CmdList.Line[Line].Y[1];
                                    TranslatePos(dx2, dy2, rt_Head1RefData, ref dx2, ref dy2);
                                    #endregion

                                    if (ActiveLine.IPara[3] == 0)
                                    {
                                        if (!DoBdCapture(ActiveLine, CmdList.Line[Line].ID, dx, dy, dx2, dy2))
                                        {
                                            Running = false;
                                        }
                                    }
                                    else //(ActiveLine.IPara[3] == 1) line scan
                                    {
                                        if (!DispProg.DoLineCapture(ActiveLine, dx, dy, dx2, dy2))
                                        {
                                            Running = false;
                                        }
                                        switch (GDefine.CameraType[0])
                                        {
                                            case GDefine.ECameraType.Spinnaker2:
                                                TaskVision.flirCamera2[CmdList.Line[Line].IPara[1]].GrabCont();
                                                break;
                                            case GDefine.ECameraType.MVCGenTL:
                                                if (TaskVision.frmMVCGenTLCamera.Visible)
                                                {
                                                    TaskVision.frmMVCGenTLCamera.SelectCamera(0);
                                                    if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[0].StartGrab();
                                                }
                                                break;
                                        }
                                    }
                                    break;
                                }
                            #endregion
                            #region DO_UNITMARK
                            case ECmd.DO_UNITMARK:
                                {
                                    EMsg = Msg + " DO_UNITMARK";

                                    if (rt_Head1MapBin >= EMapBin.BinNG) break;
                                    b_Flag_ConsecutiveUnit = false;

                                    TaskVision.LightingOn(TaskVision.UnitMarkLightRGB);

                                    #region assign and translate pt1
                                    double dx = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[0];
                                    double dy = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[0];
                                    double dz = f_origin_z;
                                    TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);
                                #endregion

                                _Retry:
                                    double ox = 0;
                                    double oy = 0;
                                    double s = 0;
                                    Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> FoundOrient = null;
                                    if (!DoUnitMark(ActiveLine, dx, dy, out ox, out oy, out s, ref FoundOrient)) goto _Error;

                                    double v_ox = ox * TaskVision.DistPerPixelX[ActiveLine.IPara[2]];
                                    double v_oy = oy * TaskVision.DistPerPixelY[ActiveLine.IPara[2]];
                                    double v_s = s;
                                    bool OK = (Math.Abs(v_ox) <= ActiveLine.DPara[1]) && (Math.Abs(v_oy) <= ActiveLine.DPara[1]) && (Math.Abs(v_s) >= ActiveLine.DPara[0]);
                                    if (ActiveLine.IPara[0] > 0) OK = !OK;

                                    int SkipCount = ActiveLine.IPara[5];
                                    if (OK)
                                    {
                                        i_UnitSkipCount = 0;
                                    }
                                    else
                                    {
                                        i_UnitSkipCount++;

                                        if (i_UnitSkipCount > SkipCount)// ActiveLine.IPara[1])
                                        {
                                            EFailAction FailAction = (EFailAction)ActiveLine.IPara[6];
                                            if (FailAction == EFailAction.AutoReject)
                                            {
                                                BdStatus = EBoardStatus.Reject;
                                                goto _EndBoard;
                                            }

                                            #region
                                            i_UnitSkipCount = 0;

                                            DefineSafety.DoorLock = false;
                                            frm_DispCore_VisionFailMsg frm = new frm_DispCore_VisionFailMsg();
                                            frm.ShowSkipButton = ActiveLine.IPara[11] > 0;
                                            DialogResult dr = frm.ShowDialog(FailAction,
                                                TaskVision.UnitMarkTemplate.Image.ToBitmap(),
                                                FoundOrient.ToBitmap(),
                                                v_s, v_ox, v_oy, 0,
                                                CmdList.Line[Line].DPara[0], CmdList.Line[Line].DPara[1], 0);
                                            switch (dr)
                                            {
                                                case DialogResult.Retry:
                                                    DefineSafety.DoorLock = true;
                                                    goto _Retry;
                                                case DialogResult.Ignore:
                                                    OK = false;
                                                    DefineSafety.DoorLock = true;
                                                    break;
                                                case DialogResult.OK:
                                                    OK = true;
                                                    DefineSafety.DoorLock = true;
                                                    break;
                                                case DialogResult.Yes:
                                                    OK = true;
                                                    DefineSafety.DoorLock = true;
                                                    break;
                                                default://DialogResult.Abort - Stop
                                                    Line = Line--;
                                                    BdStatus = EBoardStatus.Stop;
                                                    GDefine.Status = EStatus.Stop;
                                                    //Intf.DoorLock();
                                                    goto _Pause;
                                            }
                                            #endregion
                                        }

                                        if (b_InLoop)
                                        {
                                            if (OK)
                                                Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] = EMapBin.UnitMarkOK;
                                            else
                                                Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] = EMapBin.UnitMarkNG;
                                        }
                                    }
                                    break;
                                }
                            #endregion

                            case ECmd.DO_VIS_INSP:
                                {
                                    EMsg = Msg + " " + ((ECmd)CmdList.Line[Line].Cmd).ToString();

                                    if (!b_InLoop && !Running) goto _Pause;
                                    if (b_SecondHalf || b_IsNeedle2) break;

                                    TConditions Conds = new TConditions(Line, ActiveLine);
                                    if (!Conds.IsTrue) break;
                                    ExecutedLines.Add(Line);

                                    b_Flag_ConsecutiveUnit = false;

                                    //***Inspect Prior Unit: 0 = current, >0 number of units prior to inspect
                                    int index = RunTime.UIndex;
                                    int unitPrior = ActiveLine.IPara[7];
                                    //index = RunTime.UIndex - unitPrior;
                                    //***reverse search by numnber of complete units
                                    int count = 0;
                                    if (unitPrior > 0)
                                    {
                                        while (true)
                                        {
                                            index--;
                                            if (index < 0) break;
                                            if (Map.CurrMap[rt_LayoutID].Bin[index] == EMapBin.Complete) count++;
                                            if (count >= unitPrior) break;
                                        }
                                    }

                                    if (index < 0) break;

                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(index))
                                    {
                                        if (rt_Head2MapBin >= EMapBin.BinNG) goto _End;
                                    }
                                    else
                                      if (rt_Head1MapBin >= EMapBin.BinNG) goto _End;

                                    #region Get current unit info
                                    int CColNo = 0; int CRowNo = 0; int UColNo = 0; int URowNo = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(index, ref UColNo, ref URowNo, ref CColNo, ref CRowNo);
                                    int ColNo = 0; int RowNo = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(index, ref ColNo, ref RowNo);
                                    #endregion

                                    //double d_Ref_Rel_X = rt_Layout_Rel_X;
                                    //double d_Ref_Rel_Y = rt_Layout_Rel_Y;
                                    double d_Ref_Rel_X = rt_LayoutRelPos[index].X;
                                    double d_Ref_Rel_Y = rt_LayoutRelPos[index].Y;

                                    #region assign position and translate
                                    double dx = f_origin_x + d_Ref_Rel_X + ActiveLine.X[0];
                                    double dy = f_origin_y + d_Ref_Rel_Y + ActiveLine.Y[0];

                                    double odx = dx;
                                    double ody = dy;

                                    if (ActiveLine.ID > 0)
                                        TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);
                                    #endregion

                                    _Retry:
                                    int RefID = ActiveLine.ID;
                                    TaskVision.LightingOn(TaskVision.LightRGB[RefID]);

                                    #region Move and settle
                                    if (!TaskDisp.TaskMoveGZFocus(ActiveLine.IPara[21])) goto _Error;

                                    double StartV = ActiveLine.DPara[10]; if (StartV == 0) StartV = TaskGantry.GXAxis.Para.StartV;
                                    double DriveV = ActiveLine.DPara[11]; if (DriveV == 0) DriveV = TaskGantry.GXAxis.Para.FastV;
                                    double Accel = ActiveLine.DPara[12]; if (Accel == 0) Accel = TaskGantry.GXAxis.Para.Accel;
                                    if (!TaskGantry.SetMotionParamGXY(StartV, DriveV, Accel)) goto _Error;

                                    TPos2 GXYPos = new TPos2();
                                    GXYPos.X = dx;
                                    GXYPos.Y = dy;
                                    TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                                    GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + TaskDisp.Head2_DefDistX;

                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                    {
                                        if (!TaskGantry.SetMotionParamGX2Y2()) return false;
                                        if (!TaskGantry.MoveAbsGX2Y2(GX2Y2.X, GX2Y2.Y, true)) return false;
                                    }
                                    if (!TaskGantry.MoveAbsGXY(GXYPos.X, GXYPos.Y, true)) return false;

                                    //settle time
                                    int SettleTime = ActiveLine.IPara[4];
                                    int t = GDefine.GetTickCount() + SettleTime;
                                    while (GDefine.GetTickCount() <= t) { Thread.Sleep(1); }
                                    #endregion

                                    double v_ox = 0;
                                    double v_oy = 0;
                                    double v_oa = 0;
                                    double v_s = 0;
                                    bool v_OK = false;

                                    try
                                    {
                                        string data = "";
                                        TaskVision.ExecVision((int)EVisionRef.No1, ActiveLine.ID, ref v_ox, ref v_oy, ref v_oa, ref v_s, ref v_OK, ref data, ref TaskVision.Image);

                                        TaskVision.imgBoxEmgu.Image = TaskVision.Image;
                                        if (TaskVision.imgBoxEmgu != null) TaskVision.imgBoxEmgu.Invalidate();

                                        if (!v_OK)
                                        {
                                            #region
                                            DefineSafety.DoorLock = false;

                                            frmVisionFailMsg2 frmV = new frmVisionFailMsg2();
                                            Log.AddToLog("0" + (char)9 + "DoVisInsp Fail Unit No " + RunTime.UIndex.ToString());
                                            frmV.ShowAccept = true;
                                            frmV.ShowSkip = true;//updated 5.0.107 - 20210308 - KN
                                            frmV.ShowManual = false;

                                            DialogResult dr = frmV.ShowDialog();

                                            if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2)
                                            {
                                                Application.OpenForms[0].Invoke(new Action(() =>
                                                {
                                                    TaskVision.frmCamera.SelectCamera(0);
                                                    TaskVision.frmCamera.Grab();
                                                }));
                                            }
                                            if (GDefine.CameraType[0] == GDefine.ECameraType.MVCGenTL)
                                            {
                                                Application.OpenForms[0].Invoke(new Action(() =>
                                                {
                                                    if (TaskVision.frmMVCGenTLCamera.Visible)
                                                    {
                                                        TaskVision.frmMVCGenTLCamera.SelectCamera(0);
                                                        if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[0].StartGrab();
                                                    }
                                                }));
                                            }

                                            switch (dr)
                                            {
                                                #region
                                                case DialogResult.Retry://Retry Button
                                                    Log.AddToLog("0" + (char)9 + "Retry");
                                                    DefineSafety.DoorLock = true;
                                                    Thread.Sleep(100);
                                                    goto _Retry;
                                                case DialogResult.Cancel://Skip Button
                                                    Log.AddToLog("0" + (char)9 + "Skip");
                                                    v_OK = false;
                                                    DefineSafety.DoorLock = true;
                                                    Thread.Sleep(100);
                                                    break;
                                                case DialogResult.Yes://Accept Button
                                                    Log.AddToLog("0" + (char)9 + "Accept");
                                                    v_OK = true;
                                                    DefineSafety.DoorLock = true;
                                                    Thread.Sleep(100);
                                                    break;
                                                case DialogResult.Abort://Stop Button
                                                    Log.AddToLog("0" + (char)9 + "Stop");
                                                    LastLine++;
                                                    DefineSafety.DoorLock = true;
                                                    Thread.Sleep(100);
                                                    goto _Pause;
                                                default:
                                                    Log.AddToLog("0" + (char)9 + "Default");
                                                    for (int L = Line; L >= 0; L--)
                                                    {
                                                        if (CmdList.Line[L].Cmd == ECmd.FOR_LAYOUT)
                                                        {
                                                            LastLine = L;
                                                            break;
                                                        }
                                                    }
                                                    Thread.Sleep(100);
                                                    goto _Pause;
                                                    #endregion
                                            }
                                            #endregion
                                        }

                                        int i = RunTime.UIndex;
                                        if (!v_OK) Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.VVING;
                                        if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG) Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.VVIOK;

                                        #region Add Result Log
                                        string s_OKNG = v_OK ? "OK" : "NG";
                                        Log.Vision.WriteByMonthDay("VisInsp, UnitNo," + RunTime.UIndex.ToString() + ",C," + ColNo.ToString() + ",R," + RowNo.ToString() + "," + data);// + "," + s_OKNG);
                                        #endregion
                                    }
                                    finally
                                    {
                                    }
                                _End:;
                                    break;
                                }

                            #region SINGULATED_ID
                            case ECmd.SINGULATED_ID:
                                {
                                    rt_Singulated = true;
                                    break;
                                }
                            #endregion
                            #region READ_ID
                            case ECmd.READ_ID:
                                {
                                    //Special condition for Unisem process half frame
                                    if (TaskDisp.Preference == TaskDisp.EPreference.Unisem && TaskDisp.SECSGEMProtocol == TaskDisp.ESECSGEMProtocol.SECSGEMConnect2 && (GDefine.sgc2.EnableDnloadStripMapE142 || GDefine.sgc2.EnableUploadStripMapE142))
                                    {
                                        //Skip Read ID
                                        if (TaskConv.Pro.rt_StType == TaskConv.EProStType.Disp2 && TaskConv.Pro.Status == TaskConv.EProcessStatus.InProcess) goto _End;
                                    }

                                    EMsg = Msg + " READ_ID";

                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                    {
                                        if (rt_Head2MapBin >= EMapBin.BinNG) goto _End;
                                    }
                                    else
                                    {
                                        if (rt_Head1MapBin >= EMapBin.BinNG) goto _End;
                                    }

                                    b_Flag_ConsecutiveUnit = false;

                                    TaskVision.LightingOn(TaskVision.Read2DLightRGB);

                                    #region assign and translate pt1
                                    double dx = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[0];
                                    double dy = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[0];
                                    double dz = f_origin_z;
                                    TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);
                                    #endregion

                                    if (!Read_ID(ActiveLine, dx, dy)) goto _Pause;
                                    IO.SetState(EMcState.Run);

                                _End:
                                    break;
                                }
                            #endregion

                            case ECmd.DO_HEIGHT:
                                #region
                                {

                                    EMsg = Msg + Enum.GetName(typeof(ECmd), ECmd.DO_HEIGHT);
                                    int HeightID = ActiveLine.ID;

                                _Retry:
                                    #region Normal Operation
                                    #region Get current unit info
                                    int CColNo = 0; int CRowNo = 0; int UColNo = 0; int URowNo = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref UColNo, ref URowNo, ref CColNo, ref CRowNo);
                                    int ColNo = 0; int RowNo = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref ColNo, ref RowNo);
                                    #endregion

                                    THeightData HeightData = new THeightData();
                                    double d_Height_Rel_X = rt_Layout_Rel_X;
                                    double d_Height_Rel_Y = rt_Layout_Rel_Y;

                                    if (TaskDisp.Preference == TaskDisp.EPreference.Cree)
                                    {
                                        //1.1.22 - removed
                                        //added back for Cree
                                        //handle multiple layout not do height
                                        //int TTLayouts = rt_Layouts.Count();
                                        if (rt_LayoutID < rt_Layouts.Count() - 1)
                                        {
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID + 1].TUCount; i++)
                                            {
                                                int _CColNo = 0; int _CRowNo = 0; int _UColNo = 0; int _URowNo = 0;
                                                rt_Layouts[rt_LayoutID + 1].UnitNoGetRC(i, ref _UColNo, ref _URowNo, ref _CColNo, ref _CRowNo);

                                                if (CColNo == _CColNo && CRowNo == _CRowNo)
                                                {
                                                    if (Map.CurrMap[rt_LayoutID + 1].Bin[i] == EMapBin.HeightOK) continue;
                                                    if (Map.CurrMap[rt_LayoutID + 1].Bin[i] == EMapBin.RefOK)
                                                        goto _ForceHeight;
                                                }
                                            }
                                        }
                                    }

                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                    {
                                        if (rt_Head2MapBin >= EMapBin.BinNG) goto _End;
                                    }
                                    else
                                        if (rt_Head1MapBin >= EMapBin.BinNG) goto _End;

                                    if (rt_HeightData[HeightID, RunTime.UIndex].Ready) goto _End;

                                    _ForceHeight:
                                    b_Flag_ConsecutiveUnit = false;

                                    switch ((EAlignType)ActiveLine.IPara[2])
                                    {
                                        #region Manage Align Type
                                        case EAlignType.Board:
                                        default:
                                            #region
                                            //if (!(rt_UIndex == 0)) goto _End;
                                            d_Height_Rel_X = rt_LayoutRelPos[0].X;
                                            d_Height_Rel_Y = rt_LayoutRelPos[0].Y;
                                            break;
                                        #endregion
                                        case EAlignType.Clstr:
                                            #region
                                            //if (!(UColNo == 0 && URowNo == 0)) goto _End;
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                if (i_CColNo == CColNo && i_CRowNo == CRowNo && i_UColNo == 0 && i_URowNo == 0)
                                                {
                                                    d_Height_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Height_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.ClstrCol:
                                            #region
                                            //if (!(CRowNo == 0 && UColNo == 0 && URowNo == 0)) goto _End;
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_ColNo = 0; int i_RowNo = 0;// int i_UColNo = 0; int i_URowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);//, ref i_CColNo, ref i_CRowNo);

                                                if (i_ColNo == ColNo && i_RowNo == 0)
                                                {
                                                    d_Height_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Height_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.ClstrRow:
                                            #region
                                            //if (!(CColNo == 0 && UColNo == 0 && URowNo == 0)) goto _End;
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_ColNo = 0; int i_RowNo = 0;// int i_UColNo = 0; int i_URowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);//, ref i_CColNo, ref i_CRowNo);

                                                if (i_ColNo == 0 && i_RowNo == RowNo)
                                                {
                                                    d_Height_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Height_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.Unit:
                                            #region
                                            if (rt_Head1MapBin >= EMapBin.BinNG) goto _End;
                                            break;
                                        #endregion
                                        case EAlignType.UnitCol:
                                            #region
                                            //if (!(RowNo == 0)) goto _End;
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_ColNo = 0; int i_RowNo = 0;// int i_UColNo = 0; int i_URowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);//, ref i_CColNo, ref i_CRowNo);

                                                if (i_ColNo == ColNo && i_RowNo == 0)
                                                {
                                                    d_Height_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Height_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                        #endregion
                                        case EAlignType.UnitRow:
                                            #region
                                            //if (!(ColNo == 0)) goto _End;
                                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                            {
                                                int i_ColNo = 0; int i_RowNo = 0;// int i_UColNo = 0; int i_URowNo = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);//, ref i_CColNo, ref i_CRowNo);

                                                if (i_ColNo == 0 && i_RowNo == RowNo)
                                                {
                                                    d_Height_Rel_X = rt_LayoutRelPos[i].X;
                                                    d_Height_Rel_Y = rt_LayoutRelPos[i].Y;
                                                    break;
                                                }
                                            }
                                            break;
                                            #endregion
                                            #endregion
                                    }

                                    TaskVision.LightingOff();

                                    List<double> X = new List<double>();
                                    List<double> Y = new List<double>();
                                    List<double> Z = new List<double>();
                                    #region assign and translate pts
                                    int Points = CmdList.Line[Line].IPara[1];
                                    if (CmdList.Line[Line].IPara[0] == 3) Points = 3;//Plane Type

                                    double dx = 0;
                                    double dy = 0;
                                    for (int i = 0; i < Points; i++)
                                    {
                                        dx = f_origin_x + d_Height_Rel_X + CmdList.Line[Line].X[i];
                                        dy = f_origin_y + d_Height_Rel_Y + CmdList.Line[Line].Y[i];

                                        Point2D OriPt = new Point2D(dx, dy);
                                        Point2D NewPt = OriPt.Translate(new Point2D(rt_Head1RefData.DatumX, rt_Head1RefData.DatumY), new Point2D(rt_Head1RefData.NewDatumX, rt_Head1RefData.NewDatumY));
                                        NewPt = NewPt.Rotate(new Point2D(rt_Head1RefData.NewDatumX, rt_Head1RefData.NewDatumY), rt_Head1RefData.Angle);

                                        X.Add(NewPt.X);
                                        Y.Add(NewPt.Y);
                                        Z.Add(0);
                                    }
                                #endregion

                                _RetryHeight:
                                    bool doOK = false;
                                    if (!DoHeight(ActiveLine, Points, X, Y, Z, out doOK)) goto _Pause;
                                    int OK = doOK ? 0 : 100;//0 - OK, 1 - FailRefHeightTol, 2-FailRefHeightSkipTol, 3 - FailRange  100 - DoHeight Fail

                                    if (Z.Average() == 0)//exact Zero prompt error
                                    {
                                        #region
                                        Msg MsgBox = new Msg();
                                        EMsgRes MsgRes = MsgBox.Show("Z Average 0. ", EMcState.Error, EMsgBtn.smbStop, false);
                                        for (int L = Line; L >= 0; L--)
                                        {
                                            if (CmdList.Line[L].Cmd == ECmd.FOR_LAYOUT)
                                            {
                                                LastLine = L;
                                                break;
                                            }
                                        }
                                        goto _Pause;
                                        #endregion
                                    }

                                    #region Add Laser Log
                                    double Z_Ave = Math.Round(Z.Average(), 5);
                                    if (Z_Ave == 0)
                                    {
                                        Z_Ave = 0.00001;
                                        if (Z.Average() < 0) Z_Ave = -Z_Ave;
                                    }
                                    string s_HeightData = "";
                                    s_HeightData = s_HeightData + "Ave" + (char)9 + Z_Ave.ToString("f5") + (char)9;
                                    s_HeightData = s_HeightData + "Range" + (char)9 + (Z.Max() - Z.Min()).ToString("f5") + (char)9;
                                    s_HeightData = s_HeightData + "Data" + (char)9;
                                    foreach (double d in Z)
                                    {
                                        s_HeightData = s_HeightData + d.ToString("f5") + (char)9;
                                    }
                                    Log.Laser.WriteByMonthDay("UnitNo " + (char)9 + RunTime.UIndex.ToString() + (char)9 + s_HeightData);
                                    #endregion

                                    if (DispProg.Options_EnableProcessLog)
                                    {
                                        string str = $"Height\t";
                                        str += $"MeasID={ActiveLine.ID}\t";
                                        //str += $"UnitNo\t{RunTime.UIndex}\t";
                                        str += $"C,R={RunTime.Head_CR[0].X},{RunTime.Head_CR[0].Y}\t";
                                        for (int i = 0; i < Z.Count; i++)
                                        {
                                            str += $"X,Y,H={X[i]:f3},{Y[i]:f3},{Z[i]:f3}\t";
                                        }
                                        GLog.WriteProcessLog(str);
                                    }

                                    double d_RefHeight = TaskDisp.Laser_CalValue == 0 ? ActiveLine.DPara[5] : TaskDisp.Laser_CalValue - TaskDisp.Laser_RefPosZ + ActiveLine.DPara[5];
                                    double d_RefHeightErrorTol = ActiveLine.DPara[6];
                                    double d_RefHeightSkipTol = ActiveLine.DPara[7];

                                    //Prompt Error when exceed Error Tolerance
                                    if (d_RefHeightErrorTol > 0)
                                    {
                                        foreach (double d in Z)
                                        {
                                            if ((d <= d_RefHeight - d_RefHeightErrorTol) || (d >= d_RefHeight + d_RefHeightErrorTol))
                                            {
                                                HeightData.OK = false;
                                                Msg MsgBox = new Msg();
                                                EMsgRes MsgRes = MsgBox.Show(ErrCode.LASER_OUT_OF_REF_HEIGHT_TOL, $"Ref Height = {d_RefHeight:f4} Current Height = {d:f4}", EMcState.Warning, EMsgBtn.smbRetry_Stop | EMsgBtn.smbSkip, false);

                                                switch (MsgRes)
                                                {
                                                    case EMsgRes.smrRetry: goto _Retry;
                                                    case EMsgRes.smrSkip://skip
                                                        OK = 1;
                                                        //goto _Continue;
                                                        HeightData.OK = false;
                                                        goto _SkipHeight;
                                                    default://Stop
                                                        i_DoHeightSkipCntr = 0;
                                                        //clear all height data
                                                        RunTime.UIndex = 0;
                                                        for (int i = 0; i < MAX_IDS; i++)
                                                            for (int j = 0; j < TLayout.MAX_UNITS; j++)
                                                            {
                                                                rt_HeightData[i, j] = new THeightData();
                                                            }
                                                        goto _Pause;
                                                }
                                            }
                                        }
                                    }
                                    if (d_RefHeightSkipTol > 0)
                                    {
                                        foreach (double d in Z)
                                        {
                                            if ((d <= d_RefHeight - d_RefHeightSkipTol) || (d >= d_RefHeight + d_RefHeightSkipTol))
                                            {
                                                HeightData.OK = false;
                                                OK = 2;
                                                goto _Continue;
                                            }
                                        }
                                    }
                                _Continue:

                                    double Diff = Z.Max() - Z.Min();
                                    if (Diff > CmdList.Line[Line].DPara[0]) OK = 3;

                                    if (OK == 0)
                                        i_DoHeightSkipCntr = 0;
                                    else
                                        i_DoHeightSkipCntr++;

                                    //Check Z Rel Tolerance
                                    if (CmdList.Line[Line].DPara[1] > 0)
                                    {
                                        if (d_LastLaserHeight == 0)
                                        { }
                                        else
                                        {
                                            #region
                                            if (Math.Abs(Z.Average() - d_LastLaserHeight) >= CmdList.Line[Line].DPara[1])
                                            {
                                                DefineSafety.DoorLock = false;

                                                frm_DispCore_HeightFailMsg frm = new frm_DispCore_HeightFailMsg();
                                                frm.Message.Clear();
                                                frm.Message.Add("Unit Relative Height Tol Error.");
                                                frm.Message.Add("Relative difference " + (Math.Abs(Z.Average() - d_LastLaserHeight)).ToString("f3") + " mm.");
                                                frm.Buttons = frm_DispCore_HeightFailMsg.Retry | frm_DispCore_HeightFailMsg.Stop | frm_DispCore_HeightFailMsg.Skip;

                                                DialogResult dr = frm.ShowDialog();
                                                switch (dr)
                                                {
                                                    case DialogResult.Retry:
                                                        DefineSafety.DoorLock = true;
                                                        goto _RetryHeight;
                                                    case DialogResult.Abort://Stop
                                                        for (int L = Line; L >= 0; L--)
                                                        {
                                                            if (CmdList.Line[L].Cmd == ECmd.FOR_LAYOUT)
                                                            {
                                                                LastLine = L;
                                                                break;
                                                            }
                                                        }
                                                        goto _Pause;
                                                    case DialogResult.Ignore://Skip
                                                        OK = 4;// false;
                                                        i_DoHeightSkipCntr++;
                                                        DefineSafety.DoorLock = true;
                                                        HeightData.OK = false;
                                                        goto _SkipHeight;
                                                }

                                            }
                                            #endregion;
                                        }
                                        d_LastLaserHeight = Z.Average();
                                    }

                                    int SkipCount = ActiveLine.IPara[5];
                                    EFailAction FailAction = (EFailAction)ActiveLine.IPara[6];
                                    if (OK > 0 && i_DoHeightSkipCntr > SkipCount)
                                    {
                                        if (FailAction == EFailAction.AutoReject)
                                        {
                                            BdStatus = EBoardStatus.Reject;
                                            goto _EndBoard;
                                        }

                                        #region
                                        i_DoHeightSkipCntr = 0;

                                        DefineSafety.DoorLock = false;
                                        frm_DispCore_HeightFailMsg frm = new frm_DispCore_HeightFailMsg();
                                        frm.FailAction = FailAction;
                                        frm.Message.Clear();

                                        switch (OK)
                                        {
                                            case 3:
                                                frm.Message.Add("Laser Height Z Diff exceed spec.");
                                                frm.Message.Add("Measured (mm)" + (char)9 + Diff.ToString("f3"));
                                                frm.Message.Add("Spec (mm)" + (char)9 + CmdList.Line[Line].DPara[0].ToString("f3"));
                                                break;
                                            case 1:
                                                frm.Message.Add("Laser Height exceed Ref Error Tol.");
                                                break;
                                            case 2:
                                                frm.Message.Add("Laser Height exceed Ref Skip Tol.");
                                                break;
                                            default:
                                                frm.Message.Add("Laser Height Error.");
                                                break;
                                        }
                                        DialogResult dr = frm.ShowDialog();

                                        switch (dr)
                                        {
                                            case DialogResult.Retry://Retry
                                                DefineSafety.DoorLock = true;
                                                goto _RetryHeight;
                                            case DialogResult.Ignore://Skip
                                                                     //OK = false;
                                                DefineSafety.DoorLock = true;
                                                break;
                                            case DialogResult.Yes://Accept
                                                OK = 0;
                                                DefineSafety.DoorLock = true;
                                                break;
                                            case DialogResult.Cancel://Reject
                                                BdStatus = EBoardStatus.Reject;
                                                DefineSafety.DoorLock = true;
                                                goto _EndBoard;
                                            default://Stop
                                                for (int L = Line; L >= 0; L--)
                                                {
                                                    if (CmdList.Line[L].Cmd == ECmd.FOR_LAYOUT)
                                                    {
                                                        LastLine = L;
                                                        break;
                                                    }
                                                }
                                                goto _Pause;
                                        }
                                        #endregion
                                    }

                                    //_SkipHeight:
                                    double A = 0;
                                    double B = 0;
                                    double C = 0;
                                    if (CmdList.Line[Line].IPara[0] == 3)//Plane Type
                                    {
                                        #region generate plane eq and update height data
                                        bool b_planeOK = GDefine.GenerateXYZPlaneEquation(X[0], Y[0], Z[0], X[1], Y[1], Z[1], X[2], Y[2], Z[2], out A, out B, out C);

                                        HeightData.A = A;
                                        HeightData.B = B;
                                        HeightData.C = C;
                                        HeightData.OK = OK == 0 && b_planeOK;
                                        #endregion
                                    }
                                    else//Height Type
                                    {
                                        #region update height data
                                        HeightData.A = 0;
                                        HeightData.B = 0;
                                        HeightData.C = Z.Average();
                                        HeightData.OK = OK == 0;
                                        #endregion
                                    }

                                _SkipHeight:
                                    HeightData.Ready = true;

                                    if (!b_InLoop)//***update all layout if ref is done outside loop
                                    {
                                        #region
                                        for (int ID = 0; ID < rt_LayoutCount; ID++)
                                        {
                                            for (int i = 0; i < rt_Layouts[ID].TUCount; i++)
                                            {
                                                rt_HeightData[HeightID, i].Copy(HeightData);
                                                if (Map.CurrMap[ID].Bin[i] < EMapBin.BinNG)
                                                {
                                                    if (rt_HeightData[HeightID, i].OK)
                                                        Map.CurrMap[ID].Bin[i] = EMapBin.HeightOK;
                                                    else
                                                        Map.CurrMap[ID].Bin[i] = EMapBin.HeightNG;
                                                }
                                            }
                                        }
                                        #endregion
                                    }
                                    else
                                        switch ((EAlignType)ActiveLine.IPara[2])
                                        {
                                            #region Update Unit HeightData
                                            case EAlignType.Board:
                                            default:
                                                #region
                                                if (ActiveLine.IPara[7] > 0)//update all layout; eg for net dispense
                                                {
                                                    for (int ID = rt_LayoutID; ID < rt_LayoutCount; ID++)
                                                    {
                                                        for (int i = 0; i < rt_Layouts[ID].TUCount; i++)
                                                        {
                                                            rt_HeightData[HeightID, i].Copy(HeightData);
                                                            if (Map.CurrMap[ID].Bin[i] < EMapBin.BinNG)
                                                            {
                                                                if (rt_HeightData[HeightID, i].OK)
                                                                    Map.CurrMap[ID].Bin[i] = EMapBin.HeightOK;
                                                                else
                                                                    Map.CurrMap[ID].Bin[i] = EMapBin.HeightNG;
                                                            }
                                                        }
                                                    }
                                                }
                                                else
                                                    for (int i = 0; i < rt_Layouts[HeightID].TUCount; i++)
                                                    {
                                                        rt_HeightData[HeightID, i].Copy(HeightData);
                                                        if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                        {
                                                            if (rt_HeightData[HeightID, i].OK)
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.HeightOK;
                                                            else
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.HeightNG;
                                                        }
                                                    }
                                                break;
                                            #endregion
                                            case EAlignType.Clstr:
                                                #region
                                                {
                                                    if (ActiveLine.IPara[7] > 0)//update all layout; eg for net dispense
                                                    {
                                                        for (int ID = rt_LayoutID; ID < rt_LayoutCount; ID++)
                                                        {
                                                            rt_Layouts[ID].UnitNoGetRC(RunTime.UIndex, ref UColNo, ref URowNo, ref CColNo, ref CRowNo);

                                                            for (int i = 0; i < rt_Layouts[ID].TUCount; i++)
                                                            {
                                                                int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                                rt_Layouts[ID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                                if (i_CColNo == CColNo && i_CRowNo == CRowNo)
                                                                {
                                                                    rt_HeightData[HeightID, i].Copy(HeightData);
                                                                    if (Map.CurrMap[ID].Bin[i] < EMapBin.BinNG)
                                                                    {
                                                                        if (rt_HeightData[HeightID, i].OK)
                                                                            Map.CurrMap[ID].Bin[i] = EMapBin.HeightOK;
                                                                        else
                                                                            Map.CurrMap[ID].Bin[i] = EMapBin.HeightNG;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else
                                                    {
                                                        rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref UColNo, ref URowNo, ref CColNo, ref CRowNo);

                                                        for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                        {
                                                            int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                            rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                            if (i_CColNo == CColNo && i_CRowNo == CRowNo)
                                                            {
                                                                rt_HeightData[HeightID, i].Copy(HeightData);
                                                                if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                                {
                                                                    if (rt_HeightData[HeightID, i].OK)
                                                                        Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.HeightOK;
                                                                    else
                                                                        Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.HeightNG;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.ClstrCol:
                                                #region
                                                //if (CRowNo == 0 && UColNo == 0 && URowNo == 0)
                                                {
                                                    for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                    {
                                                        int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                        rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                        if (i_CColNo == CColNo)// && i_UColNo == UColNo && i_URowNo == URowNo)
                                                        {
                                                            rt_HeightData[HeightID, i].Copy(HeightData);
                                                            if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                            {
                                                                if (rt_HeightData[HeightID, i].OK)
                                                                    Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.HeightOK;
                                                                else
                                                                    Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.HeightNG;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.ClstrRow:
                                                #region
                                                //if (CColNo == 0 && UColNo == 0 && URowNo == 0)
                                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                {
                                                    int i_CColNo = 0; int i_CRowNo = 0; int i_UColNo = 0; int i_URowNo = 0;
                                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_UColNo, ref i_URowNo, ref i_CColNo, ref i_CRowNo);

                                                    if (i_CRowNo == CRowNo)// && i_UColNo == UColNo && i_URowNo == URowNo)
                                                    {
                                                        rt_HeightData[HeightID, i].Copy(HeightData);
                                                        if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                        {
                                                            if (rt_HeightData[HeightID, i].OK)
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.HeightOK;
                                                            else
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.HeightNG;
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.Unit:
                                                #region
                                                {
                                                    int i = RunTime.UIndex;
                                                    rt_HeightData[HeightID, i].Copy(HeightData);
                                                    if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                    {
                                                        if (rt_HeightData[HeightID, i].OK)
                                                            Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.HeightOK;
                                                        else
                                                            Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.HeightNG;
                                                    }
                                                    break;
                                                }
                                            #endregion
                                            case EAlignType.UnitCol:
                                                #region
                                                //if (RowNo == 0)
                                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                {
                                                    int i_ColNo = 0; int i_RowNo = 0;
                                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);

                                                    if (i_ColNo == ColNo)
                                                    {
                                                        rt_HeightData[HeightID, i].Copy(HeightData);
                                                        if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                        {
                                                            if (rt_HeightData[HeightID, i].OK)
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.HeightOK;
                                                            else
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.HeightNG;
                                                        }
                                                    }
                                                }
                                                break;
                                            #endregion
                                            case EAlignType.UnitRow:
                                                #region
                                                //if (ColNo == 0)
                                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                                {
                                                    int i_ColNo = 0; int i_RowNo = 0;
                                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref i_ColNo, ref i_RowNo);

                                                    if (i_RowNo == RowNo)
                                                    {
                                                        rt_HeightData[HeightID, i].Copy(HeightData);
                                                        if (Map.CurrMap[rt_LayoutID].Bin[i] < EMapBin.BinNG)
                                                        {
                                                            if (rt_HeightData[HeightID, i].OK)
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.HeightOK;
                                                            else
                                                                Map.CurrMap[rt_LayoutID].Bin[i] = EMapBin.HeightNG;
                                                        }
                                                    }
                                                }
                                                break;
                                                #endregion
                                                #endregion
                                        }
                                    #endregion
                                    _End:
                                    break;
                                }
                            #endregion
                            case ECmd.USE_HEIGHT:
                                #region
                                {
                                    EMsg = Msg + " USE_HEIGHT";

                                    int HeightID = CmdList.Line[Line].ID;

                                    rt_Head1HeightData = rt_HeightData[HeightID, RunTime.UIndex];
                                    rt_Head2HeightData = rt_Head1HeightData;
                                    if (rt_SyncHead2)
                                    {
                                        int Head2Index = 0;
                                        bool IsValid = true;
                                        if (rt_Layouts[rt_LayoutID].UnitNoGetHead2UnitNo(RunTime.UIndex, ref Head2Index, ref IsValid))
                                            rt_Head2HeightData = rt_HeightData[HeightID, Head2Index];
                                    }
                                    break;
                                }
                            #endregion
                            case ECmd.HEIGHT_SET:
                                #region
                                {
                                    EMsg = Msg + ActiveLine.Cmd.ToString();
                                    int HeightID = ActiveLine.ID;
                                    b_Flag_ConsecutiveUnit = false;

                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                    {
                                        if (rt_Head2MapBin >= EMapBin.BinNG) goto _End;
                                    }
                                    else
                                        if (rt_Head1MapBin >= EMapBin.BinNG) goto _End;

                                    THeightData HeightData = new THeightData();
                                    HeightData.OK = false;

                                    int nextLine = Line + 1;
                                    bool bNextCmdIsValid =
                                        (
                                        CmdList.Line[nextLine].Cmd == ECmd.DOT ||
                                        CmdList.Line[nextLine].Cmd == ECmd.DOT_MULTI ||
                                        CmdList.Line[nextLine].Cmd == ECmd.DOTLINE_MULTI ||
                                        CmdList.Line[nextLine].Cmd == ECmd.DOT_P ||
                                        CmdList.Line[nextLine].Cmd == ECmd.MOVE
                                        );
                                    if (!bNextCmdIsValid) throw new Exception("Invalid command after HEIGHT_SET");

                                    #region assign and translate position of next Command
                                    double dx = f_origin_x + rt_Layout_Rel_X + CmdList.Line[nextLine].X[0];
                                    double dy = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[nextLine].Y[0];
                                    double dz = f_origin_z;
                                    TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);
                                    #endregion

                                    EHeightSetReturn ret = HeightSet(ActiveLine, HeightData, new PointD(dx, dy));

                                    switch (ret)
                                    {
                                        case EHeightSetReturn.OK:
                                            break;
                                        case EHeightSetReturn.Skip:
                                            goto _SkipHeight;
                                        default:
                                            for (int L = Line; L >= 0; L--)
                                            {
                                                if (CmdList.Line[L].Cmd == ECmd.FOR_LAYOUT)
                                                {
                                                    LastLine = L;
                                                    break;
                                                }
                                            }
                                            goto _Pause;
                                    }

                                _SkipHeight:
                                    HeightData.Ready = true;
                                    rt_Head1HeightData = HeightData;

                                    rt_HeightData[HeightID, RunTime.UIndex].Copy(HeightData);
                                    if (Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] < EMapBin.BinNG)
                                    {
                                        if (rt_HeightData[HeightID, RunTime.UIndex].OK)
                                            Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] = EMapBin.HeightOK;
                                        else
                                            Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] = EMapBin.HeightNG;
                                    }
                                _End:
                                    break;
                                }
                            #endregion

                            case ECmd.DOT_MULTI:
                                #region
                                {
                                    if (!b_InLoop && !Running) goto _Pause;
                                    LicenseValidation();

                                    int t = GDefine.GetTickCount();

                                    EMsg = Msg + " DOT_MULTI";
                                    if (b_SecondHalf || b_IsNeedle2) break;
                                    TaskVision.LightingOn(TaskVision.DefLightRGB);

                                    if (GDefine.CameraType[(int)TaskVision.SelectedCam] == GDefine.ECameraType.PtGrey)
                                    {
                                        if (RunMode == ERunMode.Camera)
                                            TaskVision.PtGrey_CamLive(0);
                                    }
                                    if (!DoDotMulti(ActiveLine, RunMode, f_origin_x, f_origin_y, f_origin_z)) Running = false;
                                    break;
                                }
                            #endregion

                            case ECmd.DOT:
                                #region
                                {
                                    //1.0.38.2 TaskVision.CameraRun = (RunMode == ERunMode.Camera);

                                    if (!b_InLoop && !Running) goto _Pause;
                                    LicenseValidation();

                                    EMsg = Msg + " DOT";
                                    if (b_SecondHalf || b_IsNeedle2) break;
                                    TaskVision.LightingOn(TaskVision.DefLightRGB);

                                    #region assign and translate position
                                    double dx = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[0] + rt_RepeatOfst.X;
                                    double dy = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[0] + rt_RepeatOfst.Y;
                                    double dz = f_origin_z;
                                    TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);

                                    double dx2 = f_origin_x + rt_Layout_Rel_X2 + CmdList.Line[Line].X[0] + rt_RepeatOfst.X;
                                    double dy2 = f_origin_y + rt_Layout_Rel_Y2 + CmdList.Line[Line].Y[0] + rt_RepeatOfst.Y;
                                    TranslatePos(dx2, dy2, rt_Head2RefData, ref dx2, ref dy2);

                                    //Z Correction
                                    dz = dz + TaskDisp.Head_Ofst[0].Z;
                                    double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z));
                                    double dz2 = dz + ZDiff;
                                    #endregion

                                    dx = dx + BiasKernel.X[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XZ_YTABLE)
                                        dy = dy - BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                                    else
                                        dy = dy + BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                                    dz = dz + BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];

                                    EHeadNo HeadNo = (EHeadNo)CmdList.Line[Line].ID;
                                    switch (TaskDisp.Head_Operation)
                                    {
                                        case TaskDisp.EHeadOperation.Single:
                                            HeadNo = EHeadNo.Head1;
                                            break;
                                        case TaskDisp.EHeadOperation.Sync:
                                            if (!b_Head2UnitIsValid) HeadNo = HeadNo & EHeadNo.Head1;
                                            break;
                                    }

                                    #region Force Head Operation
                                    if (b_ForceHead1)
                                    {
                                        if (HeadNo == EHeadNo.Head2)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head1;
                                    }
                                    if (b_ForceHead2)
                                    {
                                        if (GDefine.HeadConfig != GDefine.EHeadConfig.Dual || DispProg.Head_Operation == TaskDisp.EHeadOperation.Single)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head2;
                                    }
                                    #endregion

                                    b_MovePanelGap = MovePanelGap(Line);//Cmd: DOT

                                    if (GDefine.CameraType[(int)TaskVision.SelectedCam] == GDefine.ECameraType.PtGrey)
                                    {
                                        if (RunMode == ERunMode.Camera)
                                            TaskVision.PtGrey_CamLive(0);
                                    }

                                    if (!DoDot(ActiveLine, HeadNo, rt_SyncHead2, b_Head2UnitIsValid, RunMode, dx, dy, dz, dx2, dy2, dz2))
                                    {
                                        Running = false;
                                    }
                                    break;
                                }
                            #endregion
                            case ECmd.DOT_P:
                                #region
                                {
                                    if (!b_InLoop && !Running) goto _Pause;
                                    LicenseValidation();

                                    int t = GDefine.GetTickCount();

                                    EMsg = Msg + " DOT_P";
                                    if (b_SecondHalf || b_IsNeedle2) break;
                                    TaskVision.LightingOn(TaskVision.DefLightRGB);

                                    if (GDefine.CameraType[(int)TaskVision.SelectedCam] == GDefine.ECameraType.PtGrey)
                                    {
                                        if (RunMode == ERunMode.Camera)
                                            TaskVision.PtGrey_CamLive(0);
                                    }

                                    b_MovePanelGap = MovePanelGap(Line);//Cmd: DOT_P

                                    if (!Dot_P(ActiveLine, RunMode, f_origin_x + rt_RepeatOfst.X, f_origin_y + rt_RepeatOfst.Y, f_origin_z)) Running = false;
                                    break;
                                }
                            #endregion
                            case ECmd.DOTLINE_MULTI:
                                #region
                                {
                                    if (!b_InLoop && !Running) goto _Pause;
                                    LicenseValidation();

                                    int t = GDefine.GetTickCount();

                                    EMsg = Msg + " DOT_L";
                                    if (b_SecondHalf || b_IsNeedle2) break;
                                    TaskVision.LightingOn(TaskVision.DefLightRGB);

                                    if (GDefine.CameraType[(int)TaskVision.SelectedCam] == GDefine.ECameraType.PtGrey)
                                    {
                                        if (RunMode == ERunMode.Camera)
                                            TaskVision.PtGrey_CamLive(0);
                                    }

                                    b_MovePanelGap = MovePanelGap(Line);//Cmd: DOTLINE_MULTI

                                    if (!DotLine_Multi(ActiveLine, RunMode, f_origin_x, f_origin_y, f_origin_z)) Running = false;
                                    break;
                                }
                            #endregion

                            case ECmd.MOVE:
                                #region
                                {
                                    if (!b_InLoop && !Running) goto _Pause;
                                    LicenseValidation();

                                    EMsg = Msg + " MOVE";
                                    if (b_SecondHalf || b_IsNeedle2) break;
                                    TaskVision.LightingOn(TaskVision.DefLightRGB);

                                    MoveLine_ReverseDir = (EMoveLineRev)CmdList.Line[Line].IPara[4];
                                    if (CmdList.Line[Line + 1].Cmd != ECmd.LINE) MoveLine_ReverseDir = EMoveLineRev.None;

                                    #region assign and translate position
                                    double dz = f_origin_z;
                                    double dx = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[0] + rt_RepeatOfst.X;
                                    double dy = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[0] + rt_RepeatOfst.Y;
                                    TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);

                                    double dx2 = f_origin_x + rt_Layout_Rel_X2 + CmdList.Line[Line].X[0] + rt_RepeatOfst.X;
                                    double dy2 = f_origin_y + rt_Layout_Rel_Y2 + CmdList.Line[Line].Y[0] + rt_RepeatOfst.Y;
                                    TranslatePos(dx2, dy2, rt_Head2RefData, ref dx2, ref dy2);

                                    #region MoveLine_ReverseDir
                                    if (MoveLine_ReverseDir > EMoveLineRev.None)
                                    {
                                        int RowNo = 0;
                                        int ColNo = 0;
                                        rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref ColNo, ref RowNo);

                                        if ((MoveLine_ReverseDir == EMoveLineRev.OddRow && (RowNo % 2) == 1) ||
                                            (MoveLine_ReverseDir == EMoveLineRev.OddCol && (ColNo % 2) == 1))
                                        {
                                            dz = f_origin_z;
                                            dx = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line + 1].X[0];
                                            dy = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line + 1].Y[0];
                                            TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);

                                            dx2 = f_origin_x + rt_Layout_Rel_X2 + CmdList.Line[Line + 1].X[0];
                                            dy2 = f_origin_y + rt_Layout_Rel_Y2 + CmdList.Line[Line + 1].Y[0];
                                            TranslatePos(dx2, dy2, rt_Head2RefData, ref dx2, ref dy2);
                                        }
                                    }
                                    #endregion
                                    #endregion

                                    dx = dx + BiasKernel.X[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XZ_YTABLE)
                                        dy = dy - BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                                    else
                                        dy = dy + BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];

                                    EHeadNo HeadNo = (EHeadNo)CmdList.Line[Line].ID;
                                    switch (TaskDisp.Head_Operation)
                                    {
                                        case TaskDisp.EHeadOperation.Single:
                                            HeadNo = EHeadNo.Head1;
                                            break;
                                        case TaskDisp.EHeadOperation.Sync:
                                            if (!b_Head2UnitIsValid) HeadNo = HeadNo & EHeadNo.Head1;
                                            break;
                                    }
                                    #region Force Head Operation
                                    if (b_ForceHead1)
                                    {
                                        if (HeadNo == EHeadNo.Head2)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head1;
                                    }
                                    if (b_ForceHead2)
                                    {
                                        if (GDefine.HeadConfig != GDefine.EHeadConfig.Dual || DispProg.Head_Operation == TaskDisp.EHeadOperation.Single)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head2;
                                    }
                                    #endregion

                                    int ModelNo = CmdList.Line[Line].IPara[0];
                                    b_MovePanelGap = MovePanelGap(Line);//Cmd: MOVE

                                    if (GDefine.CameraType[(int)TaskVision.SelectedCam] == GDefine.ECameraType.PtGrey)
                                    {
                                        if (RunMode == ERunMode.Camera)
                                            TaskVision.PtGrey_CamLive(0);
                                    }

                                    if (!DoMove(HeadNo, rt_SyncHead2, b_Head2UnitIsValid, RunMode, dx, dy, dz, dx2, dy2)) goto _Error;

                                    Pt_Prev_End.X = dx;
                                    Pt_Prev_End.Y = dy;
                                    Pt_Prev2_End.X = dx2;
                                    Pt_Prev2_End.Y = dy2;

                                    break;
                                }
                            #endregion
                            case ECmd.LINE:
                                #region
                                {
                                    EMsg = Msg + " LINE";
                                    if (b_SecondHalf || b_IsNeedle2) break;

                                    TaskVision.LightingOn(TaskVision.DefLightRGB);

                                    bool First = true;
                                    if (Line > 0)
                                    {
                                        First = !(CmdList.Line[Line - 1].Cmd == ECmd.LINE ||
                                            CmdList.Line[Line - 1].Cmd == ECmd.ARC ||
                                            CmdList.Line[Line - 1].Cmd == ECmd.CIRC ||
                                            CmdList.Line[Line - 1].Cmd == ECmd.DWELL
                                            );
                                    }

                                    bool Last = true;
                                    if (Line < CmdList.Count - 1)
                                    {
                                        Last = !(CmdList.Line[Line + 1].Cmd == ECmd.LINE ||
                                            CmdList.Line[Line + 1].Cmd == ECmd.ARC ||
                                            CmdList.Line[Line + 1].Cmd == ECmd.CIRC ||
                                            CmdList.Line[Line + 1].Cmd == ECmd.DWELL
                                            );
                                    }

                                    #region assign and translate position
                                    double dx = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[0] + rt_RepeatOfst.X;
                                    double dy = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[0] + rt_RepeatOfst.Y;
                                    double dz = f_origin_z;
                                    TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);

                                    double dx2 = f_origin_x + rt_Layout_Rel_X2 + CmdList.Line[Line].X[0] + rt_RepeatOfst.X;
                                    double dy2 = f_origin_y + rt_Layout_Rel_Y2 + CmdList.Line[Line].Y[0] + rt_RepeatOfst.Y;
                                    TranslatePos(dx2, dy2, rt_Head2RefData, ref dx2, ref dy2);

                                    #region MoveLine_ReverseDir
                                    if (MoveLine_ReverseDir > EMoveLineRev.None)
                                    {
                                        int RowNo = 0;
                                        int ColNo = 0;
                                        rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref ColNo, ref RowNo);

                                        if ((MoveLine_ReverseDir == EMoveLineRev.OddRow && (RowNo % 2) == 1) ||
                                            (MoveLine_ReverseDir == EMoveLineRev.OddCol && (ColNo % 2) == 1))
                                        {
                                            dz = f_origin_z;
                                            dx = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line - 1].X[0];
                                            dy = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line - 1].Y[0];
                                            TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);

                                            dx2 = f_origin_x + rt_Layout_Rel_X2 + CmdList.Line[Line - 1].X[0];
                                            dy2 = f_origin_y + rt_Layout_Rel_Y2 + CmdList.Line[Line - 1].Y[0];
                                            TranslatePos(dx2, dy2, rt_Head2RefData, ref dx2, ref dy2);
                                        }

                                        MoveLine_ReverseDir = EMoveLineRev.None;
                                    }
                                    #endregion

                                    dx = dx + BiasKernel.X[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XZ_YTABLE)
                                        dy = dy - BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                                    else
                                        dy = dy + BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];

                                    #endregion

                                    EHeadNo HeadNo = (EHeadNo)CmdList.Line[Line].ID;
                                    switch (TaskDisp.Head_Operation)
                                    {
                                        case TaskDisp.EHeadOperation.Single:
                                            HeadNo = EHeadNo.Head1;
                                            break;
                                        case TaskDisp.EHeadOperation.Sync:
                                            if (!b_Head2UnitIsValid) HeadNo = HeadNo & EHeadNo.Head1;
                                            break;
                                    }
                                    #region Force Head Operation
                                    if (b_ForceHead1)
                                    {
                                        if (HeadNo == EHeadNo.Head2)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head1;
                                    }
                                    if (b_ForceHead2)
                                    {
                                        if (GDefine.HeadConfig != GDefine.EHeadConfig.Dual || DispProg.Head_Operation == TaskDisp.EHeadOperation.Single)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head2;
                                    }
                                    #endregion

                                    b_MovePanelGap = MovePanelGap(Line);//Cmd: LINE
                                    bool b_Continuous = ActiveLine.IPara[10] > 0;

                                    if (b_Continuous)
                                    {
                                        if (!DoCLine(ActiveLine, Line, HeadNo, RunMode, dx, dy, dz, dx2, dy2, First, Last)) goto _Error;
                                    }
                                    else
                                    {
                                        if (!DoLine(ActiveLine, HeadNo, rt_SyncHead2, RunMode, dx, dy, dz, dx2, dy2, First, Last)) goto _Pause;
                                    }
                                    break;
                                }
                            #endregion
                            case ECmd.ARC:
                            case ECmd.CIRC:
                                #region
                                {
                                    //1.0.38.2 TaskVision.CameraRun = (RunMode == ERunMode.Camera);

                                    EMsg = Msg + " ARCCIRC";
                                    if (b_SecondHalf || b_IsNeedle2) break;
                                    TaskVision.LightingOn(TaskVision.DefLightRGB);

                                    bool First = true;
                                    if (Line > 0)
                                    {
                                        First = !(CmdList.Line[Line - 1].Cmd == ECmd.LINE ||
                                            CmdList.Line[Line - 1].Cmd == ECmd.ARC ||
                                            CmdList.Line[Line - 1].Cmd == ECmd.CIRC ||
                                            CmdList.Line[Line - 1].Cmd == ECmd.DWELL
                                            );
                                    }

                                    bool Last = true;
                                    if (Line < CmdList.Count - 1)
                                    {
                                        Last = !(CmdList.Line[Line + 1].Cmd == ECmd.LINE ||
                                            CmdList.Line[Line + 1].Cmd == ECmd.ARC ||
                                            CmdList.Line[Line + 1].Cmd == ECmd.CIRC ||
                                            CmdList.Line[Line + 1].Cmd == ECmd.DWELL
                                            );
                                    }

                                    #region assign and translate position
                                    double dz = f_origin_z;

                                    double dx2 = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[0] + rt_RepeatOfst.X;
                                    double dy2 = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[0] + rt_RepeatOfst.Y;
                                    TranslatePos(dx2, dy2, rt_Head1RefData, ref dx2, ref dy2);

                                    double dx3 = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[1] + rt_RepeatOfst.X;
                                    double dy3 = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[1] + rt_RepeatOfst.Y;
                                    TranslatePos(dx3, dy3, rt_Head1RefData, ref dx3, ref dy3);

                                    double dx3_2 = f_origin_x + rt_Layout_Rel_X2 + CmdList.Line[Line].X[1] + rt_RepeatOfst.X;
                                    double dy3_2 = f_origin_y + rt_Layout_Rel_Y2 + CmdList.Line[Line].Y[1] + rt_RepeatOfst.Y;
                                    TranslatePos(dx3_2, dy3_2, rt_Head2RefData, ref dx3_2, ref dy3_2);
                                    #endregion

                                    dx2 = dx2 + BiasKernel.X[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XZ_YTABLE)
                                        dy2 = dy2 - BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                                    else
                                        dy2 = dy2 + BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];

                                    dx3 = dx3 + BiasKernel.X[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XZ_YTABLE)
                                        dy3 = dy3 - BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                                    else
                                        dy3 = dy3 + BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];

                                    bool circ = (CmdList.Line[Line].Cmd == ECmd.CIRC);

                                    EHeadNo HeadNo = (EHeadNo)CmdList.Line[Line].ID;
                                    //if (!b_Head2UnitIsValid) HeadNo = HeadNo & EHeadNo.Head1;
                                    //if (TaskDisp.Head_Operation == TaskDisp.EHeadOperation.Single) HeadNo = EHeadNo.Head1;
                                    switch (TaskDisp.Head_Operation)
                                    {
                                        case TaskDisp.EHeadOperation.Single:
                                            HeadNo = EHeadNo.Head1;
                                            break;
                                        case TaskDisp.EHeadOperation.Sync:
                                            if (!b_Head2UnitIsValid) HeadNo = HeadNo & EHeadNo.Head1;
                                            break;
                                    }
                                    #region Force Head Operation
                                    if (b_ForceHead1)
                                    {
                                        if (HeadNo == EHeadNo.Head2)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head1;
                                    }
                                    if (b_ForceHead2)
                                    {
                                        if (GDefine.HeadConfig != GDefine.EHeadConfig.Dual || DispProg.Head_Operation == TaskDisp.EHeadOperation.Single)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head2;
                                    }
                                    #endregion

                                    b_MovePanelGap = MovePanelGap(Line);//Cmd: ARC, CIRC

                                    bool b_Cont = ActiveLine.IPara[10] > 0;
                                    if (b_Cont)
                                    {
                                        if (!DoCArc(ActiveLine, Line, HeadNo, RunMode, dx2, dy2, dx3, dy3, dz, circ, First, Last)) goto _Error;
                                    }
                                    else
                                    {
                                        if (!DoArc(ActiveLine, HeadNo, rt_SyncHead2, RunMode, dx2, dy2, dx3, dy3, dz, circ, First, Last)) goto _Error;
                                    }

                                    break;
                                }
                            #endregion
                            case ECmd.DWELL:
                                #region
                                {
                                    EMsg = Msg + " DO_DWELL";
                                    if (b_SecondHalf || b_IsNeedle2) break;

                                    TaskVision.LightingOn(TaskVision.DefLightRGB);


                                    bool First = true;
                                    if (Line > 0)
                                    {
                                        First = !(CmdList.Line[Line - 1].Cmd == ECmd.LINE ||
                                            CmdList.Line[Line - 1].Cmd == ECmd.ARC ||
                                            CmdList.Line[Line - 1].Cmd == ECmd.CIRC ||
                                            CmdList.Line[Line - 1].Cmd == ECmd.DWELL
                                            );
                                    }

                                    bool Last = true;
                                    if (Line < CmdList.Count - 1)
                                    {
                                        Last = !(CmdList.Line[Line + 1].Cmd == ECmd.LINE ||
                                            CmdList.Line[Line + 1].Cmd == ECmd.ARC ||
                                            CmdList.Line[Line + 1].Cmd == ECmd.CIRC ||
                                            CmdList.Line[Line + 1].Cmd == ECmd.DWELL
                                            );
                                    }


                                    #region assign and translate position
                                    double dz = f_origin_z;
                                    #endregion

                                    EHeadNo HeadNo = (EHeadNo)CmdList.Line[Line].ID;
                                    switch (TaskDisp.Head_Operation)
                                    {
                                        case TaskDisp.EHeadOperation.Single:
                                            HeadNo = EHeadNo.Head1;
                                            break;
                                        case TaskDisp.EHeadOperation.Sync:
                                            if (!b_Head2UnitIsValid) HeadNo = HeadNo & EHeadNo.Head1;
                                            break;
                                    }
                                    #region Force Head Operation
                                    if (b_ForceHead1)
                                    {
                                        if (HeadNo == EHeadNo.Head2)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head1;
                                    }
                                    if (b_ForceHead2)
                                    {
                                        if (GDefine.HeadConfig != GDefine.EHeadConfig.Dual || DispProg.Head_Operation == TaskDisp.EHeadOperation.Single)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head2;
                                    }
                                    #endregion

                                    int ModelNo = CmdList.Line[Line].IPara[0];
                                    b_MovePanelGap = MovePanelGap(Line);//Cmd: DWELL

                                    if (GDefine.CameraType[(int)TaskVision.SelectedCam] == GDefine.ECameraType.PtGrey)
                                    {
                                        if (RunMode == ERunMode.Camera)
                                            TaskVision.PtGrey_CamLive(0);
                                    }


                                    if (!DoDwell(ActiveLine, HeadNo, rt_SyncHead2, RunMode, dz, First, Last)) goto _Error;

                                    break;
                                }
                            #endregion
                            case ECmd.WAIT:
                                #region
                                {
                                    EMsg = Msg + " " + ECmd.WAIT.ToString();

                                    if (!b_InLoop && !Running) goto _Pause;

                                    EHeadNo HeadNo = (EHeadNo)CmdList.Line[Line].ID;

                                    switch (TaskDisp.Head_Operation)
                                    {
                                        case TaskDisp.EHeadOperation.Single:
                                            HeadNo = EHeadNo.Head1;
                                            break;
                                        case TaskDisp.EHeadOperation.Sync:
                                            if (!b_Head2UnitIsValid) HeadNo = HeadNo & EHeadNo.Head1;
                                            break;
                                    }
                                    #region Force Head Operation
                                    if (b_ForceHead1)
                                    {
                                        if (HeadNo == EHeadNo.Head2)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head1;
                                    }
                                    if (b_ForceHead2)
                                    {
                                        if (GDefine.HeadConfig != GDefine.EHeadConfig.Dual || DispProg.Head_Operation == TaskDisp.EHeadOperation.Single || HeadNo == EHeadNo.Head1)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head2;
                                    }
                                    #endregion

                                    b_MovePanelGap = MovePanelGap(Line);//Cmd: WAIT

                                    if (GDefine.CameraType[(int)TaskVision.SelectedCam] == GDefine.ECameraType.PtGrey)
                                    {
                                        if (RunMode == ERunMode.Camera)
                                            TaskVision.PtGrey_CamLive(0);
                                    }

                                    DoWait(HeadNo, rt_SyncHead2, CmdList.Line[Line].IPara[0]);
                                    break;
                                }
                            #endregion

                            case ECmd.WAIT_START:
                                #region
                                {
                                    frm_ProgressReport frm = new frm_ProgressReport();
                                    frm.Message = "Waiting for Start Button...";
                                    frm.Enable_StartButton = true;
                                    if (frm.ShowDialog() == DialogResult.Cancel) goto _EndBoard;
                                    break;
                                }
                            #endregion
                            case ECmd.VOL_SET_DOTS:
                                #region
                                {
                                    if (!SetDotsVol()) goto _Pause;
                                    break;
                                }
                            #endregion
                            case ECmd.PP_VOL_SET_SPEED:
                                #region
                                {
                                    if (!SetPatternSpeed()) goto _Pause;
                                    break;
                                }
                            #endregion
                            case ECmd.PURGE:
                                #region
                                {
                                    EMsg = Msg + " PURGE";

                                    if (!b_InLoop && !Running) goto _Pause;
                                    if (b_SecondHalf || b_IsNeedle2) break;

                                    TConditions Conds = new TConditions(Line, ActiveLine);
                                    if (!Conds.IsTrue) break;
                                    ExecutedLines.Add(Line);

                                    b_Flag_ConsecutiveUnit = false;

                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                        if (rt_Head2MapBin >= EMapBin.BinNG) break;
                                        else
                                    if (rt_Head1MapBin >= EMapBin.BinNG) break;

                                    int Time = ActiveLine.IPara[0];
                                    int Delay = ActiveLine.IPara[1];
                                    int Count = ActiveLine.IPara[2];
                                    int PostVacTime = ActiveLine.IPara[3];

                                    EHeadNo HeadNo = EHeadNo.Head1;
                                    if (rt_SyncHead2) HeadNo = EHeadNo.Head12;
                                    #region Force Head Operation
                                    if (b_ForceHead1)
                                    {
                                        if (HeadNo == EHeadNo.Head2)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head1;
                                    }
                                    if (b_ForceHead2)
                                    {
                                        if (GDefine.HeadConfig != GDefine.EHeadConfig.Dual || DispProg.Head_Operation == TaskDisp.EHeadOperation.Single)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head2;
                                    }
                                    #endregion
                                    bool b_Head1 = (HeadNo == EHeadNo.Head1 || HeadNo == EHeadNo.Head12);
                                    bool b_Head2 = (HeadNo == EHeadNo.Head2 || HeadNo == EHeadNo.Head12);

                                    if (Count == 0)
                                    {
                                        if (!TaskDisp.TaskPurgeNeedle(b_Head1, b_Head2, RunMode == ERunMode.Normal)) goto _Error;
                                    }
                                    else
                                    {
                                        if (!TaskDisp.TaskPurgeNeedle(b_Head1, b_Head2, RunMode == ERunMode.Normal, true, Time, Delay, Count, PostVacTime)) goto _Error;
                                    }
                                    TaskDisp.FPressOn(new bool[2] { true, TaskDisp.Head_Operation == TaskDisp.EHeadOperation.Sync });
                                    break;
                                }
                            #endregion
                            case ECmd.CLEAN:
                                #region
                                {
                                    EMsg = Msg + " CLEAN";

                                    if (!b_InLoop && !Running) goto _Pause;
                                    if (b_SecondHalf || b_IsNeedle2) break;

                                    TConditions Conds = new TConditions(Line, ActiveLine);
                                    if (!Conds.IsTrue) break;
                                    ExecutedLines.Add(Line);

                                    b_Flag_ConsecutiveUnit = false;
                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                        if (rt_Head2MapBin >= EMapBin.BinNG) break;
                                        else
                                    if (rt_Head1MapBin >= EMapBin.BinNG) break;

                                    int Time = ActiveLine.IPara[0];
                                    int Delay = ActiveLine.IPara[1];
                                    int Count = ActiveLine.IPara[2];
                                    int PostVacTime = ActiveLine.IPara[3];

                                    EHeadNo HeadNo = EHeadNo.Head1;
                                    if (rt_SyncHead2) HeadNo = EHeadNo.Head12;
                                    #region Force Head Operation
                                    if (b_ForceHead1)
                                    {
                                        if (HeadNo == EHeadNo.Head2)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head1;
                                    }
                                    if (b_ForceHead2)
                                    {
                                        if (GDefine.HeadConfig != GDefine.EHeadConfig.Dual || DispProg.Head_Operation == TaskDisp.EHeadOperation.Single)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head2;
                                    }
                                    #endregion
                                    bool b_Head1 = (HeadNo == EHeadNo.Head1 || HeadNo == EHeadNo.Head12);
                                    bool b_Head2 = (HeadNo == EHeadNo.Head2 || HeadNo == EHeadNo.Head12);

                                    if (Count == 0)
                                    {
                                        if (!TaskDisp.TaskCleanNeedle(b_Head1, b_Head2, RunMode == ERunMode.Normal)) goto _Error;
                                    }
                                    else
                                    {
                                        if (!TaskDisp.TaskCleanNeedle(b_Head1, b_Head2, RunMode == ERunMode.Normal, true, Time, Delay, Count, PostVacTime)) goto _Error;
                                    }
                                    TaskDisp.FPressOn(new bool[2] { true, TaskDisp.Head_Operation == TaskDisp.EHeadOperation.Sync });
                                    break;
                                }
                            #endregion
                            case ECmd.PURGE_DOT:
                                #region
                                {
                                    EMsg = Msg + " PURGEDOT";

                                    if (!b_InLoop && !Running) goto _Pause;

                                    TConditions Conds = new TConditions(Line, ActiveLine);
                                    if (!Conds.IsTrue) break;
                                    ExecutedLines.Add(Line);

                                    b_Flag_ConsecutiveUnit = false;
                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                        if (rt_Head2MapBin >= EMapBin.BinNG) break;
                                        else
                                    if (rt_Head1MapBin >= EMapBin.BinNG) break;

                                    TaskVision.LightingOn(TaskVision.DefLightRGB);

                                    #region assign position
                                    double dx = 0;//CmdList.Line[Line].PosX[0];
                                    double dy = 0;//CmdList.Line[Line].PosY[0];
                                    double dz = 0;//CmdList.Line[Line].PosZ[0];

                                    double dx2 = 0;//dx + CmdList.Line[Line].PosX[1] - TaskDisp.Head2_DefPos.X + TaskDisp.Head2_DefDistX;
                                    double dy2 = 0;//dy + CmdList.Line[Line].PosY[2] - TaskDisp.Head2_DefPos.Y;
                                    double dz2 = 0;//CmdList.Line[Line].PosZ[2];
                                    if (ActiveLine.IPara[4] == 0)//Position = Auto
                                    {
                                        dx = TaskDisp.Needle_Purge_Pos[0].X;
                                        dy = TaskDisp.Needle_Purge_Pos[0].Y;
                                        dz = TaskDisp.Needle_Purge_Pos[0].Z;

                                        dx2 = TaskDisp.Needle_Purge_Pos[1].X;
                                        dy2 = TaskDisp.Needle_Purge_Pos[1].Y;
                                        dz2 = TaskDisp.Needle_Purge_Pos[1].Z;
                                    }
                                    else//Position = Manual
                                    {
                                        dx = CmdList.Line[Line].X[0];
                                        dy = CmdList.Line[Line].Y[0];
                                        dz = CmdList.Line[Line].Z[0];

                                        dx2 = CmdList.Line[Line].X[1];
                                        dy2 = CmdList.Line[Line].Y[1];
                                        dz2 = CmdList.Line[Line].Z[1];
                                    }
                                    dz = dz + TaskDisp.Head_Ofst[0].Z;
                                    dz2 = dz2 + TaskDisp.Head_Ofst[1].Z;
                                    //double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z));
                                    //double dz2 = dz + ZDiff;
                                    #endregion

                                    EHeadNo HeadNo = (EHeadNo)CmdList.Line[Line].ID;
                                    #region Force Head Operation
                                    if (b_ForceHead1)
                                    {
                                        if (HeadNo == EHeadNo.Head2)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head1;
                                    }
                                    if (b_ForceHead2)
                                    {
                                        if (GDefine.HeadConfig != GDefine.EHeadConfig.Dual || DispProg.Head_Operation == TaskDisp.EHeadOperation.Single)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head2;
                                    }
                                    #endregion

                                    if (!DoPurgeDot(ActiveLine, HeadNo, RunMode, dx, dy, dz, dx2, dy2, dz2))
                                    {
                                        Running = false;
                                    }

                                    break;
                                }
                            #endregion
                            case ECmd.PURGE_STAGE:
                                #region
                                {
                                    EMsg = Msg + " PURGE_STAGE";

                                    if (!b_InLoop && !Running) goto _Pause;
                                    if (b_SecondHalf || b_IsNeedle2) break;

                                    b_Flag_ConsecutiveUnit = false;
                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                        if (rt_Head2MapBin >= EMapBin.BinNG) break;
                                        else
                                    if (rt_Head1MapBin >= EMapBin.BinNG) break;

                                    if (!TaskDisp.PurgeStage.Execute(PurgeStage.Count)) goto _Pause;
                                    break;
                                }
                            #endregion
                            case ECmd.WIPE_STAGE:
                                #region
                                {
                                    EMsg = Msg + " WIPE_STAGE";

                                    if (!b_InLoop && !Running) goto _Pause;
                                    if (b_SecondHalf || b_IsNeedle2) break;

                                    TConditions Conds = new TConditions(Line, ActiveLine);
                                    if (!Conds.IsTrue) break;
                                    ExecutedLines.Add(Line);

                                    b_Flag_ConsecutiveUnit = false;
                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                        if (rt_Head2MapBin >= EMapBin.BinNG) break;
                                        else
                                    if (rt_Head1MapBin >= EMapBin.BinNG) break;

                                    if (!TaskDisp.WipeStage.Execute(true, false)) goto _Pause;
                                    if (DispProg.rt_SyncHead2)
                                        if (!TaskDisp.WipeStage.Execute(false, true)) goto _Pause;
                                    break;
                                }
                            #endregion
                            #region GO_PMAINT
                            case ECmd.GO_PMAINT:
                                {
                                    EMsg = Msg + " GO_PMAINT";

                                    if (!b_InLoop && !Running) goto _Pause;

                                    b_Flag_ConsecutiveUnit = false;

                                    if (!TaskDisp.TaskGotoPMaint()) goto _Error;
                                    break;
                                }
                            #endregion
                            #region GO_MMAINT
                            case ECmd.GO_MMAINT:
                                {
                                    EMsg = Msg + " GO_MMAINT";

                                    if (!b_InLoop && !Running) goto _Pause;

                                    b_Flag_ConsecutiveUnit = false;

                                    if (!TaskDisp.TaskGotoMMaint()) goto _Error;
                                    break;
                                }
                            #endregion
                            #region GO_POS
                            case ECmd.GO_POS:
                                {
                                    EMsg = Msg + " GO_POS";

                                    if (!b_InLoop && !Running) goto _Pause;

                                    b_Flag_ConsecutiveUnit = false;


                                    double X = CmdList.Line[Line].X[0];
                                    double Y = CmdList.Line[Line].Y[0];
                                    double Z = CmdList.Line[Line].Z[0];
                                    double X2 = CmdList.Line[Line].X[1];
                                    double Y2 = CmdList.Line[Line].Y[1];
                                    double Z2 = CmdList.Line[Line].Z[1];

                                    if (!TaskDisp.TaskGotoPos(X, Y, Z, X2, Y2, Z2)) goto _Error;
                                    break;
                                }
                            #endregion
                            #region DELAY
                            case ECmd.DELAY:
                                {
                                    EMsg = Msg + " DELAY";

                                    if (!b_InLoop && !Running) goto _Pause;

                                    DoDelay(CmdList.Line[Line].IPara[0]);
                                    break;
                                }
                            #endregion

                            case ECmd.WEIGHT_CAL:
                                {
                                    if (!b_InLoop && !Running) goto _Pause;
                                    if (b_SecondHalf || b_IsNeedle2) break;

                                    TConditions Conds = new TConditions(Line, ActiveLine);
                                    if (!Conds.IsTrue) break;
                                    ExecutedLines.Add(Line);

                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                        if (rt_Head2MapBin >= EMapBin.BinNG) break;
                                        else
                                    if (rt_Head1MapBin >= EMapBin.BinNG) break;

                                    EHeadNo HeadNo = EHeadNo.Head1;
                                    if (rt_SyncHead2) HeadNo = EHeadNo.Head12;
                                    #region Force Head Operation
                                    if (b_ForceHead1)
                                    {
                                        if (HeadNo == EHeadNo.Head2)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head1;
                                    }
                                    if (b_ForceHead2)
                                    {
                                        if (GDefine.HeadConfig != GDefine.EHeadConfig.Dual || DispProg.Head_Operation == TaskDisp.EHeadOperation.Single)
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                                            goto _Error;
                                        }
                                        HeadNo = EHeadNo.Head2;
                                    }
                                    #endregion
                                    bool b_Head1 = (HeadNo == EHeadNo.Head1 || HeadNo == EHeadNo.Head12);
                                    bool b_Head2 = (HeadNo == EHeadNo.Head2 || HeadNo == EHeadNo.Head12);


                                    frm_DispCore_WeightCal frm = new frm_DispCore_WeightCal();
                                    frm.CalMode = frm_DispCore_WeightCal.ECalMode.Auto;
                                    if (b_Head1) frm.AddHead(TaskWeight.EHeadNo.One);
                                    if (b_Head2) frm.AddHead(TaskWeight.EHeadNo.Two);

                                    frm.BringToFront();
                                    frm.TopMost = true;
                                    DialogResult dr = frm.ShowDialog();

                                    TaskDisp.FPressOn(new bool[2] { true, TaskDisp.Head_Operation == TaskDisp.EHeadOperation.Sync });

                                    switch (dr)
                                    {
                                        case DialogResult.OK:
                                            break;
                                        case DialogResult.Abort://Error
                                            goto _Error;
                                        case DialogResult.Cancel://Stop
                                        default:
                                            goto _Pause;
                                    }
                                    break;
                                }

                            case ECmd.PP_FILL:
                            case ECmd.PP_RECYCLE_B:
                            case ECmd.PP_RECYCLE_N:
                            case ECmd.PP_CLEANFILL:
                                #region
                                {
                                    EMsg = Msg + " " + ((ECmd)CmdList.Line[Line].Cmd).ToString();

                                    if (!b_InLoop && !Running) goto _Pause;
                                    if (b_SecondHalf || b_IsNeedle2) break;

                                    TConditions Conds = new TConditions(Line, ActiveLine);
                                    if (!Conds.IsTrue) break;
                                    ExecutedLines.Add(Line);

                                    b_Flag_ConsecutiveUnit = false;

                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                        if (rt_Head2MapBin >= EMapBin.BinNG) break;
                                        else
                                    if (rt_Head1MapBin >= EMapBin.BinNG) break;


                                    switch (CmdList.Line[Line].Cmd)
                                    {
                                        case ECmd.PP_CLEANFILL:
                                            if (!TaskDisp.TaskGotoTPos2(TaskDisp.Needle_Flush_Pos)) goto _Error;
                                            if (!TaskDisp.DoCleanFill(true, rt_SyncHead2)) goto _Error;
                                            if (!TaskDisp.CtrlWaitResponse(true, rt_SyncHead2)) goto _Error;
                                            if (!TaskDisp.CtrlWaitReady(true, rt_SyncHead2)) goto _Error;
                                            break;
                                        case ECmd.PP_FILL:
                                            if (!TaskDisp.TaskGotoTPos2(TaskDisp.Needle_Clean_Pos)) goto _Error;
                                            if (!TaskDisp.DoFill(true, rt_SyncHead2)) goto _Error;
                                            Thread.Sleep(50);
                                            if (!TaskDisp.CtrlWaitResponse(true, rt_SyncHead2)) goto _Error;
                                            if (!TaskDisp.CtrlWaitReady(true, rt_SyncHead2)) goto _Error;
                                            break;
                                        case ECmd.PP_RECYCLE_B:
                                            {
                                                if (!TaskDisp.TaskGotoTPos2(TaskDisp.Needle_Clean_Pos)) goto _Error;
                                                int Count = ActiveLine.IPara[2];
                                                TaskDisp.ERecycleMethod Method = (TaskDisp.ERecycleMethod)ActiveLine.IPara[3];
                                                for (int i = 0; i < Count; i++)
                                                {
                                                    if (!TaskDisp.RecycleBarrel(true, rt_SyncHead2, Method)) goto _Error;
                                                    if (!TaskDisp.CtrlWaitResponse(true, rt_SyncHead2)) goto _Error;
                                                    if (!TaskDisp.CtrlWaitReady(true, rt_SyncHead2)) goto _Error;
                                                }
                                                break;
                                            }
                                        case ECmd.PP_RECYCLE_N:
                                            {
                                                if (!TaskDisp.TaskGotoTPos2(TaskDisp.Needle_Clean_Pos)) goto _Error;
                                                int Count = ActiveLine.IPara[2];
                                                if (!TaskDisp.RecycleNeedle(true, rt_SyncHead2, Count)) goto _Error;
                                                if (!TaskDisp.CtrlWaitResponse(true, rt_SyncHead2)) goto _Error;
                                                if (!TaskDisp.CtrlWaitReady(true, rt_SyncHead2)) goto _Error;
                                                break;
                                            }
                                    }
                                    break;
                                }
                            #endregion
                            case ECmd.PP_VOL_COMP:
                                #region
                                {
                                    EMsg = Msg + " " + ((ECmd)CmdList.Line[Line].Cmd).ToString();

                                    TConditions Conds = new TConditions(Line, ActiveLine);
                                    if (!Conds.IsTrue) break;
                                    ExecutedLines.Add(Line);

                                    if (!PP_VolComp.Do(ActiveLine))
                                    {
                                        Running = false;
                                    }

                                    break;
                                }
                            #endregion

                            case ECmd.PP_VOL_ADJRESET:
                                #region
                                {
                                    EMsg = Msg + " " + ((ECmd)CmdList.Line[Line].Cmd).ToString();

                                    //TConditions Conds = new TConditions(Line, ActiveLine);

                                    //if (Conds.IsDisabled) break;
                                    //if (Conds.IsNone)
                                    //{
                                    //    if (!rt_Cond) break;
                                    //}
                                    //else
                                    //{
                                    //    if (!Conds.IsTrue) break;
                                    //    ExecutedLines.Add(Line);
                                    //}

                                    PP_HeadA_DispVol_Adj = 0;//unit=ul
                                    PP_HeadB_DispVol_Adj = 0;//unit=ul

                                    break;
                                }
                            #endregion
                            case ECmd.PP_VOL_ADJINC:
                                #region
                                {
                                    EMsg = Msg + " " + ((ECmd)CmdList.Line[Line].Cmd).ToString();

                                    PP_HeadA_DispVol_Adj = PP_HeadA_DispVol_Adj + ActiveLine.DPara[0];//unit=ul
                                    PP_HeadB_DispVol_Adj = PP_HeadB_DispVol_Adj + ActiveLine.DPara[1];//unit=ul

                                    break;
                                }
                            #endregion

                            case ECmd.CREATE_MAP:
                                #region
                                {
                                    if (!b_InLoop && !Running) goto _Pause;

                                    EMsg = Msg + " CREATE_MAP";

                                    ECMMethod Method = (ECMMethod)ActiveLine.IPara[2];
                                    switch (Method)
                                    {
                                        case ECMMethod.Pattern:
                                            {
                                                List<VisUtils.EMatchResult> MatchResults = new List<VisUtils.EMatchResult>();
                                                CreateMatchMap(CmdList.Line[Line], TaskVision.BoardImage[ActiveLine.IPara[1]], MatchResults);
                                                GenerateMap(ActiveLine, rt_Layouts[rt_LayoutID], MatchResults, ref Map.CurrMap[rt_LayoutID].Bin);
                                                break;
                                            }
                                        case ECMMethod.Binary:
                                            {
                                                GenerateMap(ActiveLine, rt_Layouts[rt_LayoutID], TaskVision.BoardImage[ActiveLine.IPara[1]], ref Map.CurrMap[rt_LayoutID].Bin);
                                                break;
                                            }
                                    }

                                    double d_OKYield = ((double)rt_GenMap_OKCount / (rt_GenMap_OKCount + rt_GenMap_NGCount));
                                    if (d_OKYield < ActiveLine.DPara[4])
                                    {
                                        Msg MsgBox = new Msg();
                                        EMsgRes MsgRes = MsgBox.Show(ErrCode.CREATE_MAP_OKYIELD_OOS, EMcState.Warning, EMsgBtn.smbAll, false);

                                        switch (MsgRes)
                                        {
                                            #region
                                            case EMsgRes.smrRetry:
                                                for (int L = Line; L >= 0; L--)
                                                {
                                                    if (CmdList.Line[L].Cmd == ECmd.DO_BDCAPTURE)
                                                    {
                                                        //LastLine = L;
                                                        Line = L;
                                                        goto _Loop;
                                                    }
                                                }
                                                break;
                                            case EMsgRes.smrOK://accept and continue
                                                break;
                                            case EMsgRes.smrCancel://Reject
                                                BdStatus = EBoardStatus.Reject;
                                                goto _EndBoard;
                                            default://Stop
                                                for (int L = Line; L >= 0; L--)
                                                {
                                                    if (CmdList.Line[L].Cmd == ECmd.DO_BDCAPTURE)
                                                    {
                                                        LastLine = L;
                                                        break;
                                                    }
                                                }
                                                goto _Pause;
                                                #endregion
                                        }

                                    }
                                    break;
                                }
                            #endregion
                            case ECmd.INPUT_MAP:
                                #region
                                {
                                    if (!b_InLoop && !Running) goto _Pause;

                                    EMsg = Msg + " INPUT_MAP";

                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                    {
                                        if (rt_Head2MapBin >= EMapBin.BinNG) goto _End;
                                    }
                                    else
                                    {
                                        if (rt_Head1MapBin >= EMapBin.BinNG) goto _End;
                                    }

                                    bool lotStatus = LotInfo2.LotActive;
                                    string lotNo = LotInfo2.LotNumber;
                                    if (LotInfo2.Customer == LotInfo2.ECustomer.LUMDisp) lotNo = LotInfo2.Lmds.sMesLot;
                                    // LotNumber;// Reg.ReadKey("NSWAUTOMATION_LotInfo", "MES LOT", /*PRODUCT",*/ "Lot 0001");

                                    //if (LotStatus != null && LotStatus.StartsWith("Activated"))
                                    if (lotStatus)
                                    {
                                        if (lotNo.Length == 0)
                                        {
                                            Msg MsgBox = new Msg();
                                            EMsgRes MsgRes = MsgBox.Show("Invalid Lot No", EMcState.Warning, EMsgBtn.smbAll, false);
                                            goto _Pause;
                                        }
                                    }

                                    bool enableInputMap = ActiveLine.IPara[0] > 0;
                                    TaskDisp.InputMap_Enabled = enableInputMap;

                                    if (rt_Singulated)//  Lumileds singulated mode - only one unit in map
                                    {
                                        TMap map = new TMap(Map.CurrMap[rt_LayoutID]);
                                        if (!TInputMap.Execute(lotNo, rt_Read_IDs[ActiveLine.ID, RunTime.UIndex], ref map, enableInputMap))
                                        {
                                            Line = Line--;
                                            goto _Pause;
                                        }
                                        Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] = map.Bin[0];
                                    }
                                    else
                                    {
                                        if (!TInputMap.Execute(lotNo, rt_Read_IDs[ActiveLine.ID, RunTime.UIndex], ref Map.CurrMap[rt_LayoutID], enableInputMap))
                                        {
                                            Line = Line--;
                                            goto _Pause;
                                        }
                                    }

                                _End:
                                    break;
                                }
                            #endregion
                            case ECmd.USE_MAP:
                                #region
                                rt_Head1MapBin = Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex];
                                rt_Head2MapBin = Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex];

                                if (DispProg.Pump_Type == TaskDisp.EPumpType.PP2D)
                                {
                                    int Head1Needle2Index = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetNeedle2UnitNo(RunTime.UIndex, ref Head1Needle2Index);
                                    EMapBin rt_Head1BUnitMap = Map.CurrMap[rt_LayoutID].Bin[Head1Needle2Index];
                                    rt_Head1MapBin = (EMapBin)Math.Max((byte)rt_Head1MapBin, (byte)rt_Head1BUnitMap);
                                }

                                int Head2Index_ = 0;
                                bool IsValid_ = true;
                                if (rt_Layouts[rt_LayoutID].UnitNoGetHead2UnitNo(RunTime.UIndex, ref Head2Index_, ref IsValid_))
                                {
                                    rt_Head2MapBin = Map.CurrMap[rt_LayoutID].Bin[Head2Index_];

                                    if (DispProg.Pump_Type == TaskDisp.EPumpType.PP2D)
                                    {
                                        if (rt_SyncHead2 && b_InLoop)
                                        {
                                            int Head2Needle2Index = 0;
                                            rt_Layouts[rt_LayoutID].UnitNoGetNeedle2UnitNo(Head2Index_, ref Head2Needle2Index);
                                            EMapBin rt_Head2BUnitMap = Map.CurrMap[rt_LayoutID].Bin[Head2Needle2Index];
                                            rt_Head2MapBin = (EMapBin)Math.Max((byte)rt_Head2MapBin, (byte)rt_Head2BUnitMap);
                                        }
                                    }
                                }
                                break;
                            #endregion
                            case ECmd.UNIT_COMPLETE:
                            case ECmd.UNIT_CONTINUE:
                                #region
                                {
                                    fPoolVermes = true;

                                    EMsg = Msg + " UNIT_COMPLETE";

                                    bool unitComplete = CmdList.Line[Line].Cmd == ECmd.UNIT_COMPLETE;

                                    if (b_SecondHalf || b_IsNeedle2) break;

                                    if (rt_SyncHead2 && rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex)) break;

                                    if (DispProg.Pump_Type == TaskDisp.EPumpType.PP2D && rt_Layouts[rt_LayoutID].UnitNoIsNeedle2(RunTime.UIndex)) break;

                                    #region Statistic and Map Status
                                    Stats.UnitCount_Inc(0);
                                    if (DispProg.Pump_Type == TaskDisp.EPumpType.PP2D) Stats.UnitCount_Inc(0);
                                    if (rt_SyncHead2)
                                    {
                                        Stats.UnitCount_Inc(1);
                                        if (DispProg.Pump_Type == TaskDisp.EPumpType.PP2D) Stats.UnitCount_Inc(1);
                                    }
                                    if (Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] < EMapBin.BinNG)
                                    {
                                        Stats.Board.DispCounter[0]++;
                                        Stats.Board.DispCounter[1]++;
                                        Stats.Board.DispCounter[2]++;
                                        if (unitComplete)
                                            Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] = EMapBin.Complete;
                                        else
                                        {
                                            if (Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] < EMapBin.Continue1) Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] = EMapBin.Continue1;
                                            else
                                            if (Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] >= EMapBin.Continue8) Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] = EMapBin.Continue1;
                                            else
                                                Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex]++;
                                        }

                                        Stats.Board.ProcUnitCount[0]++;
                                        if (DispProg.Pump_Type == TaskDisp.EPumpType.PP2D) Stats.Board.ProcUnitCount[0]++;
                                        if (rt_SyncHead2)
                                        {
                                            Stats.Board.ProcUnitCount[1]++;
                                            if (DispProg.Pump_Type == TaskDisp.EPumpType.PP2D) Stats.Board.ProcUnitCount[1]++;
                                        }
                                    }

                                    //Head 2 Stats and Map Status
                                    if (DispProg.Pump_Type == TaskDisp.EPumpType.PP2D)
                                    {
                                        int Head1Needle2Index = 0;
                                        rt_Layouts[rt_LayoutID].UnitNoGetNeedle2UnitNo(RunTime.UIndex, ref Head1Needle2Index);
                                        if (Map.CurrMap[rt_LayoutID].Bin[Head1Needle2Index] < EMapBin.BinNG)
                                        {
                                            if (unitComplete) Map.CurrMap[rt_LayoutID].Bin[Head1Needle2Index] = EMapBin.Complete;
                                            else
                                            {
                                                if (Map.CurrMap[rt_LayoutID].Bin[Head1Needle2Index] < EMapBin.Continue1) Map.CurrMap[rt_LayoutID].Bin[Head1Needle2Index] = EMapBin.Continue1;
                                                else
                                                if (Map.CurrMap[rt_LayoutID].Bin[Head1Needle2Index] >= EMapBin.Continue8) Map.CurrMap[rt_LayoutID].Bin[Head1Needle2Index] = EMapBin.Continue1;
                                                else
                                                    Map.CurrMap[rt_LayoutID].Bin[Head1Needle2Index]++;
                                            }
                                        }
                                    }

                                    if (rt_SyncHead2)
                                    {
                                        int Head2Index = 0;
                                        bool IsValid = false;
                                        if (rt_Layouts[rt_LayoutID].UnitNoGetHead2UnitNo(RunTime.UIndex, ref Head2Index, ref IsValid))
                                        {
                                            if (Map.CurrMap[rt_LayoutID].Bin[Head2Index] < EMapBin.BinNG)
                                            {
                                                if (unitComplete) Map.CurrMap[rt_LayoutID].Bin[Head2Index] = EMapBin.Complete;
                                                else
                                                {
                                                    if (Map.CurrMap[rt_LayoutID].Bin[Head2Index] < EMapBin.Continue1) Map.CurrMap[rt_LayoutID].Bin[Head2Index] = EMapBin.Continue1;
                                                    else
                                                    if (Map.CurrMap[rt_LayoutID].Bin[Head2Index] >= EMapBin.Continue8) Map.CurrMap[rt_LayoutID].Bin[Head2Index] = EMapBin.Continue1;
                                                    else
                                                        Map.CurrMap[rt_LayoutID].Bin[Head2Index]++;
                                                }

                                            }
                                            if (DispProg.Pump_Type == TaskDisp.EPumpType.PP2D)
                                            {
                                                int Head2Needle2Index = 0;
                                                rt_Layouts[rt_LayoutID].UnitNoGetNeedle2UnitNo(Head2Index, ref Head2Needle2Index);
                                                if (Map.CurrMap[rt_LayoutID].Bin[Head2Needle2Index] < EMapBin.BinNG)
                                                {
                                                    if (unitComplete) Map.CurrMap[rt_LayoutID].Bin[Head2Needle2Index] = EMapBin.Complete;
                                                    else
                                                    {
                                                        if (Map.CurrMap[rt_LayoutID].Bin[Head2Needle2Index] < EMapBin.Continue1) Map.CurrMap[rt_LayoutID].Bin[Head2Needle2Index] = EMapBin.Continue1;
                                                        else
                                                        if (Map.CurrMap[rt_LayoutID].Bin[Head2Needle2Index] >= EMapBin.Continue8) Map.CurrMap[rt_LayoutID].Bin[Head2Needle2Index] = EMapBin.Continue1;
                                                        else
                                                            Map.CurrMap[rt_LayoutID].Bin[Head2Needle2Index]++;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    #endregion

                                    if (CmdList.Line[Line].Cmd == ECmd.UNIT_COMPLETE)
                                    {
                                        switch (RunMode)
                                        {
                                            case ERunMode.Normal:
                                                if (PurgeStage.Interval > 0)
                                                {
                                                    if (Stats.Board.UnitCount[0] % PurgeStage.Interval == 0)
                                                        if (!TaskDisp.PurgeStage.Execute(PurgeStage.Count)) goto _Pause;
                                                }
                                                break;
                                            default:
                                                break;
                                        }

                                        if (TaskDisp.InputMap_Protocol == TaskDisp.EInputMapProtocol.TD_COB)
                                        {
                                            if (TaskDisp.InputMap_Enabled && Task_InputMap.TD_COB.MapDB_QueryIsOK)
                                            {
                                                if (Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] == EMapBin.Complete)
                                                    Task_InputMap.TD_COB.MapDB_UpdateSerialNo(rt_Read_IDs[0, 0], RunTime.UIndex, true);

                                                int i_Head2_UIndex = 0;
                                                bool IsValid = false;
                                                rt_Layouts[rt_LayoutID].UnitNoGetHead2UnitNo(RunTime.UIndex, ref i_Head2_UIndex, ref IsValid);
                                                if (Map.CurrMap[rt_LayoutID].Bin[i_Head2_UIndex] == EMapBin.Complete)
                                                    Task_InputMap.TD_COB.MapDB_UpdateSerialNo(rt_Read_IDs[0, 0], RunTime.UIndex2, true);
                                            }
                                        }

                                        if (TaskDisp.Preference == TaskDisp.EPreference.Unisem && TaskDisp.SECSGEMProtocol == TaskDisp.ESECSGEMProtocol.SECSGEMConnect2 && GDefine.sgc2.EnableUploadStripMapE142)
                                        {
                                            int C = 0; int R = 0;
                                            try
                                            {
                                                rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref C, ref R);
                                            }
                                            catch
                                            {
                                            }
                                            Map.CurrMap[rt_LayoutID].AppendInProcess(GDefine.StripMapDir.FullName + rt_Read_IDs[0, 0] + ".txt", RunTime.UIndex, new Point(C, R));
                                        }
                                    }
                                }
                                break;
                            #endregion
                            case ECmd.EXT_VISION:
                                #region
                                {
                                    if (!b_InLoop && !Running) goto _Pause;

                                    int t = GDefine.GetTickCount();

                                    EMsg = Msg + " EXT_VISION";

                                    Exec_ExtVision(ActiveLine, f_origin_x, f_origin_y, f_origin_z);
                                    break;
                                }
                            #endregion;
                            case ECmd.NEEDLE_INSP:
                                #region
                                {
                                    EMsg = Msg + " " + ((ECmd)CmdList.Line[Line].Cmd).ToString();

                                    if (!b_InLoop && !Running) goto _Pause;
                                    if (b_SecondHalf || b_IsNeedle2) break;

                                    TConditions Conds = new TConditions(Line, ActiveLine);
                                    if (!Conds.IsTrue) break;
                                    ExecutedLines.Add(Line);

                                    b_Flag_ConsecutiveUnit = false;

                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                        if (rt_Head2MapBin >= EMapBin.BinNG) break;
                                        else
                                    if (rt_Head1MapBin >= EMapBin.BinNG) break;

                                    int Time = ActiveLine.IPara[0];
                                    int Delay = ActiveLine.IPara[1];
                                    int Count = ActiveLine.IPara[2];
                                    int PostVacTime = ActiveLine.IPara[3];

                                    EHeadNo HeadNo = EHeadNo.Head1;
                                    if (rt_SyncHead2) HeadNo = EHeadNo.Head12;

                                    bool b_Head1 = (HeadNo == EHeadNo.Head1 || HeadNo == EHeadNo.Head12);
                                    bool b_Head2 = (HeadNo == EHeadNo.Head2 || HeadNo == EHeadNo.Head12);

                                    if (b_Head1)
                                        if (!TaskDisp.TaskNeedleInsp(1))
                                        {
                                            Line--;
                                            goto _Pause;
                                        }
                                    if (b_Head2)
                                    {
                                        if (!TaskDisp.TaskNeedleInsp(2))
                                        {
                                            Line--;
                                            goto _Pause;
                                        }
                                    }
                                    break;
                                }
                            #endregion;

                            case ECmd.BD_READY:
                                #region
                                CheckBoardYieldPrompt();

                                BdReady = true;
                                Define_Run.UpdateProcessStatus_BdReady();
                                break;
                            #endregion
                            case ECmd.MEASL_WH:
                                #region
                                {
                                    b_Flag_ConsecutiveUnit = false;

                                    EMsg = Msg + " MEASL_WH";

                                    int MeasID = ActiveLine.ID;

                                    TaskVision.LightingOff();

                                    #region assign and translate pt
                                    double dx1 = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[0];
                                    double dy1 = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[0];
                                    //double dz = f_origin_z;
                                    TranslatePos(dx1, dy1, rt_Head1RefData, ref dx1, ref dy1);

                                    double dx2 = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[1];
                                    double dy2 = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[1];
                                    //double dz = f_origin_z;
                                    TranslatePos(dx2, dy2, rt_Head1RefData, ref dx2, ref dy2);
                                    #endregion

                                    double MSpeed = ActiveLine.DPara[0];

                                    if (GDefine.CameraType[(int)TaskVision.SelectedCam] == GDefine.ECameraType.PtGrey)
                                    {
                                        if (RunMode == ERunMode.Camera)
                                            TaskVision.PtGrey_CamLive(0);
                                        //TaskVision.ptGPtGrey_CamLive((int)TaskVision.SelectedCam);
                                    }


                                    TaskMeasure.WHData WHData = new TaskMeasure.WHData();
                                    if (!TaskMeasure.MeasL_WH(ref WHData, dx1, dy1, dx2, dy2, MSpeed)) goto _Error;
                                    rt_MeasL_HData.Add(WHData.Height());

                                    break;
                                }
                            #endregion
                            case ECmd.MEASL_H:
                                #region
                                {
                                    b_Flag_ConsecutiveUnit = false;

                                    EMsg = Msg + " MEASL_H";

                                    int MeasID = ActiveLine.ID;

                                    TaskVision.LightingOff();

                                    #region assign and translate pt
                                    double dx1 = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[0];
                                    double dy1 = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[0];
                                    TranslatePos(dx1, dy1, rt_Head1RefData, ref dx1, ref dy1);

                                    double dx2 = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[1];
                                    double dy2 = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[1];
                                    TranslatePos(dx2, dy2, rt_Head1RefData, ref dx2, ref dy2);
                                    #endregion

                                    int SettleTime = ActiveLine.IPara[4];

                                    TaskMeasureH.MeasL_H_Profile rt_HProfile = new TaskMeasureH.MeasL_H_Profile();
                                    TaskMeasureH.MeasL_H_Data rt_HData = new TaskMeasureH.MeasL_H_Data();

                                    int Col = 0;
                                    int Row = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref Col, ref Row);
                                    rt_HData.Col = Col + 1;
                                    rt_HData.Row = Row + 1;

                                    if (GDefine.CameraType[(int)TaskVision.SelectedCam] == GDefine.ECameraType.PtGrey)
                                    {
                                        if (RunMode == ERunMode.Camera)
                                            TaskVision.PtGrey_CamLive(0);
                                    }

                                    if (!TaskMeasureH.MeasL_H(ActiveLine, ref rt_HProfile, ref rt_HData, dx1, dy1, dx2, dy2)) goto _Error;
                                    rt_HDataArr.Add(rt_HData);

                                    break;
                                }
                            #endregion
                            case ECmd.MEAS_MENISCUS:
                                #region
                                {
                                    EMsg = Msg + " " + ((ECmd)CmdList.Line[Line].Cmd).ToString();

                                    if (!b_InLoop && !Running) goto _Pause;

                                    //in dispense dual head mode, need to check Head B.
                                    bool b_VrfyMode = false;
                                    int i_LastDispCmd = 0;
                                    for (int i = Line - 1; i > 0; i--)
                                    {
                                        if (CmdList.Line[i].Cmd >= ECmd.DOT && CmdList.Line[i].Cmd < ECmd.VOL_SET_DOTS)
                                        {
                                            b_VrfyMode = true;
                                            i_LastDispCmd = i;
                                            break;
                                        }
                                        if (CmdList.Line[i].Cmd == ECmd.FOR_LAYOUT) break;
                                    }

                                    bool[] b_HeadRun = new bool[2] { true, false };
                                    if (b_VrfyMode)
                                    {
                                        bool b_Head2IsValid = false;
                                        bool b_SyncHead2 = false;
                                        SelectHead(CmdList.Line[i_LastDispCmd], ref b_HeadRun, ref b_Head2IsValid, ref b_SyncHead2);
                                    }

                                    if (b_VrfyMode && b_SecondHalf) break;
                                    if (b_IsNeedle2) break;

                                    TConditions Conds = new TConditions(Line, ActiveLine);
                                    if (!Conds.IsTrue) break;
                                    ExecutedLines.Add(Line);

                                    b_Flag_ConsecutiveUnit = false;

                                    if (rt_Layouts[rt_LayoutID].UnitNoIsHead2(RunTime.UIndex))
                                    {
                                        if (rt_Head2MapBin >= EMapBin.BinNG) goto _End;
                                    }
                                    else
                                      if (rt_Head1MapBin >= EMapBin.BinNG) goto _End;

                                    TaskVision.LightingOff();

                                    int i_StartDelay = ActiveLine.IPara[3];
                                    int SettleTime = ActiveLine.IPara[4];

                                    TaskMeasMen.MeasL_H_Profile rt_Profile = new TaskMeasMen.MeasL_H_Profile();
                                    TaskMeasMen.Data rt_Data = new TaskMeasMen.Data();
                                    TaskMeasMen.MeasL_H_Profile rt_Profile2 = new TaskMeasMen.MeasL_H_Profile();
                                    TaskMeasMen.Data rt_Data2 = new TaskMeasMen.Data();

                                    double d_MeniscusSpec = ActiveLine.DPara[5];
                                    double d_MeniscusTol = ActiveLine.DPara[6];

                                    if (b_VrfyMode && (b_HeadRun[0] || b_HeadRun[1]))
                                    {
                                        int t = GDefine.GetTickCount() + i_StartDelay;
                                        while (GDefine.GetTickCount() <= t) Thread.Sleep(1);
                                    }

                                    if (b_HeadRun[0])
                                    {
                                        #region assign and translate pt
                                        double dx1 = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[0];
                                        double dy1 = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[0];
                                        TranslatePos(dx1, dy1, rt_Head1RefData, ref dx1, ref dy1);

                                        double dx2 = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[1];
                                        double dy2 = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[1];
                                        TranslatePos(dx2, dy2, rt_Head1RefData, ref dx2, ref dy2);

                                        double dx3 = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[2];
                                        double dy3 = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[2];
                                        TranslatePos(dx3, dy3, rt_Head1RefData, ref dx3, ref dy3);
                                        #endregion

                                        #region HeadA
                                        int Col = 0; int Row = 0; int CCol = 0; int CRow = 0;
                                        rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref Col, ref Row, ref CCol, ref CRow);
                                        rt_Data.Index = RunTime.UIndex;
                                        rt_Data.Col = Col + 1;
                                        rt_Data.Row = Row + 1;
                                        rt_Data.CCol = CCol + 1;
                                        rt_Data.CRow = CRow + 1;

                                        if (!TaskMeasMen.Execute(ActiveLine, ref rt_Profile, ref rt_Data, dx1, dy1, dx2, dy2, dx3, dy3)) goto _Error;

                                        rt_MeniscusDatas.Add(rt_Data);

                                        //NSW.Net.RegistryUtils Reg = new RegistryUtils();
                                        //string LotNo = Reg.ReadKey("NSWAUTOMATION_LotInfo", "MES LOT", "");
                                        string LotNo = LotInfo2.LotNumber;
                                        if (LotInfo2.Customer == LotInfo2.ECustomer.LUMDisp) LotNo = LotInfo2.Lmds.sMesLot;

                                        rt_Data.Save(LotNo, rt_Read_IDs[0, 0], "HeadA");

                                        if (d_MeniscusSpec != 0)
                                        {
                                            Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] = EMapBin.CompleteOK;
                                            if (rt_Data.Height < d_MeniscusSpec - d_MeniscusTol || rt_Data.Height > d_MeniscusSpec + d_MeniscusTol)
                                            {
                                                Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] = EMapBin.CompleteNG;

                                                i_MeniContOOSCntr++;
                                                if (i_MeniContOOSCntr >= ActiveLine.IPara[5])
                                                {
                                                    i_MeniContOOSCntr = 0;

                                                    Msg MsgBox = new Msg();
                                                    EMsgRes MsgRes = MsgBox.Show("Meniscus Continuous Out Of Spec.",
                                                        "Head A: Spec = " + d_MeniscusSpec.ToString("f3") + " +/-" + d_MeniscusTol.ToString("F3") + " Measured " + rt_Data.Height.ToString("f3") + ".@OK - Accept and Continue.",
                                                        "",
                                                        EMcState.Warning, EMsgBtn.smbOK_Stop, false);

                                                    switch (MsgRes)
                                                    {
                                                        case EMsgRes.smrOK:
                                                            break;
                                                        default:
                                                            Line++;
                                                            goto _Pause;
                                                    }
                                                }
                                            }
                                        }
                                        #endregion
                                    }

                                    if (b_VrfyMode && b_HeadRun[1])
                                    {
                                        #region assign and translate pt
                                        double dx1 = f_origin_x + rt_Layout_Rel_X2 + CmdList.Line[Line].X[0];
                                        double dy1 = f_origin_y + rt_Layout_Rel_Y2 + CmdList.Line[Line].Y[0];
                                        TranslatePos(dx1, dy1, rt_Head1RefData, ref dx1, ref dy1);

                                        double dx2 = f_origin_x + rt_Layout_Rel_X2 + CmdList.Line[Line].X[1];
                                        double dy2 = f_origin_y + rt_Layout_Rel_Y2 + CmdList.Line[Line].Y[1];
                                        TranslatePos(dx2, dy2, rt_Head1RefData, ref dx2, ref dy2);

                                        double dx3 = f_origin_x + rt_Layout_Rel_X2 + CmdList.Line[Line].X[2];
                                        double dy3 = f_origin_y + rt_Layout_Rel_Y2 + CmdList.Line[Line].Y[2];
                                        TranslatePos(dx3, dy3, rt_Head1RefData, ref dx3, ref dy3);
                                        #endregion

                                        #region HeadB
                                        int Col = 0; int Row = 0; int CCol = 0; int CRow = 0;
                                        rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex2, ref Col, ref Row, ref CCol, ref CRow);
                                        rt_Data2.Index = RunTime.UIndex2;
                                        rt_Data2.Col = Col + 1;
                                        rt_Data2.Row = Row + 1;
                                        rt_Data2.CCol = CCol + 1;
                                        rt_Data2.CRow = CRow + 1;

                                        if (!TaskMeasMen.Execute(ActiveLine, ref rt_Profile2, ref rt_Data2, dx1, dy1, dx2, dy2, dx3, dy3)) goto _Error;

                                        rt_MeniscusDatas.Add(rt_Data2);

                                        //NSW.Net.RegistryUtils Reg = new RegistryUtils();
                                        //string LotNo = Reg.ReadKey("NSWAUTOMATION_LotInfo", "MES LOT", "");
                                        //string LotNo = LotInfo2.Lmds.sMesLot;
                                        string LotNo = LotInfo2.LotNumber;
                                        if (LotInfo2.Customer == LotInfo2.ECustomer.LUMDisp) LotNo = LotInfo2.Lmds.sMesLot;
                                        rt_Data2.Save(LotNo, rt_Read_IDs[0, 0], "HeadB");

                                        if (d_MeniscusSpec != 0)
                                        {
                                            Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex2] = EMapBin.CompleteOK;
                                            if (rt_Data.Height < d_MeniscusSpec - d_MeniscusTol || rt_Data.Height > d_MeniscusSpec + d_MeniscusTol)
                                            {
                                                i_MeniContOOSCntr++;
                                                if (i_MeniContOOSCntr >= ActiveLine.IPara[5])
                                                {
                                                    i_MeniContOOSCntr = 0;

                                                    Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex2] = EMapBin.CompleteNG;

                                                    Msg MsgBox = new Msg();
                                                    EMsgRes MsgRes = MsgBox.Show("Meniscus Continuous Out Of Spec.",
                                                        "Head B: Spec = " + d_MeniscusSpec.ToString("f3") + " +/-" + d_MeniscusTol.ToString("F3") + " Measured " + rt_Data.Height.ToString("f3") + ".@OK - Accept and Continue.",
                                                        "",
                                                        EMcState.Warning, EMsgBtn.smbOK_Stop, false);

                                                    switch (MsgRes)
                                                    {
                                                        case EMsgRes.smrOK:
                                                            break;
                                                        default:
                                                            Line++;
                                                            goto _Pause;
                                                    }
                                                }
                                            }
                                        }
                                        #endregion
                                    }
                                _End:
                                    break;
                                }
                            #endregion
                            case ECmd.CHECK_MENISCUS:
                                #region
                                {
                                    EMsg = Msg + " " + ((ECmd)CmdList.Line[Line].Cmd).ToString();

                                    if (!b_InLoop && !Running) goto _Pause;

                                    if (b_SecondHalf) break;
                                    if (b_IsNeedle2) break;

                                    TConditions Conds = new TConditions(Line, ActiveLine);

                                    //check first unit only
                                    if (Stats.Board.UnitCount[0] != 0) break;

                                    TaskVision.LightingOff();

                                    TaskMeasMen.MeasL_H_Profile rt_Profile = new TaskMeasMen.MeasL_H_Profile();
                                    TaskMeasMen.Data rt_Data = new TaskMeasMen.Data();
                                    TaskMeasMen.MeasL_H_Profile rt_Profile2 = new TaskMeasMen.MeasL_H_Profile();
                                    TaskMeasMen.Data rt_Data2 = new TaskMeasMen.Data();

                                    double d_MeniscusSpec = ActiveLine.DPara[5];
                                    double d_MeniscusTol = ActiveLine.DPara[6];

                                    int i_StartDelay = ActiveLine.IPara[3];
                                    int t = GDefine.GetTickCount() + i_StartDelay;
                                    while (GDefine.GetTickCount() <= t) Thread.Sleep(1);

                                    #region assign and translate pt
                                    double dx1 = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[0];
                                    double dy1 = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[0];
                                    TranslatePos(dx1, dy1, rt_Head1RefData, ref dx1, ref dy1);

                                    double dx2 = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[1];
                                    double dy2 = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[1];
                                    TranslatePos(dx2, dy2, rt_Head1RefData, ref dx2, ref dy2);

                                    double dx3 = f_origin_x + rt_Layout_Rel_X + CmdList.Line[Line].X[2];
                                    double dy3 = f_origin_y + rt_Layout_Rel_Y + CmdList.Line[Line].Y[2];
                                    TranslatePos(dx3, dy3, rt_Head1RefData, ref dx3, ref dy3);
                                    #endregion

                                    int Col = 0;
                                    int Row = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(RunTime.UIndex, ref Col, ref Row);
                                    rt_Data.Col = Col + 1;
                                    rt_Data.Row = Row + 1;

                                    if (!TaskMeasMen.Execute(ActiveLine, ref rt_Profile, ref rt_Data, dx1, dy1, dx2, dy2, dx3, dy3)) goto _Error;
                                    Event.OP_CHECK_MENISCUS.Set("Meniscus Value", rt_Data.Height.ToString("f4"));

                                    if (rt_Data.Height < d_MeniscusSpec - d_MeniscusTol || rt_Data.Height > d_MeniscusSpec + d_MeniscusTol)
                                    {
                                    _retry:
                                        Msg MsgBox = new Msg();
                                        EMsgRes MsgRes = MsgBox.Show("Check Meniscus Out Of Spec.",
                                            "Spec = " + d_MeniscusSpec.ToString("f3") + " +/-" + d_MeniscusTol.ToString("F3") + " Measured " + rt_Data.Height.ToString("f3") + ".@OK - Continue.@Stop - Stop.",
                                            "",
                                            EMcState.Warning, EMsgBtn.smbOK_Stop, false);

                                        if (TaskDisp.Preference == TaskDisp.EPreference.Lumileds)
                                        {
                                            if (MsgRes == EMsgRes.smrOK)
                                            {
                                                int i_UserIdx = NUtils.UserAcc.Active.UserIndex;
                                                NUtils.UserAcc.Users.LoginDlg();
                                                if (NUtils.UserAcc.Active.GroupID < (int)ELevel.Technician)
                                                {
                                                    NUtils.UserAcc.Active.UserIndex = i_UserIdx;
                                                    goto _retry;
                                                }
                                                NUtils.UserAcc.Active.UserIndex = i_UserIdx;
                                            }
                                        }

                                        Event.OP_CHECK_MENISCUS_OOS.Set("Decision", MsgRes == EMsgRes.smrOK ? "Continue" : "Stop");

                                        switch (MsgRes)
                                        {
                                            case EMsgRes.smrOK:
                                                break;
                                            default:
                                                //Line++;
                                                goto _Pause;
                                        }
                                    }
                                    //_End:
                                    break;
                                }
                            #endregion

                            case ECmd.MEAS_TEMP:
                                #region
                                {
                                    EMsg = Msg + ActiveLine.Cmd.ToString();

                                    if (!b_InLoop && !Running) goto _Pause;

                                    //if (b_SecondHalf || b_IsNeedle2) break;

                                    if (GDefine.CameraType[(int)TaskVision.SelectedCam] == GDefine.ECameraType.PtGrey)
                                    {
                                        if (RunMode == ERunMode.Camera)
                                        {
                                            TaskVision.LightingOn(TaskVision.DefLightRGB);
                                            TaskVision.PtGrey_CamLive(0);
                                        }
                                    }

                                    if (!MeasTemp.Execute(ActiveLine, RunMode, f_origin_x, f_origin_y, f_origin_z)) Running = false;
                                    break;
                                }
                            #endregion

                            case ECmd.TEMPLOGGER_LOG:
                                #region
                                {
                                    EMsg = Msg + ActiveLine.Cmd.ToString();

                                    if (!b_InLoop && !Running) goto _Pause;

                                    if (b_SecondHalf || b_IsNeedle2) break;

                                    string rx = "??";
                                    if (!TFTempLogger.GetTemp(ref rx)) Running = false;

                                    if (DispProg.Options_EnableProcessLog)
                                    {
                                        string str = $"TempLog\t";
                                        str += $"ID={ActiveLine.ID}\t";
                                        //str += $"UnitNo\t{RunTime.UIndex}\t";
                                        str += $"C,R={RunTime.Head_CR[0].X},{RunTime.Head_CR[0].Y}\t";
                                        if (Head_Operation == TaskDisp.EHeadOperation.Sync)
                                        {
                                            str += $"C2,R2={RunTime.Head_CR[1].X},{RunTime.Head_CR[1].Y}\t";
                                        }
                                        str += $"{rx}\t";

                                        GLog.WriteProcessLog(str);
                                    }

                                    break;
                                }
                            #endregion

                            case ECmd.VIDEO_START:
                                {
                                    videoStart = true;
                                    break;
                                }
                            case ECmd.VIDEO_STOP:
                                {
                                    videoStop = true;
                                    break;
                                }
                            case ECmd.IMAGE_SNAP:
                                #region
                                {
                                    if (!TProcessCamera.ImageSnap()) goto _Pause;
                                    break;
                                }
                            #endregion
                            case ECmd.VOLUME_MAP:
                                #region
                                {
                                    VolumeMap(ActiveLine);
                                    GetVolumeMapOffset(ref rt_Head1VolumeOfst, ref rt_Head2VolumeOfst);
                                    break;
                                }
                            #endregion
                            case ECmd.VOLUME_OFST:
                                {
                                    switch (TaskDisp.VolumeOfst_Protocol)
                                    {
                                        case TaskDisp.EVolumeOfstProtocol.AOT_FrontTestCloseLoop:
                                        case TaskDisp.EVolumeOfstProtocol.AOT_HeightCloseLoop:
                                            {
                                                EMsg = Msg + " " + Enum.GetName(typeof(ECmd), ECmd.VOLUME_OFST);

                                                if (CmdList.Line[Line].IPara[0] == (int)EVolumeOfstMode.Manual) break;

                                                double Ofst1 = 0;
                                                double Ofst2 = 0;

                                                if (!DoVolumeOfst(ref Ofst1, ref Ofst2, false)) goto _Pause;
                                                double HA_Vol = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj + DispProg.rt_Head1VolumeOfst;
                                                double HB_Vol = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj + DispProg.rt_Head2VolumeOfst;
                                                TaskDisp.SetDispVolume(true, true, HA_Vol, HB_Vol);
                                            }
                                            break;
                                    }
                                    break;
                                }
                                #endregion
                        }

                        TLine PrevLine(int line, ECmd ccmd)
                        {
                            int i = 1;
                            while (true)
                            {
                                try
                                {
                                    var a = CmdList.Line[line - i++];
                                    if (a.Cmd == ccmd) return a;
                                }
                                catch { return null; }
                            }
                        }

                        if ((GDefine.Status == EStatus.ErrorInit) ||
                            (GDefine.Status == EStatus.Stop) ||
                            (GDefine.Status == EStatus.Unknown))
                        {
                            TaskVision.LightingOn(TaskVision.DefLightRGB);
                            Running = false;
                        }
                    }

                _EndBoard:
                    if (!TaskDisp.TaskMoveGZZ2Up()) goto _Error;

                    TaskVision.CameraRun = true;

                    if (GDefine.CameraType[(int)TaskVision.SelectedCam] == GDefine.ECameraType.PtGrey)
                    {
                        TaskVision.PtGrey_CamLive((int)TaskVision.SelectedCam);
                    }


                    if (TaskDisp.VolumeOfst_Protocol == TaskDisp.EVolumeOfstProtocol.Lextar_FrontTestCloseLoop)
                    {
                        if (Lextar_FrontTestCloseLoop.Mode == Lextar_FrontTestCloseLoop.EMode.Auto)
                        {
                            //double[] Setting = new double[2] { 0, 0 };
                            double[] Base = new double[2] { DispProg.PP_HeadA_DispBaseVol, DispProg.PP_HeadB_DispBaseVol };
                            double[] Adjust = new double[2] { DispProg.PP_HeadA_DispVol_Adj, DispProg.PP_HeadB_DispVol_Adj };
                            double[] Offset = new double[2] { DispProg.rt_Head1VolumeOfst, DispProg.rt_Head2VolumeOfst };
                            double[] Backsuck = new double[2] { DispProg.PP_HeadA_BackSuckVol, DispProg.PP_HeadB_BackSuckVol };

                            //send the current level no starting from 1
                            NUtils.RegistryWR RegRW = new NUtils.RegistryWR("Software");
                            int OutLevel = RegRW.ReadKey("MHS\\Elev\\Out", "LevelNo", 0) + 1;

                            try
                            {
                                NDispWin.Lextar_FrontTestCloseLoop.EquipmentID = TaskDisp.VolumeOfst_EqID;
                                NDispWin.Lextar_FrontTestCloseLoop.LocalPath = TaskDisp.VolumeOfst_LocalPath;
                                NDispWin.Lextar_FrontTestCloseLoop.DataFilePath = TaskDisp.VolumeOfst_DataPath;
                                NDispWin.Lextar_FrontTestCloseLoop.DataFilePath2 = TaskDisp.VolumeOfst_DataPath2;
                                Lextar_FrontTestCloseLoop.UploadDataFile(OutLevel, Base, Adjust, Offset, Backsuck);
                            }
                            catch
                            {

                            }
                        }
                    }

                    if (TaskDisp.Option_EnableChuckVac)
                    {
                        //TaskGantry.SvChuckVac(TaskGantry.TOutputState.Off);
                        TaskGantry.ChuckVac = false;
                    }

                    GDefine.WriteRegStat(GDefine.REG_KEY_STAT_UNIT_COUNT, Stats.TotalUnitCount);

                    GDefine.OperationSpeed = EOperationSpeed.Safe;
                    GDefine.Status = EStatus.EndStop;// Ready;

                    if (!IsSub)
                    {
                        #region
                        LastTactTime = GDefine.GetTickCount() - LastStartTickCount;
                        LastStartTickCount = GDefine.GetTickCount();
                        if (LastTactTime <= 0 || rt_Layouts[rt_LayoutID].TUCount == 0)
                        {
                            LastUPH = 0;
                        }
                        else
                        {
                            double t_Tact = LastTactTime;
                            LastUPH = 3600000 / (LastTactTime / rt_Layouts[rt_LayoutID].TUCount);
                        }
                        GDefine.WriteRegStat(GDefine.REG_KEY_STAT_UPH, LastUPH);

                        TOutputMap.Execute("", rt_Read_IDs[0, 0], ref Map.CurrMap[0], TaskDisp.InputMap_Enabled);

                        if (TaskDisp.Preference == TaskDisp.EPreference.Unisem)
                        {
                            if (!TInputMap.Upload(rt_Read_IDs[0, 0], ref Map.CurrMap[0])) goto _Pause;
                        }
                        if (TaskDisp.Preference == TaskDisp.EPreference.Lumileds)
                        {
                            if (rt_MeniscusDatas.Count > 0) rt_MeniscusDatas.SaveLmds(rt_Read_IDs[0, 0]);
                        }

                        if (!BdReady) CheckBoardYieldPrompt();
                        BdReady = true;
                        Define_Run.UpdateProcessStatus_BdReady();

                        switch (rt_RunRegion)
                        {
                            case ERunRegion.All:
                                Stats.BoardCount++;
                                break;
                            case ERunRegion.H1:
                            case ERunRegion.H2:
                                Stats.BoardCount++;
                                break;
                        }

                        ClearRTDispData();
                        #endregion
                    }

                    rt_Singulated = false;

                    LastLine = -1;
                    IsBusy = false;
                    Running = false;

                    b_ForceHead1 = false;
                    b_ForceHead2 = false;

                    return true;
                }
                catch (Exception Ex)
                {
                    TaskVision.CameraRun = true;
                    if (GDefine.CameraType[(int)TaskVision.SelectedCam] == GDefine.ECameraType.PtGrey)
                    {
                        TaskVision.PtGrey_CamLive((int)TaskVision.SelectedCam);
                    }

                    GDefine.OperationSpeed = EOperationSpeed.Safe;
                    GDefine.Status = EStatus.ErrorInit;

                    IsBusy = false;
                    Running = false;

                    b_ForceHead1 = false;
                    b_ForceHead2 = false;

                    EMsg = EMsg + (char)13 + Ex.Message.ToString();
                    throw new Exception(EMsg);
                }

            _Pause:
                //set active line to move
                if (LastLine >= 0)
                    if (CmdList.Line[LastLine].Cmd == ECmd.LINE ||
                                                CmdList.Line[LastLine].Cmd == ECmd.ARC ||
                                                CmdList.Line[LastLine].Cmd == ECmd.CIRC ||
                                                CmdList.Line[LastLine].Cmd == ECmd.DWELL)
                    {
                        for (int L = LastLine; L >= 0; L--)
                        {
                            if (CmdList.Line[L].Cmd == ECmd.MOVE)
                            {
                                LastLine = L;
                                break;
                            }
                        }
                    }

                TaskVision.CameraRun = true;
                if (GDefine.CameraType[(int)TaskVision.SelectedCam] == GDefine.ECameraType.PtGrey)
                {
                    TaskVision.PtGrey_CamLive((int)TaskVision.SelectedCam);
                }

                GDefine.WriteRegStat(GDefine.REG_KEY_STAT_UNIT_COUNT, Stats.TotalUnitCount);

                GDefine.OperationSpeed = EOperationSpeed.Safe;
                GDefine.Status = EStatus.Stop;
                BdStatus = EBoardStatus.Stop;

                if (!TaskDisp.TaskMoveGZZ2Up()) goto _Error;

                IsBusy = false;
                Running = false;

                b_ForceHead1 = false;
                b_ForceHead2 = false;
                return true;

            _Error:
                //set active line to move
                if (LastLine >= 0)
                    if (CmdList.Line[LastLine].Cmd == ECmd.LINE ||
                                            CmdList.Line[LastLine].Cmd == ECmd.ARC ||
                                            CmdList.Line[LastLine].Cmd == ECmd.CIRC ||
                                            CmdList.Line[LastLine].Cmd == ECmd.DWELL)
                    {
                        for (int L = LastLine; L >= 0; L--)
                        {
                            if (CmdList.Line[L].Cmd == ECmd.MOVE)
                            {
                                LastLine = L;
                                break;
                            }
                        }
                    }

                TaskVision.CameraRun = true;
                if (GDefine.CameraType[(int)TaskVision.SelectedCam] == GDefine.ECameraType.PtGrey)
                {
                    TaskVision.PtGrey_CamLive((int)TaskVision.SelectedCam);
                }

                GDefine.OperationSpeed = EOperationSpeed.Safe;
                GDefine.Status = EStatus.ErrorInit;
                BdStatus = EBoardStatus.Stop;

                IsBusy = false;
                Running = false;

                b_ForceHead1 = false;
                b_ForceHead2 = false;

                return false;

                void CheckBoardYieldPrompt()
                {
                    if (Options_CheckBoardYield > 0)
                    {
                        int totalUnit = rt_Layouts[rt_LayoutID].TUCount;
                        int procUnitCount = Stats.Board.TotalProcUnitCount;
                        double yield = (double)procUnitCount / totalUnit;
                        if (yield < Options_CheckBoardYield)
                        {
                            Msg MsgBox = new Msg();
                            EMsgRes MsgRes = MsgBox.Show(ErrCode.CHECK_BOARD_YIELD, $"Low board yield detected. Yield {yield * 100:f2}% Unit count {procUnitCount}/{totalUnit}.", EMcState.Notice, EMsgBtn.smbOK, false);
                        }
                    }
                }
            }
            public bool Run(ERunMode RunMode, double f_origin_x, double f_origin_y, double f_origin_z, bool IsSub, bool SyncHead2)
            {
                return Run(RunMode, f_origin_x, f_origin_y, f_origin_z, TaskDisp.FlowRateOld, 0, IsSub);//, SyncHead2);
            }

            enum ELmdsCT_2DMode { Def, Singulated };

            public void Pause()
            {
                //if (LastEventMsg != ELastEventMsg.Pause)
                //{
                //    LastEventMsg = ELastEventMsg.Pause;

                //    int C = 0; int R = 0;
                //        rt_Layouts[rt_LayoutID].UnitNoGetRC(rt_UIndex, ref C, ref R);
                //    OldEvent.Log("Disp Pause UnitNo, C, R. ", rt_UIndex.ToString() + ", " + C.ToString() + ", " + R.ToString());
                //}

                Running = false;
            }
            public void Stop()
            {
                //if (LastEventMsg != ELastEventMsg.Stop)
                //{
                //    LastEventMsg = ELastEventMsg.Stop;

                //    int C = 0; int R = 0;
                //        rt_Layouts[rt_LayoutID].UnitNoGetRC(rt_UIndex, ref C, ref R);
                //    OldEvent.Log("Disp Stop UnitNo, C, R. ", rt_UIndex.ToString() + ", " + C.ToString() + ", " + R.ToString());
                //}

                Running = false;

                while (IsBusy)
                {
                    Thread.Sleep(0);
                };
            }

            #region Calc Utilities
            private bool CalcTotalDistTime(double originX, double originY, ref double Dist, ref double Time)
            {
                double LastX = originX;
                double LastY = originY;
                double TotalDist = 0;
                double d_TDelayTime = 0;
                for (int i = 0; i < CmdList.Count; i++)
                {
                    if (CmdList.Line[i].Cmd == ECmd.MOVE)
                    {
                        LastX = CmdList.Line[i].X[0];
                        LastY = CmdList.Line[i].Y[0];
                    }
                    if (CmdList.Line[i].Cmd == ECmd.LINE)
                    {
                        if (CmdList.Line[i].IPara[2] > 0)
                        {
                            double distX = CmdList.Line[i].X[0] - LastX;
                            double distY = CmdList.Line[i].Y[0] - LastY;
                            TotalDist = TotalDist + Math.Sqrt(Math.Pow(distX, 2) + Math.Pow(distY, 2));
                        }
                        LastX = CmdList.Line[i].X[0];
                        LastY = CmdList.Line[i].Y[0];
                    }
                    if (CmdList.Line[i].Cmd == ECmd.CIRC)
                    {
                        if (CmdList.Line[i].IPara[2] > 0)
                        {
                            double cx = 0;
                            double cy = 0;
                            double rad = 0;
                            if (!GDefine.Arc3PGetInfo(LastX, LastY, CmdList.Line[i].X[0], CmdList.Line[i].Y[0], CmdList.Line[i].X[1], CmdList.Line[i].Y[1], ref cx, ref cy, ref rad)) return false;
                            TotalDist = TotalDist + (2 * Math.PI * rad);
                        }
                        if (i > 0)
                        {
                            LastX = CmdList.Line[i - 1].X[1];
                            LastY = CmdList.Line[i - 1].Y[1];
                        }
                    }
                    if (CmdList.Line[i].Cmd == ECmd.ARC)
                    {
                        if (CmdList.Line[i].IPara[2] > 0)
                        {
                            double cx = 0;
                            double cy = 0;
                            double rad = 0;
                            double ps = 0;
                            double pe = 0;
                            double sa = 0;
                            double dir = 0;
                            if (!GDefine.Arc3PGetInfo(LastX, LastY, CmdList.Line[i].X[0], CmdList.Line[i].Y[0], CmdList.Line[i].X[1], CmdList.Line[i].Y[1], ref cx, ref cy, ref rad, ref ps, ref pe, ref sa, ref dir)) return false;
                            TotalDist = TotalDist + (Math.PI * rad);
                        }
                        LastX = CmdList.Line[i].X[1];
                        LastY = CmdList.Line[i].Y[1];
                    }
                    if ((CmdList.Line[i].Cmd == ECmd.LINE) || (CmdList.Line[i].Cmd == ECmd.ARC) || (CmdList.Line[i].Cmd == ECmd.CIRC))
                    {
                        bool First = true;
                        if (i > 0)
                        {
                            First = !((CmdList.Line[i - 1].Cmd == ECmd.LINE) || (CmdList.Line[i - 1].Cmd == ECmd.ARC) || (CmdList.Line[i - 1].Cmd == ECmd.CIRC));
                        }
                        bool Cont = false;
                        if (i < CmdList.Count - 1)
                        {
                            Cont = (CmdList.Line[i + 1].Cmd == ECmd.LINE) || (CmdList.Line[i + 1].Cmd == ECmd.ARC) || (CmdList.Line[i + 1].Cmd == ECmd.CIRC);
                        }

                        if (First)
                        {
                            if (CmdList.Line[i].IPara[2] > 0)
                            {
                                d_TDelayTime = d_TDelayTime + ModelList.Model[CmdList.Line[i].IPara[0]].Para[(int)TModelList.EModel.StartDelay];
                            }
                        }
                        if (!Cont)
                        {
                            if (CmdList.Line[i].IPara[2] > 0)
                            {
                                d_TDelayTime = d_TDelayTime + ModelList.Model[CmdList.Line[i].IPara[0]].Para[(int)TModelList.EModel.EndDelay];
                            }
                        }
                    }
                }

                Dist = TotalDist;
                Time = d_TDelayTime;
                return true;
            }
            private bool CalcLength(double originX, double originY, TLine Line, ref double Length)
            {
                double LastX = originX;
                double LastY = originY;
                if (Line.Cmd == ECmd.LINE)
                {
                    double distX = Line.X[0] - LastX;
                    double distY = Line.Y[0] - LastY;
                    Length = Math.Sqrt(Math.Pow(distX, 2) + Math.Pow(distY, 2));
                }
                if (Line.Cmd == ECmd.CIRC)
                {
                    double cx = 0;
                    double cy = 0;
                    double rad = 0;
                    if (!GDefine.Arc3PGetInfo(LastX, LastY, Line.X[0], Line.Y[0], Line.X[1], Line.Y[1], ref cx, ref cy, ref rad)) return false;
                    Length = 2 * Math.PI * rad;
                }
                if (Line.Cmd == ECmd.ARC)
                {
                    double cx = 0;
                    double cy = 0;
                    double rad = 0;
                    double ps = 0;
                    double pe = 0;
                    double sa = 0;
                    double dir = 0;
                    if (!GDefine.Arc3PGetInfo(LastX, LastY, Line.X[0], Line.Y[0], Line.X[1], Line.Y[1], ref cx, ref cy, ref rad, ref ps, ref pe, ref sa, ref dir)) return false;
                    Length = Math.PI * rad;
                }

                return true;
            }
            private double CalcLineLength(double X1, double Y1, double X2, double Y2)
            {
                double distX = X2 - X1;
                double distY = Y2 - Y1;
                double Length = Math.Sqrt(Math.Pow(distX, 2) + Math.Pow(distY, 2));

                return Length;
            }
            private double CalcArcLength(double X1, double Y1, double X2, double Y2, double X3, double Y3)
            {
                double cx = 0;
                double cy = 0;
                double rad = 0;
                double ps = 0;
                double pe = 0;
                double sa = 0;
                double dir = 0;
                GDefine.Arc3PGetInfo(X1, Y1, X2, Y2, X3, Y3, ref cx, ref cy, ref rad, ref ps, ref pe, ref sa, ref dir);
                double Length = Math.PI * rad;

                return Length;
            }
            private double CalcCircLength(double X1, double Y1, double X2, double Y2, double X3, double Y3)
            {
                double cx = 0;
                double cy = 0;
                double rad = 0;
                double ps = 0;
                double pe = 0;
                double sa = 0;
                double dir = 0;
                GDefine.Arc3PGetInfo(X1, Y1, X2, Y2, X3, Y3, ref cx, ref cy, ref rad, ref ps, ref pe, ref sa, ref dir);
                double Length = 2 * Math.PI * rad;

                return Length;
            }
            private double CalcCircLength(double XS, double YS, double XC, double YC)
            {
                double Radius = CalcLineLength(XS, YS, XC, YC);
                double Length = 2 * Math.PI * Radius;

                return Length;
            }
            private double CalcArcLength(double XS, double YS, double XE, double YE, double XC, double YC, bool CW)
            {
                double Radius = CalcLineLength(XS, YS, XC, YC);
                //double Length = 2 * Math.PI * Radius;

                //CCW dir value is negative -3.142 ~ 3.142
                double f_StartA = (double)Math.Atan2((YS - YC), (XS - XC));
                double f_EndA = (double)Math.Atan2((YE - YC), (YE - YC));
                double f_SweepA = 0;

                if (f_StartA > f_EndA)
                    f_SweepA = f_EndA - f_StartA;
                else
                    f_SweepA = (Math.PI * 2) - (f_EndA - f_StartA);

                f_SweepA = Math.Abs(f_SweepA);

                if (!CW) f_SweepA = (Math.PI * 2) - f_SweepA;

                double Length = Radius * f_SweepA;
                return Length;
            }
            #endregion

            private bool MovePanelGap(int LineNo)//return true if false if next command 
            {
                if (LineNo >= CmdList.Count - 1) return true;

                ECmd NextCmd = CmdList.Line[LineNo + 1].Cmd;
                if (NextCmd == ECmd.DOT ||
                    NextCmd == ECmd.DOT_P ||
                    NextCmd == ECmd.DOT_MULTI ||
                    NextCmd == ECmd.DOTLINE_MULTI ||
                    NextCmd == ECmd.MOVE ||
                    NextCmd == ECmd.LINE ||
                    NextCmd == ECmd.ARC ||
                    NextCmd == ECmd.DWELL ||
                    NextCmd == ECmd.WAIT
                    ) return false;

                return true;
            }

            private bool DoBdOrient(TLine Line, double X, double Y, out double ox, out double oy, out double s, ref Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> FoundOrient)
            {
                string EMsg = "DoBdOrient";
                GDefine.Status = EStatus.Busy;

                ox = 0;
                oy = 0;
                s = 0;

                try
                {
                    //if (!TaskDisp.TaskMoveGZZ2Up()) return false;

                    //#region Z Up
                    //TaskGantry.SetMotionParamGZ();
                    //TaskGantry.MoveAbsGZ(DispProg.CameraZPos);
                    //#endregion

                    if (!TaskDisp.TaskMoveGZFocus(0)) return false;

                    TaskGantry.SetMotionParamGX2Y2();
                    if (!TaskGantry.MoveGX2Y2DefPos(true)) return false;

                    //TPos2 GXY = new TPos2(X, Y);
                    //TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                    //GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + TaskDisp.Head2_MinDistX;
                    //if (!TaskDisp.GotoXYPos(GXY, GX2Y2)) goto _Stop;
                    TaskGantry.SetMotionParamGXY();
                    if (!TaskGantry.MoveAbsGXY(X, Y, true)) goto _Stop;

                    //settle time
                    int SettleTime = Line.IPara[4];
                    int t = GDefine.GetTickCount() + SettleTime;
                    while (GDefine.GetTickCount() <= t) { Thread.Sleep(1); }

                    //Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> FoundTemplate = null;
                    int Threshold = (int)Line.DPara[5];
                    if (!TaskVision.MatchTemplate(Line.IPara[2], TaskVision.BdOrientTemplate, Threshold, out ox, out oy, out s, ref FoundOrient)) goto _Stop;
                }
                catch (Exception Ex)
                {
                    GDefine.Status = EStatus.ErrorInit;
                    EMsg = EMsg + (char)13 + Ex.ToString();
                    throw new Exception(EMsg);
                }
                GDefine.Status = EStatus.Ready;
                return true;
                _Stop:
                GDefine.Status = EStatus.Stop;
                return false;
            }

            private bool DoUnitMark(TLine Line, double X, double Y, out double ox, out double oy, out double s, ref Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> FoundOrient)
            {
                string EMsg = "DoUnitMark";
                GDefine.Status = EStatus.Busy;

                ox = 0;
                oy = 0;
                s = 0;

                try
                {
                    if (!TaskDisp.TaskMoveGZZ2Up()) return false;

                    //TPos2 GXY = new TPos2(X, Y);
                    //TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                    //GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + TaskDisp.Head2_MinDistX;
                    //if (!TaskDisp.GotoXYPos(GXY, GX2Y2)) goto _Stop;

                    #region Z Up
                    //TaskGantry.SetMotionParamGZ();
                    //TaskGantry.MoveAbsGZ(DispProg.CameraZPos);
                    if (!TaskDisp.TaskMoveGZFocus(Line.IPara[21])) return false;
                    #endregion

                    if (!TaskGantry.MoveGX2Y2DefPos(true)) return false;

                    //TPos2 GXY = new TPos2(X, Y);
                    //TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                    //GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + TaskDisp.Head2_MinDistX;
                    //if (!TaskDisp.GotoXYPos(GXY, GX2Y2)) goto _Stop;
                    if (!TaskGantry.MoveAbsGXY(X, Y, true)) goto _Stop;

                    //settle time
                    int SettleTime = Line.IPara[4];
                    int t = GDefine.GetTickCount() + SettleTime;
                    while (GDefine.GetTickCount() <= t) { Thread.Sleep(0); }

                    //Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> FoundTemplate = null;
                    int Threshold = (int)Line.DPara[5];
                    if (!TaskVision.MatchTemplate(Line.IPara[2], TaskVision.UnitMarkTemplate, Threshold, out ox, out oy, out s, ref FoundOrient)) goto _Stop;
                }
                catch (Exception Ex)
                {
                    GDefine.Status = EStatus.ErrorInit;
                    EMsg = EMsg + (char)13 + Ex.ToString();
                    throw new Exception(EMsg);
                }
                GDefine.Status = EStatus.Ready;
                return true;
                _Stop:
                GDefine.Status = EStatus.Stop;
                return false;
            }
            private void DoDelay(int Time)
            {
                GDefine.Status = EStatus.Busy;
                int t = GDefine.GetTickCount() + Time;
                while (GDefine.GetTickCount() <= t)
                {
                    Thread.Sleep(0);
                }
                GDefine.Status = EStatus.Ready;
            }

            public bool DoPurgeDot(TLine Line, EHeadNo HeadNo, ERunMode RunMode, double XA1, double YA1, double ZA1, double XA2, double YA2, double ZA2)
            {
                string EMsg = "DoPurgeDot";
                int t = 0;

                GDefine.Status = EStatus.Busy;

                #region Select Head
                bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
                bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));

                if (!b_Head1Run && !b_Head2Run) goto _End;
                #endregion

                TModelPara Model = new TModelPara(ModelList, Line.IPara[0]);

                bool Disp = (Line.IPara[2] > 0);
                EDotMode DotMode = (EDotMode)Line.IPara[1];

                try
                {
                    #region Set Volume
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            double VolToDispA_ul = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj;
                            double VolToDispB_ul = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj;
                            if (rt_Head1VolumeOfst != 0)
                            {
                                VolToDispA_ul = VolToDispA_ul + rt_Head1VolumeOfst;
                            }
                            if (rt_Head2VolumeOfst != 0)
                            {
                                VolToDispB_ul = VolToDispB_ul + rt_Head2VolumeOfst;
                            }
                            if (Model.DispVol > 0)
                            {
                                VolToDispA_ul = Model.DispVol;
                                VolToDispB_ul = Model.DispVol;
                            }

                            if (Disp)
                            {
                                switch (Pump_Type)
                                {
                                    case TaskDisp.EPumpType.PP:
                                    case TaskDisp.EPumpType.PP2D:
                                    case TaskDisp.EPumpType.PPD:
                                        if (VolToDispA_ul != progDispVol[0] || VolToDispB_ul != progDispVol[1])
                                        {
                                            if (!TaskDisp.SetDispVolume(b_Head1Run, b_Head2Run, VolToDispA_ul, VolToDispB_ul))
                                            {
                                                Msg MsgBox = new Msg();
                                                MsgBox.Show(ErrCode.DISPCTRL1_COMM_ERR, "SetDispVolume ");
                                                goto _Stop;
                                            }
                                            if (b_Head1Run) progDispVol[0] = VolToDispA_ul;
                                            if (b_Head2Run) progDispVol[1] = VolToDispB_ul;
                                        }
                                        if (Model.BSuckVol > 0)
                                        {
                                            if (!TaskDisp.Thread_SetBackSuckVolume_Run(b_Head1Run, b_Head2Run, Model.BSuckVol, Model.BSuckVol)) goto _Stop;
                                        }
                                        break;
                                }
                            }
                            break;
                        case ERunMode.Camera:
                        case ERunMode.Dry:
                            break;
                    }
                    #endregion

                    if (!TaskDisp.TaskMoveGZZ2Up()) goto _Error;

                    TPos2 GXY = new TPos2(XA1, YA1);
                    TPos2 GX2Y2 = new TPos2(XA2, YA2);
                    if (!TaskGantry.SetMotionParamGXY()) goto _Error;
                    if (!TaskGantry.MoveAbsGXY(GXY.X, GXY.Y, false)) goto _Error;
                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                    {
                        if (!TaskGantry.SetMotionParamGX2Y2()) goto _Error;
                        if (!TaskGantry.MoveAbsGX2Y2(GX2Y2.X, GX2Y2.Y, false)) goto _Error;
                        TaskGantry.WaitGX2Y2();
                    }
                    if (!TaskGantry.WaitGXY()) goto _Error;

                    //ZA1 = ZA1 + TaskDisp.Head_Ofst[0].Z;
                    //ZA2 = ZA2 + TaskDisp.Head_Ofst[1].Z;

                    #region Update Z Offset
                    ZA1 = ZA1 + TaskDisp.Z1Offset;
                    ZA2 = ZA2 + TaskDisp.Z2Offset;
                    #endregion

                    #region Move to ZRetGap or ZUpGap
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                if (!TaskGantry.SetMotionParamGZZ2(Model.DnStartV, Model.DnSpeed, Model.DnAccel)) return false;
                                if (Model.UpGap != 0)
                                {
                                    #region Move to ZUpGap

                                    double Z1UpGap = ZA1 + Model.UpGap;
                                    if (Z1UpGap > TaskDisp.ZDefPos) Z1UpGap = TaskDisp.ZDefPos;
                                    double Z2UpGap = ZA2 + Model.UpGap;
                                    if (Z2UpGap > TaskDisp.ZDefPos) Z2UpGap = TaskDisp.ZDefPos;

                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                    {
                                        if (b_Head1Run && b_Head2Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZZ2(Z1UpGap, Z2UpGap)) return false;
                                        }
                                        else
                                            if (b_Head1Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZ(Z1UpGap)) return false;
                                        }
                                        else
                                                if (b_Head2Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZ2(Z2UpGap)) return false;
                                        }
                                    }
                                    else
                                    {
                                        if (!TaskGantry.MoveAbsGZ(Z1UpGap)) return false;
                                    }
                                    #endregion
                                }
                                else
                                    if (Model.RetGap != 0)
                                {
                                    #region Move to ZRetGap
                                    double Z1RetGap = ZA1 + Model.RetGap;
                                    if (Z1RetGap > TaskDisp.ZDefPos) Z1RetGap = TaskDisp.ZDefPos;
                                    double Z2RetGap = ZA2 + Model.RetGap;
                                    if (Z2RetGap > TaskDisp.ZDefPos) Z2RetGap = TaskDisp.ZDefPos;

                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                    {
                                        if (b_Head1Run && b_Head2Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZZ2(Z1RetGap, Z2RetGap)) return false;
                                        }
                                        else
                                            if (b_Head1Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZ(Z1RetGap)) return false;
                                        }
                                        else
                                                if (b_Head2Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZ2(Z2RetGap)) return false;
                                        }
                                    }
                                    else
                                    {
                                        if (!TaskGantry.MoveAbsGZ(Z1RetGap)) return false;
                                    }
                                    #endregion
                                }
                                break;
                            }
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }
                    #endregion

                    #region move z to DispGap
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                double sv = Model.DnStartV;
                                double dv = Model.DnSpeed;
                                double ac = Model.DnAccel;
                                if (!TaskGantry.SetMotionParamGZZ2(sv, dv, ac)) goto _Stop;

                                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                {
                                    if (b_Head1Run && b_Head2Run)
                                    {
                                        if (!TaskGantry.MoveAbsGZZ2(ZA1 + Model.DispGap, ZA2 + Model.DispGap)) goto _Stop;
                                    }
                                    else
                                        if (b_Head1Run)
                                    {
                                        if (!TaskGantry.MoveAbsGZ(ZA1 + Model.DispGap)) goto _Stop;
                                    }
                                    else
                                            if (b_Head2Run)
                                    {
                                        if (!TaskGantry.MoveAbsGZ2(ZA2 + Model.DispGap)) goto _Stop;
                                    }
                                }
                                else
                                {
                                    if (!TaskGantry.MoveAbsGZ(ZA1 + Model.DispGap)) goto _Stop;
                                }
                                break;
                            }
                        case ERunMode.Camera:
                        default:
                            {
                                break;
                            }
                    }
                    #endregion

                    #region Down Wait
                    t = GDefine.GetTickCount() + Model.DnWait;
                    while (GDefine.GetTickCount() < t) { }
                    { Thread.Sleep(1); }
                    #endregion

                    if (DotMode == EDotMode.Cont)
                    {
                        #region DotMode Continuous
                        switch (RunMode)
                        {
                            case ERunMode.Normal:
                                {
                                    if (Disp)
                                    {
                                        if (!TaskDisp.Thread_SetDispVolume_Wait()) goto _Stop;

                                        if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                        if (!TaskDisp.TrigOn(b_Head1Run, b_Head2Run)) goto _Stop;
                                        //if (!TaskDisp.HPCWaitNotReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                        if (!TaskDisp.CtrlWaitResponse(b_Head1Run, b_Head2Run)) goto _Stop;
                                    }
                                    break;
                                }
                            case ERunMode.Dry:
                            case ERunMode.Camera:
                                {
                                    break;
                                }
                        }

                        t = GDefine.GetTickCount() + (int)(Model.StartDelay + Model.EndDelay);
                        while (GDefine.GetTickCount() < t) { Thread.Sleep(1); };

                        switch (RunMode)
                        {
                            case ERunMode.Normal:
                                {
                                    if (Disp)
                                    {
                                        if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) goto _Stop;
                                        //if (b_Head1Run) DispProg.Stats.HeadAShotCount++;
                                        //if (b_Head2Run) DispProg.Stats.HeadBShotCount++;
                                    }
                                    break;
                                }
                            case ERunMode.Dry:
                            case ERunMode.Camera:
                                {
                                    break;
                                }
                        }
                        #endregion
                    }

                    if (DotMode == EDotMode.ExtTimed)
                    {
                        #region DotMode ExtTimed
                        switch (RunMode)
                        {
                            case ERunMode.Normal:
                                {
                                    if (Disp)
                                    {
                                        if (!TaskDisp.Thread_SetDispVolume_Wait()) goto _Stop;

                                        if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                        if (!TaskDisp.TrigOn(b_Head1Run, b_Head2Run)) goto _Stop;
                                        //if (!TaskDisp.HPCWaitNotReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                        if (!TaskDisp.CtrlWaitResponse(b_Head1Run, b_Head2Run)) goto _Stop;
                                        if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) goto _Stop;
                                        //if (b_Head1Run) DispProg.Stats.HeadAShotCount++;
                                        //if (b_Head2Run) DispProg.Stats.HeadBShotCount++;

                                        int t_Start = GDefine.GetTickCount() + (int)Model.StartDelay;

                                        if (Model.StartDelay > 0)
                                        {
                                            while (GDefine.GetTickCount() < t_Start)
                                            {
                                                //TaskDisp.CheckIsFilling(b_Head1Run, b_Head2Run);
                                                //Thread.Sleep(0);
                                                TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                            }
                                            goto _Ret;
                                        }

                                        //if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                        if (!TaskDisp.CtrlWaitComplete(b_Head1Run, b_Head2Run)) goto _Stop;
                                    }
                                    break;
                                }
                            case ERunMode.Dry:
                            case ERunMode.Camera:
                                {
                                    break;
                                }
                        }
                        #endregion
                    }

                    #region post wait
                    t = GDefine.GetTickCount() + Model.PostWait;
                    while (GDefine.GetTickCount() < t)
                    {
                        //TaskDisp.CheckIsFilling(b_Head1Run, b_Head2Run);
                        //Thread.Sleep(1);
                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                    }
                    #endregion

                    _Ret:
                    #region Move ZRetGap, ZUpGap and ZPanelGap
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                if (Model.RetGap != 0)
                                {
                                    #region Move Ret
                                    if (!TaskGantry.SetMotionParamGZZ2(Model.RetStartV, Model.RetSpeed, Model.RetAccel)) return false;

                                    double Z1RetGap = ZA1 + Model.RetGap;
                                    if (Z1RetGap > TaskDisp.ZDefPos) Z1RetGap = TaskDisp.ZDefPos;
                                    double Z2RetGap = ZA2 + Model.RetGap;
                                    if (Z2RetGap > TaskDisp.ZDefPos) Z2RetGap = TaskDisp.ZDefPos;

                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                    {
                                        if (b_Head1Run && b_Head2Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZZ2(Z1RetGap, Z2RetGap)) return false;
                                        }
                                        else
                                            if (b_Head1Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZ(Z1RetGap)) return false;
                                        }
                                        else
                                                if (b_Head2Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZ2(Z2RetGap)) return false;
                                        }
                                    }
                                    else
                                    {
                                        if (!TaskGantry.MoveAbsGZ(Z1RetGap)) return false;
                                    }
                                    #endregion
                                    #region Ret Wait
                                    t = GDefine.GetTickCount() + Model.RetWait;
                                    while (GDefine.GetTickCount() < t)
                                    {
                                        //TaskDisp.CheckIsFilling(b_Head1Run, b_Head2Run);
                                        //Thread.Sleep(0);
                                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                    }
                                    #endregion
                                }
                                if (Model.UpGap != 0)
                                {
                                    #region Move Up
                                    if (!TaskGantry.SetMotionParamGZZ2(Model.UpStartV, Model.UpSpeed, Model.UpAccel)) return false;

                                    double Z1UpGap = ZA1 + Model.UpGap;
                                    if (Z1UpGap > TaskDisp.ZDefPos) Z1UpGap = TaskDisp.ZDefPos;
                                    double Z2UpGap = ZA2 + Model.UpGap;
                                    if (Z2UpGap > TaskDisp.ZDefPos) Z2UpGap = TaskDisp.ZDefPos;

                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                    {
                                        if (b_Head1Run && b_Head2Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZZ2(Z1UpGap, Z2UpGap)) return false;
                                        }
                                        else
                                            if (b_Head1Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZ(Z1UpGap)) return false;
                                        }
                                        else
                                                if (b_Head2Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZ2(Z2UpGap)) return false;
                                        }
                                    }
                                    else
                                    {
                                        if (!TaskGantry.MoveAbsGZ(Z1UpGap)) return false;
                                    }
                                    #endregion
                                    #region Up Wait
                                    t = GDefine.GetTickCount() + Model.UpWait;
                                    while (GDefine.GetTickCount() < t)
                                    {
                                        //TaskDisp.CheckIsFilling(b_Head1Run, b_Head2Run);
                                        //Thread.Sleep(0);
                                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                    }
                                    #endregion
                                }
                                //REM LastInCluster
                                //if (LastInCluster && b_MovePanelGap && Model.PanelGap != 0)
                                //{
                                //    #region Move Panel Gap
                                //    if (!TaskGantry.SetMotionParamGZZ2()) goto _Stop;

                                //    double Z1PanelGap = ZA1 + Model.PanelGap;
                                //    if (Z1PanelGap > TaskDisp.ZDefPos) Z1PanelGap = TaskDisp.ZDefPos;
                                //    double Z2PanelGap = ZA2 + Model.PanelGap;
                                //    if (Z2PanelGap > TaskDisp.ZDefPos) Z2PanelGap = TaskDisp.ZDefPos;

                                //    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                //    {
                                //        if (b_Head1Run && b_Head2Run)
                                //        {
                                //            if (!TaskGantry.MoveAbsGZZ2(Z1PanelGap, Z2PanelGap)) return false;
                                //        }
                                //        else
                                //            if (b_Head1Run)
                                //            {
                                //                if (!TaskGantry.MoveAbsGZ(Z1PanelGap)) return false;
                                //            }
                                //            else
                                //                if (b_Head2Run)
                                //                {
                                //                    if (!TaskGantry.MoveAbsGZ2(Z2PanelGap)) return false;
                                //                }
                                //    }
                                //    else
                                //    {
                                //        if (!TaskGantry.MoveAbsGZ(Z1PanelGap)) return false;
                                //    }
                                //    #endregion
                                //}
                                break;
                            }
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }
                    #endregion

                    if (!TaskDisp.TaskMoveGZZ2Up()) goto _Error;

                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            {
                                if (Disp)
                                {
                                    if (!TaskDisp.IsFilling())
                                    {
                                        //                                        if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                    }
                                }
                                break;
                            }
                        case ERunMode.Dry:
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }
                }
                catch (Exception Ex)
                {
                    GDefine.Status = EStatus.ErrorInit;
                    TaskDisp.TrigOff(b_Head1Run, b_Head2Run);
                    EMsg = EMsg + (char)13 + Ex.Message.ToString();
                    throw new Exception(EMsg);
                }
                _End:
                GDefine.Status = EStatus.Ready;
                return true;
                _Stop:
                GDefine.Status = EStatus.Stop;
                return false;
                _Error:
                GDefine.Status = EStatus.ErrorInit;
                return false;
            }

            public bool DoDot(TLine Line, EHeadNo HeadNo, bool SyncHead2, bool Head2Valid, ERunMode RunMode, double X1, double Y1, double Z1, double X2, double Y2, double Z2)
            {
                string EMsg = "DoDot";
                int t = 0;

                GDefine.Status = EStatus.Busy;

                TModelPara Model = new TModelPara(ModelList, Line.IPara[0]);
                bool Disp = (Line.IPara[2] > 0);

                X1 = X1 + OriginDrawOfst.X;
                Y1 = Y1 + OriginDrawOfst.Y;
                Z1 = Z1 + OriginDrawOfst.Z;
                X2 = X2 + OriginDrawOfst.X + TaskDisp.Head2_XOffset;
                Y2 = Y2 + OriginDrawOfst.Y + TaskDisp.Head2_YOffset;

                #region Select Head
                bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
                bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
                if (SyncHead2)
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
                }
                else
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
                }

                if (!b_Head1Run && !b_Head2Run) goto _End;
                #endregion

                bool b_PreMoveZ = (Line.IPara[3] > 0) && b_Flag_ConsecutiveUnit;

                #region Z Correction
                Z1 = Z1 + TaskDisp.Head_Ofst[0].Z;
                double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z) - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z);
                Z2 = Z1 + ZDiff;
                #endregion

                #region Update Z Offset
                Z1 = Z1 + TaskDisp.Z1Offset;
                Z2 = Z2 + TaskDisp.Z2Offset + TaskDisp.Head2_ZOffset;
                #endregion

                EDotMode DotMode = (EDotMode)Line.IPara[1];

                try
                {
                    #region Set Volume
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            #region
                            double VolToDispA_ul = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj;
                            double VolToDispB_ul = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj;

                            if (rt_Head1VolumeOfst != 0)
                            {
                                VolToDispA_ul = VolToDispA_ul + rt_Head1VolumeOfst;
                            }
                            if (rt_Head2VolumeOfst != 0)
                            {
                                VolToDispB_ul = VolToDispB_ul + rt_Head2VolumeOfst;
                            }
                            if (Model.DispVol > 0)
                            {
                                VolToDispA_ul = Model.DispVol;
                                VolToDispB_ul = Model.DispVol;
                            }

                            if (Disp)
                            {
                                switch (Pump_Type)
                                {
                                    case TaskDisp.EPumpType.PP:
                                    case TaskDisp.EPumpType.PP2D:
                                    case TaskDisp.EPumpType.PPD:
                                        if (VolToDispA_ul != progDispVol[0] || VolToDispB_ul != progDispVol[1])
                                        {
                                            if (!TaskDisp.SetDispVolume(b_Head1Run, b_Head2Run, VolToDispA_ul, VolToDispB_ul))
                                            {
                                                Msg MsgBox = new Msg();
                                                MsgBox.Show(ErrCode.DISPCTRL1_COMM_ERR, "SetDispVolume ");
                                                goto _Stop;
                                            }
                                            if (b_Head1Run) progDispVol[0] = VolToDispA_ul;
                                            if (b_Head2Run) progDispVol[1] = VolToDispB_ul;
                                        }
                                        if (Model.BSuckVol > 0)
                                        {
                                            if (!TaskDisp.Thread_SetBackSuckVolume_Run(b_Head1Run, b_Head2Run, Model.BSuckVol, Model.BSuckVol)) goto _Stop;
                                        }
                                        if (Model.PumpSpeed > 0)
                                        {
                                            if (!TaskDisp.Thread_SetDispSpeed_Run(b_Head1Run, b_Head2Run, Model.PumpSpeed, Model.PumpSpeed)) goto _Stop;
                                        }
                                        break;
                                    case TaskDisp.EPumpType.Vermes:
                                        for (int i = 0; i < 2; i++)
                                        {
                                            if (TaskDisp.Vermes3200[i].IsOpen)
                                            {
                                                if (TaskDisp.Vermes3200[i].Param.NP != 1)
                                                {
                                                    TaskDisp.Vermes3200[i].Param.NP = 1;
                                                    TaskDisp.Vermes3200[i].Set();
                                                }
                                            }
                                        }
                                        break;
                                    case TaskDisp.EPumpType.Vermes1560:
                                        for (int i = 0; i < 2; i++)
                                        {
                                            if (TaskDisp.Vermes1560[i].IsOpen)
                                            {
                                                if (TaskDisp.Vermes1560[i].NP[0] != 1)
                                                {
                                                    TaskDisp.Vermes1560[i].NP[0] = 1;
                                                    TaskDisp.Vermes1560[i].UpdateSetup();
                                                }
                                            }
                                        }
                                        break;
                                }

                                if (Model.FPressA != pressVal[0] || Model.FPressB != pressVal[1])
                                {
                                    FPressCtrl.Thread.Set_PressUnit(new double[2] { Model.FPressA, Model.FPressB });
                                    pressVal = new double[] { Model.FPressA, Model.FPressB };
                                }
                            }
                            #endregion
                            break;
                        case ERunMode.Camera:
                        case ERunMode.Dry:
                            break;
                    }
                    #endregion

                    #region Move GZ2 Up if invalid
                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2 && !Head2Valid)
                    {
                        switch (RunMode)
                        {
                            case ERunMode.Normal:
                            case ERunMode.Dry:
                                if (!TaskDisp.TaskMoveGZ2Up()) return false;
                                break;
                        }
                    }
                    #endregion

                    #region move position
                    double X2_Ofst = X2 - X1;
                    double Y2_Ofst = Y2 - Y1;

                    TPos2 GXY = new TPos2(X1, Y1);
                    TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                if (!SyncHead2)
                                {
                                    if (HeadNo == EHeadNo.Head1)
                                    {
                                        GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                        GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;
                                    }
                                    if (HeadNo == EHeadNo.Head2)
                                    {
                                        GXY.X = GXY.X + TaskDisp.Head_Ofst[1].X;
                                        GXY.Y = GXY.Y + TaskDisp.Head_Ofst[1].Y;
                                    }
                                }
                                else
                                {
                                    GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                    GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;

                                    GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + X2_Ofst;
                                    GX2Y2.Y = GX2Y2.Y + Y2_Ofst;
                                }
                                break;
                            }
                        case ERunMode.Camera:
                        default:
                            {
                                break;
                            }
                    }
                    #endregion

                    #region If ZPlane Valid, Update Z Values
                    double LX1 = GXY.X - TaskDisp.Head_Ofst[0].X;
                    double LY1 = GXY.Y - TaskDisp.Head_Ofst[0].Y;
                    double LX2 = LX1 + (X2 - X1);
                    double LY2 = LY1 + (Y2 - Y1);
                    UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
                    #endregion

                    if (!b_PreMoveZ)
                    {
                        #region
                        if (!TaskGantry.SetMotionParamGXY()) goto _Error;
                        if (TaskDisp.Option_XYShortDistPeakSpeedRatio < 1)
                        {
                            TPos2 Curr = new TPos2();
                            Curr.X = TaskGantry.GXPos();
                            Curr.Y = TaskGantry.GYPos();
                            double Dist = Math.Sqrt(Math.Pow(GXY.X - Curr.X, 2) + Math.Pow(GXY.Y - Curr.Y, 2));

                            if (
                                (TaskDisp.Option_XYShortDist == 0 && TaskGantry.TrapezoidDrive.IsShortDist(TaskGantry.GXAxis.Para.StartV, TaskGantry.GXAxis.Para.FastV, TaskGantry.GXAxis.Para.Accel, Dist)) ||
                                (Dist <= TaskDisp.Option_XYShortDist)
                                )
                            {
                                double peakSpeed = TaskGantry.TrapezoidDrive.HalfDistSpeed(TaskGantry.GXAxis.Para.StartV, TaskGantry.GXAxis.Para.FastV, TaskGantry.GXAxis.Para.Accel, Dist);
                                peakSpeed = peakSpeed * TaskDisp.Option_XYShortDistPeakSpeedRatio;
                                if (!TaskGantry.SetMotionParamEx(TaskGantry.GXAxis, TaskGantry.GXAxis.Para.StartV, peakSpeed, TaskGantry.GXAxis.Para.Accel)) goto _Error;
                            }
                        }

                        if (!TaskGantry.MoveAbsGXY(GXY.X, GXY.Y, false)) goto _Error;
                        if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                        {
                            if (b_Head2Run)
                            {
                                if (!TaskGantry.SetMotionParamGX2Y2()) goto _Error;
                                if (!TaskGantry.MoveAbsGX2Y2(GX2Y2.X, GX2Y2.Y, false)) goto _Error;
                                TaskGantry.WaitGX2Y2();
                            }
                        }
                        TaskGantry.WaitGXY();

                        if (!b_Flag_ConsecutiveUnit)
                        {
                            #region Move to ZRetGap or ZUpGap
                            switch (RunMode)
                            {
                                case ERunMode.Normal:
                                case ERunMode.Dry:
                                    {
                                        if (!TaskGantry.SetMotionParamGZZ2(Model.DnStartV, Model.DnSpeed, Model.DnAccel)) return false;
                                        if (Model.UpGap != 0)
                                        {
                                            #region Move to ZUpGap

                                            double Z1UpGap = Z1 + Model.UpGap;
                                            if (Z1UpGap > TaskDisp.ZDefPos) Z1UpGap = TaskDisp.ZDefPos;
                                            double Z2UpGap = Z2 + Model.UpGap;
                                            if (Z2UpGap > TaskDisp.ZDefPos) Z2UpGap = TaskDisp.ZDefPos;

                                            if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1UpGap, Z2UpGap)) return false;
                                            #endregion
                                        }
                                        else
                                            if (Model.RetGap != 0)
                                        {
                                            #region Move to ZRetGap
                                            double Z1RetGap = Z1 + Model.RetGap;
                                            if (Z1RetGap > TaskDisp.ZDefPos) Z1RetGap = TaskDisp.ZDefPos;
                                            double Z2RetGap = Z2 + Model.RetGap;
                                            if (Z2RetGap > TaskDisp.ZDefPos) Z2RetGap = TaskDisp.ZDefPos;

                                            if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1RetGap, Z2RetGap)) return false;
                                            #endregion
                                        }
                                        break;
                                    }
                                case ERunMode.Camera:
                                    {
                                        break;
                                    }
                            }
                            #endregion

                            #region First Gap Wait
                            t = GDefine.GetTickCount() + Model.FirstGapWait;
                            while (GDefine.GetTickCount() < t) { }
                            { Thread.Sleep(1); }
                            #endregion
                        }

                        if (videoStart)
                        {
                            videoStart = false;
                            if (!TProcessCamera.StartVideoLog()) goto _Stop;
                        }

                        #region move z to DispGap
                        switch (RunMode)
                        {
                            case ERunMode.Normal:
                            case ERunMode.Dry:
                                {
                                    double sv = Model.DnStartV;
                                    double dv = Model.DnSpeed;
                                    double ac = Model.DnAccel;
                                    if (!TaskGantry.SetMotionParamGZZ2(sv, dv, ac)) goto _Stop;
                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1 + Model.DispGap, Z2 + Model.DispGap)) return false;
                                    break;

                                }
                            case ERunMode.Camera:
                            default:
                                {
                                    break;
                                }
                        }
                        #endregion
                        #endregion
                    }
                    else//PreMoveZ
                    {
                        #region
                        double CurX = TaskGantry.GXPos();
                        double CurY = TaskGantry.GYPos();

                        double d_XYDist = Math.Sqrt(Math.Pow(GXY.X - CurX, 2) + Math.Pow(GXY.Y - CurY, 2));
                        double t_XYMoveTime = 0;
                        TaskGantry.GetMotionData(TaskGantry.GXAxis, TaskGantry.GXAxis.Para.StartV, TaskGantry.GXAxis.Para.FastV, TaskGantry.GXAxis.Para.Accel, d_XYDist, ref t_XYMoveTime);

                        double CurZ = TaskGantry.GZPos();
                        double d_ZDist = CurZ - (Z1 + Model.DispGap);
                        if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                        {
                            double CurZ2 = TaskGantry.GZ2Pos();
                            double d_Z2Dist = CurZ2 - (Z2 + Model.DispGap);
                            d_ZDist = Math.Min(d_ZDist, d_Z2Dist);
                        }
                        double t_ZMoveTime = 0;
                        TaskGantry.GetMotionData(TaskGantry.GZAxis, Model.DnStartV, Model.DnSpeed, Model.DnAccel, d_ZDist, ref t_ZMoveTime);

                        if (!TaskGantry.SetMotionParamGXY()) goto _Error;
                        if (!TaskGantry.MoveAbsGXY(GXY.X, GXY.Y, false)) goto _Error;

                        if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                        {
                            if (!TaskGantry.SetMotionParamGX2Y2()) goto _Error;
                            if (!TaskGantry.MoveAbsGX2Y2(GX2Y2.X, GX2Y2.Y, false)) goto _Error;
                            TaskGantry.WaitGX2Y2();
                        }

                        int t_Hold = GDefine.GetTickCount();
                        if (t_XYMoveTime > t_ZMoveTime)
                            t_Hold = GDefine.GetTickCount() + (int)((t_XYMoveTime - t_ZMoveTime) * 1000);
                        while (GDefine.GetTickCount() < t_Hold)
                        {
                            Thread.Sleep(0);
                        }

                        if (videoStart)
                        {
                            videoStart = false;
                            if (!TProcessCamera.StartVideoLog()) goto _Stop;
                        }

                        #region Move Z to DispGap
                        switch (RunMode)
                        {
                            case ERunMode.Normal:
                            case ERunMode.Dry:
                                {
                                    double sv = Model.DnStartV;
                                    double dv = Model.DnSpeed;
                                    double ac = Model.DnAccel;
                                    if (!TaskGantry.SetMotionParamGZZ2(sv, dv, ac)) goto _Stop;

                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                    {
                                        if (b_Head1Run && b_Head2Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZZ2(Z1 + Model.DispGap, Z2 + Model.DispGap)) goto _Stop;
                                        }
                                        else
                                            if (b_Head1Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZ(Z1 + Model.DispGap)) goto _Stop;
                                        }
                                        else
                                                if (b_Head2Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZ2(Z2 + Model.DispGap)) goto _Stop;
                                        }
                                    }
                                    else
                                    {
                                        if (!TaskGantry.MoveAbsGZ(Z1 + Model.DispGap)) goto _Stop;
                                    }
                                    break;
                                }
                            case ERunMode.Camera:
                            default:
                                {
                                    break;
                                }
                        }
                        #endregion
                        TaskGantry.WaitGXY();
                        #endregion
                    }

                    if (DispProg.Options_EnableProcessLog)
                    {
                        string str = $"Dot\t";
                        str += $"DispGap={Model.DispGap:f3}\t";
                        str += $"C,R={RunTime.Head_CR[0].X},{RunTime.Head_CR[0].Y}\t";
                        str += $"X,Y,Z={GXY.X:f3},{GXY.Y:f3},{Z1 + Model.DispGap:f3}\t";
                        if (Head_Operation == TaskDisp.EHeadOperation.Sync)
                        {
                            str += $"C2,R2={RunTime.Head_CR[1].X},{RunTime.Head_CR[1].Y}\t";
                            str += $"X2,Y2,Z2={GX2Y2.X:f3},{GX2Y2.Y:f3},{Z2 + Model.DispGap:f3}\t";
                            double zdiff = TaskDisp.Head_ZSensor_RefPosZ[1] - TaskDisp.Head_ZSensor_RefPosZ[0];
                            str += $"X2A,Y2A,Z2A={GXY.X + X2_Ofst:f3},{GXY.Y + Y2_Ofst:f3},{Z2 + zdiff + Model.DispGap:f3}\t";
                        }

                        GLog.WriteProcessLog(str);
                    }

                    #region Down Wait
                    if (Model.DnWait > 0)
                    {
                        t = GDefine.GetTickCount() + Model.DnWait;
                        while (GDefine.GetTickCount() < t) { }// { Thread.Sleep(0); }
                    }
                    #endregion

                    if (DotMode == EDotMode.Cont)
                    {
                        #region DotMode Continuous
                        switch (RunMode)
                        {
                            case ERunMode.Normal:
                                {
                                    if (Disp)
                                    {
                                        //if (!TaskDisp.Thread_SetDispVolume_Wait()) goto _Stop;
                                        if (Model.PumpSpeed > 0) { if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop; }
                                        if (!FPressCtrl.Thread.Set_PressUnitWait()) goto _Stop;

                                        if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                        if (!TaskDisp.TrigOn(b_Head1Run, b_Head2Run)) goto _Stop;
                                        if (!TaskDisp.CtrlWaitResponse(b_Head1Run, b_Head2Run)) goto _Stop;
                                    }
                                    break;
                                }
                            case ERunMode.Dry:
                            case ERunMode.Camera:
                                {
                                    break;
                                }
                        }

                        t = GDefine.GetTickCount() + (int)(Model.StartDelay + Model.DispTime + Model.EndDelay);
                        while (GDefine.GetTickCount() < t) { };

                        switch (RunMode)
                        {
                            case ERunMode.Normal:
                                {
                                    if (Disp)
                                    {
                                        if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) goto _Stop;
                                        if (b_Head1Run) Stats.DispCount_Inc(0);
                                        if (b_Head2Run) Stats.DispCount_Inc(1);
                                    }
                                    break;
                                }
                            case ERunMode.Dry:
                            case ERunMode.Camera:
                                {
                                    break;
                                }
                        }
                        #endregion
                    }

                    bool b_ExTimedCompleted = false;
                    if (DotMode == EDotMode.ExtTimed)
                    {
                        #region DotMode ExtTimed
                        switch (RunMode)
                        {
                            case ERunMode.Normal:
                                {
                                    if (Disp)
                                    {
                                        switch (Pump_Type)
                                        {
                                            case TaskDisp.EPumpType.PP:
                                            case TaskDisp.EPumpType.PP2D:
                                            case TaskDisp.EPumpType.PPD:
                                                if (!TaskDisp.Thread_SetDispVolume_Wait()) goto _Stop;
                                                if (Model.BSuckVol > 0) { if (!TaskDisp.Thread_SetBackSuckVolume_Wait()) goto _Stop; }
                                                if (Model.PumpSpeed > 0) { if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop; }
                                                break;
                                        }

                                        if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                        if (!TaskDisp.TrigOn(b_Head1Run, b_Head2Run)) goto _Stop;
                                        if (!TaskDisp.CtrlWaitResponse(b_Head1Run, b_Head2Run)) goto _Stop;
                                        if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) goto _Stop;
                                        if (b_Head1Run) Stats.DispCount_Inc(0);// HeadAShotCount++;
                                        if (b_Head2Run) Stats.DispCount_Inc(1);// HeadBShotCount++;

                                        int t_Start = GDefine.GetTickCount() + (int)Model.StartDelay;

                                        if (Model.StartDelay > 0)
                                        {
                                            while (GDefine.GetTickCount() < t_Start)
                                            {
                                                if (Model.StartDelay > 75) Thread.Sleep(1);
                                            }
                                            TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                            goto _Ret;
                                        }

                                        if (!TaskDisp.CtrlWaitComplete(b_Head1Run, b_Head2Run)) goto _Stop;
                                        b_ExTimedCompleted = true;
                                    }
                                    break;
                                }
                            case ERunMode.Dry:
                            case ERunMode.Camera:
                                {
                                    break;
                                }
                        }
                        #endregion
                    }

                    #region post wait
                    if (Model.PostWait > 0)
                    {
                        t = GDefine.GetTickCount() + Model.PostWait;
                        while (GDefine.GetTickCount() < t)
                        {
                            TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);//) goto _Stop;
                        }
                    }
                    #endregion

                    _Ret:

                    #region Move ZRetGap, ZUpGap and ZPanelGap
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                if (Model.RetGap != 0)
                                {
                                    #region Move Ret
                                    if (!TaskGantry.SetMotionParamGZZ2(Model.RetStartV, Model.RetSpeed, Model.RetAccel)) return false;

                                    double Z1RetGap = Z1 + Model.RetGap;
                                    if (Z1RetGap > TaskDisp.ZDefPos) Z1RetGap = TaskDisp.ZDefPos;
                                    double Z2RetGap = Z2 + Model.RetGap;
                                    if (Z2RetGap > TaskDisp.ZDefPos) Z2RetGap = TaskDisp.ZDefPos;


                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1RetGap, Z2RetGap)) return false;
                                    #endregion
                                    #region Ret Wait
                                    if (Model.RetWait > 0)
                                    {
                                        t = GDefine.GetTickCount() + Model.RetWait;
                                        while (GDefine.GetTickCount() < t)
                                        {
                                            TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                        }
                                    }
                                    #endregion
                                }
                                if (videoStop)
                                {
                                    videoStop = false;
                                    TProcessCamera.StopVideoLog();
                                }
                                if (Model.UpGap != 0)
                                {
                                    #region Move Up
                                    if (!TaskGantry.SetMotionParamGZZ2(Model.UpStartV, Model.UpSpeed, Model.UpAccel)) return false;

                                    double Z1UpGap = Z1 + Model.UpGap;
                                    if (Z1UpGap > TaskDisp.ZDefPos) Z1UpGap = TaskDisp.ZDefPos;
                                    double Z2UpGap = Z2 + Model.UpGap;
                                    if (Z2UpGap > TaskDisp.ZDefPos) Z2UpGap = TaskDisp.ZDefPos;

                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1UpGap, Z2UpGap)) return false;
                                    #endregion
                                    #region Up Wait
                                    t = GDefine.GetTickCount() + Model.UpWait;
                                    while (GDefine.GetTickCount() < t)
                                    {
                                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                    }
                                    #endregion
                                }
                                break;
                            }
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }
                    #endregion

                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            {
                                if (Disp)
                                {
                                    if (!TaskDisp.IsFilling() && !b_ExTimedCompleted)
                                    {
                                        if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                    }
                                }
                                break;
                            }
                        case ERunMode.Dry:
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }

                    b_Flag_ConsecutiveUnit = true;
                    if (TaskDisp.Thread_CheckIsFilling_Error()) goto _Stop;
                }
                catch (Exception Ex)
                {
                    GDefine.Status = EStatus.ErrorInit;
                    TaskDisp.TrigOff(b_Head1Run, b_Head2Run);
                    EMsg = EMsg + (char)13 + Ex.Message.ToString();
                    throw new Exception(EMsg);
                }
                _End:
                GDefine.Status = EStatus.Ready;
                return true;
                _Stop:
                GDefine.Status = EStatus.Stop;
                return false;
                _Error:
                GDefine.Status = EStatus.ErrorInit;
                return false;
            }

            private bool DoMove(EHeadNo HeadNo, bool SyncHead2, bool Head2Valid, ERunMode RunMode, double X1, double Y1, double Z1, double X2, double Y2)
            {
                string EMsg = "DoMove";

                GDefine.Status = EStatus.Busy;

                X1 = X1 + OriginDrawOfst.X;
                Y1 = Y1 + OriginDrawOfst.Y;
                Z1 = Z1 + OriginDrawOfst.Z;
                X2 = X2 + OriginDrawOfst.X + TaskDisp.Head2_XOffset;
                Y2 = Y2 + OriginDrawOfst.Y + TaskDisp.Head2_YOffset;
                //Z2 = Z2 + OriginDrawOfst.Z;

                #region Select Head
                bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
                bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
                if (SyncHead2)
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
                }
                else
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
                }

                if (!b_Head1Run && !b_Head2Run) return true;
                #endregion

                TModelPara Model = new TModelPara(ModelList, rt_NextCmdLine.IPara[0]);
                bool b_PreMoveZ = (rt_CmdLine.IPara[3] > 0) && b_Flag_ConsecutiveUnit;
                b_PreMoveZ = b_PreMoveZ && (rt_NextCmdLine.Cmd == ECmd.LINE || rt_NextCmdLine.Cmd == ECmd.ARC || rt_NextCmdLine.Cmd == ECmd.CIRC);

                #region Z Correction
                Z1 = Z1 + TaskDisp.Head_Ofst[0].Z;
                double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z));
                double Z2 = Z1 + ZDiff;
                #endregion

                #region Update Z Offset
                Z1 = Z1 + TaskDisp.Z1Offset;
                Z2 = Z2 + TaskDisp.Z2Offset + TaskDisp.Head2_ZOffset;
                #endregion

                #region Move GZ2 Up if invalid
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2 && !Head2Valid)
                {
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            if (!TaskDisp.TaskMoveGZ2Up()) return false;
                            break;
                    }
                }
                #endregion

                try
                {
                    #region move position
                    double X2_Ofst = X2 - X1;
                    double Y2_Ofst = Y2 - Y1;

                    TPos2 GXY = new TPos2(X1, Y1);
                    TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                if (!SyncHead2)
                                {
                                    if (HeadNo == EHeadNo.Head1 || HeadNo == EHeadNo.Head12)
                                    {
                                        GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                        GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;
                                    }
                                    if (HeadNo == EHeadNo.Head2)
                                    {
                                        GXY.X = GXY.X + TaskDisp.Head_Ofst[1].X;
                                        GXY.Y = GXY.Y + TaskDisp.Head_Ofst[1].Y;
                                    }
                                }
                                else
                                {
                                    GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                    GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;

                                    GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + X2_Ofst;
                                    GX2Y2.Y = GX2Y2.Y + Y2_Ofst;
                                }
                                break;
                            }
                        case ERunMode.Camera:
                        default:
                            {
                                break;
                            }
                    }

                    #region If ZPlane Valid, Update Z Values
                    double LX1 = GXY.X - TaskDisp.Head_Ofst[0].X;
                    double LY1 = GXY.Y - TaskDisp.Head_Ofst[0].Y;

                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                    {
                        double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
                        double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
                    }
                    double LX2 = LX1 + X2_Ofst;
                    double LY2 = LY1 + Y2_Ofst;
                    UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
                    #endregion

                    if (!b_PreMoveZ)
                    {
                        if (!TaskGantry.SetMotionParamGXY()) goto _Error;
                        if (TaskDisp.Option_XYShortDistPeakSpeedRatio < 1)
                        {
                            TPos2 Curr = new TPos2();
                            Curr.X = TaskGantry.GXPos();
                            Curr.Y = TaskGantry.GYPos();
                            double Dist = Math.Sqrt(Math.Pow(GXY.X - Curr.X, 2) + Math.Pow(GXY.Y - Curr.Y, 2));

                            if (
                                (TaskDisp.Option_XYShortDist == 0 && TaskGantry.TrapezoidDrive.IsShortDist(TaskGantry.GXAxis.Para.StartV, TaskGantry.GXAxis.Para.FastV, TaskGantry.GXAxis.Para.Accel, Dist)) ||
                                (Dist <= TaskDisp.Option_XYShortDist)
                                )
                            {
                                double peakSpeed = TaskGantry.TrapezoidDrive.HalfDistSpeed(TaskGantry.GXAxis.Para.StartV, TaskGantry.GXAxis.Para.FastV, TaskGantry.GXAxis.Para.Accel, Dist);
                                peakSpeed = peakSpeed * TaskDisp.Option_XYShortDistPeakSpeedRatio;
                                if (!TaskGantry.SetMotionParamEx(TaskGantry.GXAxis, TaskGantry.GXAxis.Para.StartV, peakSpeed, TaskGantry.GXAxis.Para.Accel)) goto _Error;
                            }
                        }

                        if (!TaskGantry.MoveAbsGXY(GXY.X, GXY.Y, false)) goto _Error;
                        if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                        {
                            if (b_Head2Run)
                            {
                                if (!TaskGantry.SetMotionParamGX2Y2()) goto _Error;
                                if (!TaskGantry.MoveAbsGX2Y2(GX2Y2.X, GX2Y2.Y, false)) goto _Error;
                                //Thread.Sleep(1);
                                TaskGantry.WaitGX2Y2();
                            }
                        }
                        //else Thread.Sleep(1);
                        TaskGantry.WaitGXY();

                        if (!b_Flag_ConsecutiveUnit)
                        {
                            #region Move to ZRetGap or ZUpGap
                            switch (RunMode)
                            {
                                case ERunMode.Normal:
                                case ERunMode.Dry:
                                    {
                                        if (!TaskGantry.SetMotionParamGZZ2(Model.DnStartV, Model.DnSpeed, Model.DnAccel)) return false;
                                        if (Model.UpGap != 0)
                                        {
                                            #region Move to ZUpGap
                                            double Z1UpGap = Z1 + Model.UpGap;
                                            if (Z1UpGap > TaskDisp.ZDefPos) Z1UpGap = TaskDisp.ZDefPos;
                                            double Z2UpGap = Z2 + Model.UpGap;
                                            if (Z2UpGap > TaskDisp.ZDefPos) Z2UpGap = TaskDisp.ZDefPos;

                                            if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                            {
                                                if (b_Head1Run && b_Head2Run)
                                                {
                                                    if (!TaskGantry.MoveAbsGZZ2(Z1UpGap, Z2UpGap)) return false;
                                                }
                                                else
                                                    if (b_Head1Run)
                                                {
                                                    if (!TaskGantry.MoveAbsGZ(Z1UpGap)) return false;
                                                }
                                                else
                                                        if (b_Head2Run)
                                                {
                                                    if (!TaskGantry.MoveAbsGZ2(Z2UpGap)) return false;
                                                }
                                            }
                                            else
                                            {
                                                if (!TaskGantry.MoveAbsGZ(Z1UpGap)) return false;
                                            }
                                            #endregion
                                        }
                                        else
                                            if (Model.RetGap != 0)
                                        {
                                            #region Move to ZRetGap
                                            double Z1RetGap = Z1 + Model.RetGap;
                                            if (Z1RetGap > TaskDisp.ZDefPos) Z1RetGap = TaskDisp.ZDefPos;
                                            double Z2RetGap = Z2 + Model.RetGap;
                                            if (Z2RetGap > TaskDisp.ZDefPos) Z2RetGap = TaskDisp.ZDefPos;

                                            if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                            {
                                                if (b_Head1Run && b_Head2Run)
                                                {
                                                    if (!TaskGantry.MoveAbsGZZ2(Z1RetGap, Z2RetGap)) return false;
                                                }
                                                else
                                                    if (b_Head1Run)
                                                {
                                                    if (!TaskGantry.MoveAbsGZ(Z1RetGap)) return false;
                                                }
                                                else
                                                        if (b_Head2Run)
                                                {
                                                    if (!TaskGantry.MoveAbsGZ2(Z2RetGap)) return false;
                                                }
                                            }
                                            else
                                            {
                                                if (!TaskGantry.MoveAbsGZ(Z1RetGap)) return false;
                                            }
                                            #endregion
                                        }
                                        break;
                                    }
                                case ERunMode.Camera:
                                    {
                                        break;
                                    }
                            }
                            #endregion

                            #region First Gap Wait
                            int t = GDefine.GetTickCount() + Model.FirstGapWait;
                            while (GDefine.GetTickCount() < t) { }
                            { Thread.Sleep(1); }
                            #endregion
                        }

                        b_Flag_ConsecutiveUnit = true;
                    }
                    else//PreMoveZ
                    {
                        double CurX = TaskGantry.GXPos();
                        double CurY = TaskGantry.GYPos();

                        double d_XYDist = Math.Sqrt(Math.Pow(GXY.X - CurX, 2) + Math.Pow(GXY.Y - CurY, 2));
                        double t_XYMoveTime = 0;
                        TaskGantry.GetMotionData(TaskGantry.GXAxis, TaskGantry.GXAxis.Para.StartV, TaskGantry.GXAxis.Para.FastV, TaskGantry.GXAxis.Para.Accel, d_XYDist, ref t_XYMoveTime);

                        double CurZ = TaskGantry.GZPos();
                        double d_ZDist = CurZ - (Z1 + Model.DispGap);
                        if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                        {
                            double CurZ2 = TaskGantry.GZ2Pos();
                            double d_Z2Dist = CurZ2 - (Z2 + Model.DispGap);
                            d_ZDist = Math.Min(d_ZDist, d_Z2Dist);
                        }
                        double t_ZMoveTime = 0;
                        TaskGantry.GetMotionData(TaskGantry.GZAxis, Model.DnStartV, Model.DnSpeed, Model.DnAccel, d_ZDist, ref t_ZMoveTime);

                        if (!TaskGantry.SetMotionParamGXY()) goto _Error;
                        if (!TaskGantry.MoveAbsGXY(GXY.X, GXY.Y, false)) goto _Error;
                        if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                        {
                            if (!TaskGantry.SetMotionParamGX2Y2()) goto _Error;
                            if (!TaskGantry.MoveAbsGX2Y2(GX2Y2.X, GX2Y2.Y, false)) goto _Error;
                            TaskGantry.WaitGX2Y2();
                        }

                        int t_Hold = GDefine.GetTickCount();
                        if (t_XYMoveTime > t_ZMoveTime)
                            t_Hold = GDefine.GetTickCount() + (int)((t_XYMoveTime - t_ZMoveTime) * 1000);
                        while (GDefine.GetTickCount() < t_Hold)
                        {
                            Thread.Sleep(0);
                        }

                        #region move z to gap
                        switch (RunMode)
                        {
                            case ERunMode.Normal:
                            case ERunMode.Dry:
                                {
                                    double sv = Model.DnStartV;
                                    double dv = Model.DnSpeed;
                                    double ac = Model.DnAccel;
                                    if (!TaskGantry.SetMotionParamGZZ2(sv, dv, ac)) goto _Stop;

                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                    {
                                        if (b_Head1Run && b_Head2Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZZ2(Z1 + Model.DispGap, Z2 + Model.DispGap)) goto _Stop;
                                        }
                                        else
                                            if (b_Head1Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZ(Z1 + Model.DispGap)) goto _Stop;
                                        }
                                        else
                                                if (b_Head2Run)
                                        {
                                            if (!TaskGantry.MoveAbsGZ2(Z2 + Model.DispGap)) goto _Stop;
                                        }
                                    }
                                    else
                                    {
                                        if (!TaskGantry.MoveAbsGZ(Z1 + Model.DispGap)) goto _Stop;
                                    }
                                    break;
                                }
                            case ERunMode.Camera:
                            default:
                                {
                                    break;
                                }
                        }
                        #endregion
                        TaskGantry.WaitGXY();

                        b_Flag_ConsecutiveUnit = true;
                    }

                    if (DispProg.Options_EnableProcessLog)
                    {
                        string str = $"Move\t";
                        str += $"DispGap={Model.DispGap:f3}\t";
                        str += $"C,R={RunTime.Head_CR[0].X},{RunTime.Head_CR[0].Y}\t";
                        str += $"X,Y,Z={GXY.X:f3},{GXY.Y:f3},{Z1 + Model.DispGap:f3}\t";
                        if (Head_Operation == TaskDisp.EHeadOperation.Sync)
                        {
                            str += $"C2,R2={RunTime.Head_CR[1].X},{RunTime.Head_CR[1].Y}\t";
                            str += $"X2,Y2,Z2={GX2Y2.X:f3},{GX2Y2.Y:f3},{Z2 + Model.DispGap:f3}\t";
                            double zdiff = TaskDisp.Head_ZSensor_RefPosZ[1] - TaskDisp.Head_ZSensor_RefPosZ[0];
                            str += $"X2A,Y2A,Z2A={GXY.X + X2_Ofst:f3},{GXY.Y + Y2_Ofst:f3},{Z2 + zdiff + Model.DispGap:f3}\t";
                        }

                        GLog.WriteProcessLog(str);
                    }
                    if (videoStart)
                    {
                        videoStart = false;
                        if (!TProcessCamera.StartVideoLog()) goto _Stop;
                    }

                    #endregion
                }
                catch (Exception Ex)
                {
                    GDefine.Status = EStatus.ErrorInit;
                    EMsg = EMsg + (char)13 + Ex.Message.ToString();
                    throw new Exception(EMsg);
                }
                GDefine.Status = EStatus.Ready;
                return true;
            _Stop:
                GDefine.Status = EStatus.Stop;
                return false;
            _Error:
                GDefine.Status = EStatus.ErrorInit;
                return false;
            }

            public bool DoLine(TLine Line, EHeadNo HeadNo, bool SyncHead2, ERunMode RunMode, double DestX1, double DestY1, double Z1, double DestX2, double DestY2, bool First, bool Last)
            {
                string EMsg = "DoLine";
                int t = 0;

                GDefine.Status = EStatus.Busy;

                bool Disp = Line.IPara[2] > 0;
                double d_LineLength = 0;
                double d_G2Length = 0;

                #region Update DrawOffset
                DestX1 = DestX1 + OriginDrawOfst.X;
                DestY1 = DestY1 + OriginDrawOfst.Y;
                Z1 = Z1 + OriginDrawOfst.Z;
                DestX2 = DestX2 + OriginDrawOfst.X + TaskDisp.Head2_XOffset;
                DestY2 = DestY2 + OriginDrawOfst.Y + TaskDisp.Head2_YOffset;
                #endregion

                double X2_Ofst = DestX2 - DestX1;
                double Y2_Ofst = DestY2 - DestY1;

                double CurX = 0;
                double CurY = 0;
                CurX = TaskGantry.GXPos();
                CurY = TaskGantry.GYPos();
                double CurX2 = 0;
                double CurY2 = 0;
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                {
                    CurX2 = Math.Round(TaskGantry.GX2Pos(), 3);
                    CurY2 = Math.Round(TaskGantry.GY2Pos(), 3);
                }
                double LX1 = 0;
                double LY1 = 0;
                double LX2 = 0;
                double LY2 = 0;

                #region Select Head
                bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
                bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
                if (SyncHead2)
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
                }
                else
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
                }

                if (!b_Head1Run && !b_Head2Run) return true;
                #endregion

                #region Z Correction
                Z1 = Z1 + TaskDisp.Head_Ofst[0].Z;
                double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z) - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z);
                double Z2 = Z1 + ZDiff;
                #endregion

                #region Update Z Offset
                Z1 = Z1 + TaskDisp.Z1Offset;
                //Z2 = Z2 + TaskDisp.Z2Offset;
                Z2 = Z2 + TaskDisp.Z2Offset + TaskDisp.Head2_ZOffset;
                #endregion

                string s_Debug = "DoLine" + (char)9;

                try
                {
                    TModelPara Model = new TModelPara(ModelList, Line.IPara[0]);

                    #region Update PumpSpeed
                    if (Disp)
                    {
                        if (Model.PumpSpeed != 0)
                            if (!TaskDisp.Thread_SetDispSpeed_Run(b_Head1Run, b_Head2Run, Model.PumpSpeed, Model.PumpSpeed)) goto _Stop;
                    }
                    else
                        if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) return false;
                    #endregion

                    if (!First) goto _Cont;

                    #region Update DispVolume
                    switch (RunMode)
                    {
                        case ERunMode.Camera:
                        case ERunMode.Normal:
                            double VolToDispA_ul = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj;
                            double VolToDispB_ul = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj;

                            if (rt_Head1VolumeOfst != 0)
                            {
                                VolToDispA_ul = VolToDispA_ul + rt_Head1VolumeOfst;
                            }
                            if (rt_Head2VolumeOfst != 0)
                            {
                                VolToDispB_ul = VolToDispB_ul + rt_Head2VolumeOfst;
                            }
                            if (Model.DispVol > 0)
                            {
                                VolToDispA_ul = Model.DispVol;
                                VolToDispB_ul = Model.DispVol;
                            }

                            if (Disp)
                            {
                                switch (Pump_Type)
                                {
                                    case TaskDisp.EPumpType.PP:
                                    case TaskDisp.EPumpType.PP2D:
                                    case TaskDisp.EPumpType.PPD:
                                        if (VolToDispA_ul != progDispVol[0] || VolToDispB_ul != progDispVol[1])
                                        {
                                            if (!TaskDisp.SetDispVolume(b_Head1Run, b_Head2Run, VolToDispA_ul, VolToDispB_ul))
                                            {
                                                Msg MsgBox = new Msg();
                                                MsgBox.Show(ErrCode.DISPCTRL1_COMM_ERR, "SetDispVolume ");
                                                goto _Stop;
                                            }
                                            if (b_Head1Run) progDispVol[0] = VolToDispA_ul;
                                            if (b_Head2Run) progDispVol[1] = VolToDispB_ul;
                                        }
                                        if (Model.BSuckVol > 0)
                                        {
                                            if (!TaskDisp.Thread_SetBackSuckVolume_Run(b_Head1Run, b_Head2Run, Model.BSuckVol, Model.BSuckVol)) goto _Stop;
                                        }
                                        break;
                                }
                                if (Model.FPressA != pressVal[0] && Model.FPressB != pressVal[1])
                                {
                                    FPressCtrl.SetPress_MPa(new double[2] { Model.FPressA, Model.FPressB });
                                    pressVal = new double[] { Model.FPressA, Model.FPressB };
                                }
                            }
                            switch (DispProg.Pump_Type)
                            {
                                case TaskDisp.EPumpType.Vermes:
                                    for (int i = 0; i < 2; i++)
                                    {
                                        if (TaskDisp.Vermes3200[i].IsOpen)
                                        {
                                            if (TaskDisp.Vermes3200[i].Param.NP != 0)
                                            {
                                                TaskDisp.Vermes3200[i].Param.NP = 0;
                                                TaskDisp.Vermes3200[i].Set();
                                            }
                                        }
                                    }
                                    break;
                                case TaskDisp.EPumpType.Vermes1560:
                                    for (int i = 0; i < 2; i++)
                                    {
                                        if (TaskDisp.Vermes1560[i].IsOpen)
                                        {
                                            if (TaskDisp.Vermes1560[i].NP[0] != 0)
                                            {
                                                TaskDisp.Vermes1560[i].NP[0] = 0;
                                                TaskDisp.Vermes1560[i].UpdateSetup();
                                            }
                                        }
                                    }
                                    break;
                            }
                            break;
                    }
                    #endregion

                    #region Move Z to Disp Gap
                    CurX = TaskGantry.GXPos();
                    CurY = TaskGantry.GYPos();
                    LX1 = CurX - TaskDisp.Head_Ofst[0].X;
                    LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                    {
                        double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
                        double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
                        LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
                        LY2 = LY1 + OfstY;
                    }
                    UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                #region
                                if (!TaskGantry.SetMotionParamGZZ2(Model.DnStartV, Model.DnSpeed, Model.DnAccel)) return false;
                                if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1 + Model.DispGap, Z2 + Model.DispGap)) return false;
                                break;
                                #endregion
                            }
                        case ERunMode.Camera:
                        default:
                            {
                                break;
                            }
                    }
                    #endregion

                    #region Down Wait
                    t = GDefine.GetTickCount() + Model.DnWait;
                    while (GDefine.GetTickCount() < t) { }
                    { Thread.Sleep(1); }
                    #endregion

                    #region Wait PumpSpeed
                    if (Disp)
                    {
                        if (Model.PumpSpeed != 0)
                            if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop;
                        if (!FPressCtrl.Thread.Set_PressUnitWait()) goto _Stop;

                        if (!TaskDisp.Thread_SetDispVolume_Wait()) goto _Stop; 
                        if (Model.BSuckVol > 0) { if (!TaskDisp.Thread_SetBackSuckVolume_Wait()) goto _Stop; }
                    }
                    #endregion

                    #region Start Trigger
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            {
                                switch (Pump_Type)
                                {
                                    default:
                                        if (Disp)
                                        {
                                            if (!TaskDisp.Thread_SetDispVolume_Wait()) goto _Stop;
                                            if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                            if (!TaskDisp.TrigOn(b_Head1Run, b_Head2Run)) goto _Stop;
                                            if (!TaskDisp.CtrlWaitResponse(b_Head1Run, b_Head2Run)) goto _Stop;
                                        }
                                        break;
                                    case TaskDisp.EPumpType.TP:
                                        if (Disp) TaskDisp.TP.TrigOn();
                                        break;
                                }
                                break;
                            }
                        case ERunMode.Dry:
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }

                    #endregion

                    #region Start Delay
                    t = GDefine.GetTickCount() + (int)Model.StartDelay;
                    while (GDefine.GetTickCount() < t)
                    {
                        if (Model.StartDelay > 75) Thread.Sleep(1);
                    }
                    #endregion

                    goto _NonCont;

                    _Cont:
                    #region Continuous Trigger
                    //if (Disp && RunMode == ERunMode.Normal)
                    //{
                    //    TaskDisp.TrigOn(b_Head1Run, b_Head2Run);
                    //}
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            {
                                switch (Pump_Type)
                                {
                                    default:
                                        if (Disp) TaskDisp.TrigOn(b_Head1Run, b_Head2Run);
                                        break;
                                    case TaskDisp.EPumpType.TP:
                                        {
                                            if (Disp) TaskDisp.TP.TrigOn();
                                            break;
                                        }
                                }
                                break;
                            }
                    }
                    #endregion

                    _NonCont:
                    #region Calc Line Para
                    TPos2 GXY = new TPos2(DestX1, DestY1);
                    TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                if (!SyncHead2)
                                {
                                    if (HeadNo == EHeadNo.Head1)
                                    {
                                        GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                        GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;
                                    }
                                    if (HeadNo == EHeadNo.Head2)
                                    {
                                        GXY.X = GXY.X + TaskDisp.Head_Ofst[1].X;
                                        GXY.Y = GXY.Y + TaskDisp.Head_Ofst[1].Y;
                                    }
                                    if (HeadNo == EHeadNo.Head12)
                                    {
                                        throw new Exception("Invalid HeadNo");
                                    }
                                }
                                else
                                {
                                    GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                    GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;


                                    GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + X2_Ofst;
                                    GX2Y2.Y = GX2Y2.Y + Y2_Ofst;
                                }
                                break;
                            }
                        case ERunMode.Camera:
                        default:
                            {
                                break;
                            }
                    }

                    d_LineLength = CalcLineLength(CurX, CurY, GXY.X, GXY.Y);
                    d_G2Length = CalcLineLength(CurX2, CurY2, GX2Y2.X, GX2Y2.Y);

                    double SpeedRatio = 1;//GXY2 not move; set same speed
                    if (d_LineLength == 0 || d_G2Length == 0)
                        SpeedRatio = 1;
                    else
                    {
                        SpeedRatio = d_G2Length / d_LineLength;
                    }

                    //temp start
                    //double Model.XYDist = Math.Sqrt(Math.Pow(GXY.X - CurX, 2) + Math.Pow(GXY.Y - CurY, 2));
                    // double t_CalcMoveTime = 0;
                    //TaskGantry.GetMotionData(TaskGantry.GXAxis, Model.LineStartV, Model.LineSpeed, Model.LineAccel, Model.XYDist, ref t_CalcMoveTime);

                    //double LiftRate = 0;
                    double d_SV = Model.LineStartV;
                    double d_DV = Model.LineSpeed;
                    double d_AC = Model.LineAccel;
                    TaskGantry.GetOperationSpeed(ref d_SV, ref d_DV, ref d_AC);
                    double LiftRate = Model.LiftDist / (d_LineLength / d_DV);

                    double d_CalcMoveTime = 0;
                    TaskGantry.GetMotionDataEx(d_SV, d_DV, d_AC, d_LineLength, ref d_CalcMoveTime);

                    double d_EarlyCutoff = Line.IPara[3];
                    double d_TrigOffTime = d_CalcMoveTime * 1000 - d_EarlyCutoff;
                    #endregion

                    //temp end
                    #region Move Line
                    int t_Start = GDefine.GetTickCount();
                    if (!TaskGantry.SetMotionParamGXY(Model.LineStartV, Model.LineSpeed, Model.LineAccel)) return false;

                    int t_MoveStart = GDefine.GetTickCount();
                    if (!TaskGantry.MoveConstAbsGXY(GXY.X, GXY.Y, false)) return false;

                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                    {
                        if (b_Head2Run)
                        {
                            if (!TaskGantry.SetMotionParamGX2Y2(Model.LineStartV * SpeedRatio, Model.LineSpeed * SpeedRatio, Model.LineAccel * SpeedRatio)) goto _Stop;
                            if (!TaskGantry.MoveConstAbsGX2Y2(GX2Y2.X, GX2Y2.Y, false))
                                goto _Stop;
                        }
                    }
                    #endregion

                    if (DispProg.Options_EnableProcessLog)
                    {
                        string str = $"Line\t";
                        str += $"DispGap={Model.DispGap:f3}\t";
                        str += $"C,R={RunTime.Head_CR[0].X},{RunTime.Head_CR[0].Y}\t";
                        str += $"X,Y,Z={GXY.X:f3},{GXY.Y:f3},{Z1 + Model.DispGap:f3}\t";
                        if (Head_Operation == TaskDisp.EHeadOperation.Sync)
                        {
                            str += $"C2,R2={RunTime.Head_CR[1].X},{RunTime.Head_CR[1].Y}\t";
                            str += $"X2,Y2,Z2={GX2Y2.X:f3},{GX2Y2.Y:f3},{Z2 + Model.DispGap:f3}\t";
                            double zdiff = TaskDisp.Head_ZSensor_RefPosZ[1] - TaskDisp.Head_ZSensor_RefPosZ[0];
                            str += $"X2A,Y2A,Z2A={GXY.X + X2_Ofst:f3},{GXY.Y + Y2_Ofst:f3},{Z2 + zdiff + Model.DispGap:f3}\t";
                        }
                        GLog.WriteProcessLog(str);
                    }

                    #region Wait Complete
                    if (!TaskGantry.SetMotionParamGZZ2()) return false;
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                while (TaskGantry.IsBusyGXY())//
                                {
                                    #region If ZPlane Valid, Update Z Values
                                    CurX = TaskGantry.GXPos();
                                    CurY = TaskGantry.GYPos();
                                    LX1 = CurX - TaskDisp.Head_Ofst[0].X;
                                    LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                    {
                                        double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
                                        double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
                                        LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
                                        LY2 = LY1 + OfstY;
                                    }
                                    UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
                                    #endregion

                                    double ZLift1 = Z1;
                                    double ZLift2 = Z2;
                                    if (LiftRate != 0)
                                    {
                                        double z = (double)(GDefine.GetTickCount() - t_Start) / 1000 * LiftRate;
                                        ZLift1 = ZLift1 + z;
                                        ZLift2 = ZLift2 + z;
                                    }
                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, ZLift1 + Model.DispGap, ZLift2 + Model.DispGap)) return false;

                                    #region Early Cutoff
                                    if (d_EarlyCutoff != 0 && d_TrigOffTime > 0)
                                    {
                                        if (GDefine.GetTickCount() - t_MoveStart >= d_TrigOffTime)
                                        {
                                            d_TrigOffTime = 0;//reset time
                                            switch (RunMode)
                                            {
                                                case ERunMode.Normal:
                                                    {
                                                        switch (Pump_Type)
                                                        {
                                                            default:
                                                                #region Stop Trigger
                                                                if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) return false;
                                                                break;
                                                            #endregion
                                                            case TaskDisp.EPumpType.TP:
                                                                TaskDisp.TP.TrigOff();
                                                                break;
                                                        }
                                                        break;
                                                    }
                                                case ERunMode.Dry:
                                                case ERunMode.Camera:
                                                    {
                                                        break;
                                                    }
                                            }
                                        }
                                    }
                                    #endregion

                                    TaskDisp.CtrlError.UpdateErrorFlag();
                                }
                                if ((GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2))
                                {
                                    if (TaskGantry.IsBusyGX2Y2())
                                        if (!TaskGantry.ForceStopGX2Y2()) return false;
                                }

                                break;
                            }
                        case ERunMode.Camera:
                        default:
                            {
                                if (!TaskGantry.WaitGXY()) return false;
                                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                {
                                    if (!TaskGantry.ForceStopGX2Y2()) return false;
                                }
                                break;
                            }
                    }
                    #endregion

                    if (!First)
                    {
                        #region Wait DispSpeed
                        if (Disp)
                        {
                            if (Model.PumpSpeed != 0)
                                if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop;
                            if (!FPressCtrl.Thread.Set_PressUnitWait()) goto _Stop;
                        }
                        #endregion
                    }

                    if (!Last) goto _End;

                    #region End Delay
                    t = GDefine.GetTickCount() + (int)Model.EndDelay;
                    while (GDefine.GetTickCount() < t)
                    {
                        //TaskDisp.CheckIsFilling(b_Head1Run, b_Head2Run);
                        //Thread.Sleep(1);
                        //TaskDisp.ThreaModel.CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                        if (Model.EndDelay > 75) Thread.Sleep(1);
                    }
                    #endregion

                    #region Stop Trigger
                    if (RunMode == ERunMode.Normal)
                    {
                        switch (Pump_Type)
                        {
                            default:
                                if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) return false;
                                break;
                            case TaskDisp.EPumpType.TP:
                                TaskDisp.TP.TrigOff();
                                break;
                        }
                    }
                    #endregion

                    #region Post Wait
                    t = GDefine.GetTickCount() + Model.PostWait;
                    while (GDefine.GetTickCount() <= t)
                    {
                        //TaskDisp.CheckIsFilling(b_Head1Run, b_Head2Run);
                        //Thread.Sleep(1);
                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                    }
                    #endregion

                    #region Move ZRetGap, ZUpGap and ZPanelGap
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                if (Model.RetGap != 0)
                                {
                                    #region Move Ret
                                    if (!TaskGantry.SetMotionParamGZZ2(Model.RetStartV, Model.RetSpeed, Model.RetAccel)) return false;

                                    double Z1RetGap = Z1 + Model.RetGap;
                                    if (Z1RetGap > TaskDisp.ZDefPos) Z1RetGap = TaskDisp.ZDefPos;
                                    double Z2RetGap = Z2 + Model.RetGap;
                                    if (Z2RetGap > TaskDisp.ZDefPos) Z2RetGap = TaskDisp.ZDefPos;

                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1RetGap, Z2RetGap)) return false;
                                    #endregion
                                    #region Ret Wait
                                    t = GDefine.GetTickCount() + Model.RetWait;
                                    while (GDefine.GetTickCount() < t)
                                    {
                                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                    }
                                    #endregion
                                }
                                if (videoStop)
                                {
                                    videoStop = false;
                                    TProcessCamera.StopVideoLog();
                                }
                                if (Model.UpGap != 0)
                                {
                                    #region Move Up
                                    if (!TaskGantry.SetMotionParamGZZ2(Model.UpStartV, Model.UpSpeed, Model.UpAccel)) return false;

                                    double Z1UpGap = Z1 + Model.UpGap;
                                    if (Z1UpGap > TaskDisp.ZDefPos) Z1UpGap = TaskDisp.ZDefPos;
                                    double Z2UpGap = Z2 + Model.UpGap;
                                    if (Z2UpGap > TaskDisp.ZDefPos) Z2UpGap = TaskDisp.ZDefPos;

                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1UpGap, Z2UpGap)) return false;
                                    #endregion
                                    #region Up Wait
                                    t = GDefine.GetTickCount() + Model.UpWait;
                                    while (GDefine.GetTickCount() < t)
                                    {
                                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                    }
                                    #endregion
                                }
                                break;
                            }
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }
                    #endregion

                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            {
                                if (!TaskDisp.IsFilling())
                                {
                                    if (Disp)
                                    {
                                        if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                    }
                                }
                                break;
                            }
                        case ERunMode.Dry:
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }
                    _End:
                    { }

                    if (Last)
                    {
                        switch (RunMode)
                        {
                            case ERunMode.Normal:
                                if (Disp)
                                {
                                    if (b_Head1Run) Stats.DispCount_Inc(0);// HeadAShotCount++;
                                    if (b_Head2Run) Stats.DispCount_Inc(1);// HeadBShotCount++;}
                                }
                                break;
                        }
                    }

                    if (TaskDisp.Thread_CheckIsFilling_Error()) goto _Stop;

                    if (GDefine.LogLevel == 1) Log.AddToLog(s_Debug);
                }
                catch (Exception Ex)
                {
                    GDefine.Status = EStatus.ErrorInit;
                    TaskGantry.ForceStopGXY();
                    TaskDisp.TrigOff(b_Head1Run, b_Head2Run);
                    EMsg = EMsg + (char)13 + Ex.Message.ToString();
                    throw new Exception(EMsg);
                }
                GDefine.Status = EStatus.Ready;
                return true;
                _Stop:
                TaskDisp.TrigOff(b_Head1Run, b_Head2Run);
                GDefine.Status = EStatus.Stop;
                return false;
            }

            public bool DoArc(TLine Line, EHeadNo HeadNo, bool SyncHead2, ERunMode RunMode,
                double X1P2, double Y1P2, double X1P3, double Y1P3, double Z1,
                bool Circ, bool First, bool Last)
            {
                string EMsg = "DoArc";
                int t = 0;

                GDefine.Status = EStatus.Busy;

                bool Disp = (Line.IPara[2] > 0);

                #region
                X1P2 = X1P2 + OriginDrawOfst.X;
                Y1P2 = Y1P2 + OriginDrawOfst.Y;
                X1P3 = X1P3 + OriginDrawOfst.X;
                Y1P3 = Y1P3 + OriginDrawOfst.Y;
                Z1 = Z1 + OriginDrawOfst.Z;
                #endregion

                double CurX = 0;
                double CurY = 0;
                double LX1 = 0;
                double LY1 = 0;
                double LX2 = 0;
                double LY2 = 0;

                #region Select Head
                bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
                bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
                if (SyncHead2)
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
                }
                else
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
                }
                if (!b_Head1Run && !b_Head2Run) return true;
                #endregion

                #region Z Correction
                Z1 = Z1 + TaskDisp.Head_Ofst[0].Z;
                double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z) - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z);
                double Z2 = Z1 + ZDiff;
                #endregion

                #region Update Z Offset
                Z1 = Z1 + TaskDisp.Z1Offset;
                Z2 = Z2 + TaskDisp.Z2Offset + TaskDisp.Head2_ZOffset;
                #endregion


                try
                {
                    TModelPara Model = new TModelPara(ModelList, Line.IPara[0]);

                    #region Update PumpSpeed
                    if (Disp)
                    {
                        //double d_PumpSpeed = (short)ModelList.Model[Line.IPara[0]].Para[(int)TModelList.EModel.PumpSpeed];
                        if (Model.PumpSpeed != 0)
                            if (!TaskDisp.Thread_SetDispSpeed_Run(b_Head1Run, b_Head2Run, Model.PumpSpeed, Model.PumpSpeed)) goto _Stop;
                    }
                    else
                    {
                        if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) return false;
                    }
                    #endregion

                    if (!First) goto _Cont;

                    #region Set DispVolume
                    switch (RunMode)
                    {
                        case ERunMode.Camera:
                        case ERunMode.Normal:
                            double VolToDispA_ul = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj;
                            double VolToDispB_ul = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj;

                            if (rt_Head1VolumeOfst != 0)
                            {
                                VolToDispA_ul = VolToDispA_ul + rt_Head1VolumeOfst;
                            }
                            if (rt_Head2VolumeOfst != 0)
                            {
                                VolToDispB_ul = VolToDispB_ul + rt_Head2VolumeOfst;
                            }

                            if (Model.DispVol > 0)
                            {
                                VolToDispA_ul = Model.DispVol;
                                VolToDispB_ul = Model.DispVol;
                            }

                            if (Disp)
                            {
                                switch (Pump_Type)
                                {
                                    case TaskDisp.EPumpType.PP:
                                    case TaskDisp.EPumpType.PP2D:
                                    case TaskDisp.EPumpType.PPD:
                                        //if (!TaskDisp.Thread_SetDispVolume_Run(b_Head1Run, b_Head2Run, VolToDispA_ul, VolToDispB_ul)) goto _Stop;
                                        if (VolToDispA_ul != progDispVol[0] || VolToDispB_ul != progDispVol[1])
                                        {
                                            if (!TaskDisp.SetDispVolume(b_Head1Run, b_Head2Run, VolToDispA_ul, VolToDispB_ul))
                                            {
                                                Msg MsgBox = new Msg();
                                                MsgBox.Show(ErrCode.DISPCTRL1_COMM_ERR, "SetDispVolume ");
                                                goto _Stop;
                                            }
                                            if (b_Head1Run) progDispVol[0] = VolToDispA_ul;
                                            if (b_Head2Run) progDispVol[1] = VolToDispB_ul;
                                        }
                                        break;
                                }

                                if (Model.FPressA != pressVal[0] || Model.FPressB != pressVal[1])
                                {
                                    FPressCtrl.Thread.Set_PressUnit(new double[2] { Model.FPressA, Model.FPressB });
                                    pressVal = new double[] { Model.FPressA, Model.FPressB };
                                }
                            }
                            break;
                    }
                    #endregion

                    #region Move Z to Disp Gap
                    CurX = TaskGantry.GXPos();
                    CurY = TaskGantry.GYPos();
                    LX1 = CurX - TaskDisp.Head_Ofst[0].X;
                    LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                    {
                        double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
                        double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
                        LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
                        LY2 = LY1 + OfstY;
                    }
                    UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);

                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                #region
                                if (!TaskGantry.SetMotionParamGZZ2(Model.DnStartV, Model.DnSpeed, Model.DnAccel)) return false;
                                if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1 + Model.DispGap, Z2 + Model.DispGap)) return false;
                                break;
                                #endregion
                            }
                        case ERunMode.Camera:
                        default:
                            {
                                break;
                            }
                    }
                    #endregion

                    #region Down Wait
                    t = GDefine.GetTickCount() + Model.DnWait;
                    while (GDefine.GetTickCount() < t) { Thread.Sleep(1); }
                    #endregion

                    #region Wait DispSpeed
                    if (Disp)
                    {
                        if (Model.PumpSpeed != 0)
                            if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop;
                        if (!FPressCtrl.Thread.Set_PressUnitWait()) goto _Stop;
                    }
                    #endregion

                    #region Start Trigger
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            {
                                if (Disp)
                                {
                                    if (!TaskDisp.Thread_SetDispVolume_Wait()) goto _Stop;

                                    if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                    if (!TaskDisp.TrigOn(b_Head1Run, b_Head2Run)) goto _Stop;
                                    if (!TaskDisp.CtrlWaitResponse(b_Head1Run, b_Head2Run)) goto _Stop;
                                }
                                break;
                            }
                        case ERunMode.Dry:
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }

                    #endregion

                    #region Start Delay
                    t = GDefine.GetTickCount() + (int)Model.StartDelay;
                    while (GDefine.GetTickCount() < t)
                    {
                        if (Model.StartDelay > 75) Thread.Sleep(1);
                    }
                    #endregion

                    _Cont:
                    #region Continuous Trigger
                    if (Disp && RunMode == ERunMode.Normal)
                    {
                        switch (Pump_Type)
                        {
                            default:
                                TaskDisp.TrigOn(b_Head1Run, b_Head2Run);
                                break;
                            case TaskDisp.EPumpType.TP:
                                TaskDisp.TP.TrigOn();
                                break;
                        }
                    }
                    #endregion

                    #region Calc Arc/Arc Para
                    double d_X1P2 = X1P2;
                    double d_Y1P2 = Y1P2;
                    double d_X1P3 = X1P3;
                    double d_Y1P3 = Y1P3;
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            d_X1P2 = d_X1P2 + TaskDisp.Head_Ofst[0].X;
                            d_Y1P2 = d_Y1P2 + TaskDisp.Head_Ofst[0].Y;
                            d_X1P3 = d_X1P3 + TaskDisp.Head_Ofst[0].X;
                            d_Y1P3 = d_Y1P3 + TaskDisp.Head_Ofst[0].Y;
                            break;
                        case ERunMode.Camera:
                        default:
                            break;
                    }
                    CurX = TaskGantry.GXPos();
                    CurY = TaskGantry.GYPos();
                    double d_cX = 0; double d_cY = 0; double d_Radius = 0; double d_StartAngle = 0; double d_EndAngle = 0; double d_SweepAngle = 0; double d_DW_dir = 0;
                    if (!GDefine.Arc3PGetInfo(CurX, CurY, d_X1P2, d_Y1P2, d_X1P3, d_Y1P3, ref d_cX, ref d_cY, ref d_Radius, ref d_StartAngle, ref d_EndAngle, ref d_SweepAngle, ref d_DW_dir)) goto _Error;
                    bool Dir_CW = d_DW_dir > 0;

                    double d_Length = 0;
                    if (Circ)
                        d_Length = CalcCircLength(CurX, CurY, d_X1P2, d_Y1P2, d_X1P3, d_Y1P3);
                    else
                        d_Length = CalcArcLength(CurX, CurY, d_X1P2, d_Y1P2, d_X1P3, d_Y1P3);

                    double d_SV = Model.LineStartV;
                    double d_DV = Model.LineSpeed;
                    double d_AC = Model.LineAccel;
                    TaskGantry.GetOperationSpeed(ref d_SV, ref d_DV, ref d_AC);
                    double LiftRate = Model.LiftDist / (d_Length / d_DV);

                    double d_CalcMoveTime = 0;
                    TaskGantry.GetMotionDataEx(d_SV, d_DV, d_AC, d_Length, ref d_CalcMoveTime);

                    double d_EarlyCutoff = Line.IPara[3];
                    double d_TrigOffTime = d_CalcMoveTime * 1000 - (double)d_EarlyCutoff;
                    #endregion

                    if (!TaskGantry.SetMotionParamGXY(Model.LineStartV, Model.LineSpeed, Model.LineAccel)) return false;

                    int t_MoveStart = GDefine.GetTickCount();
                    if (Circ)
                    {
                        if (!TaskGantry.MoveConstArcCenterEndAbsGXY(d_cX, d_cY, CurX, CurY, Dir_CW, false)) goto _Stop;//return false;
                    }
                    else
                    {
                        if (!TaskGantry.MoveConstArcCenterEndAbsGXY(d_cX, d_cY, d_X1P3, d_Y1P3, Dir_CW, false)) goto _Stop;//return false;
                    }

                    if (DispProg.Options_EnableProcessLog)
                    {
                        string str = $"Arc\t";
                        //str += $"Head\t{Line.ID}\t";
                        //str += $"UnitNo\t{RunTime.UIndex}\t";
                        str += $"DispGap={Model.DispGap:f3}\t";
                        str += $"C,R={RunTime.Head_CR[0].X},{RunTime.Head_CR[0].Y}\t";
                        if (Circ)
                            str += $"X,Y,Z={CurX:f3},{CurY:f3},{Z1 + Model.DispGap:f3}\t";
                        else
                            str += $"X,Y,Z={d_X1P3:f3},{d_Y1P3:f3},{Z1 + Model.DispGap:f3}\t";

                        GLog.WriteProcessLog(str);
                    }

                    #region wait complete
                    if (!TaskGantry.SetMotionParamGZZ2()) return false;
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                while (TaskGantry.IsBusyGXY())
                                //while (CommonControl.P1245.AxisBusy(TaskGantry.GXAxis, TaskGantry.GYAxis))
                                {
                                    #region If ZPlane Valid, Update Z Values
                                    CurX = TaskGantry.GXPos();
                                    CurY = TaskGantry.GYPos();
                                    LX1 = CurX - TaskDisp.Head_Ofst[0].X;
                                    LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                    {
                                        double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
                                        double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
                                        LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
                                        LY2 = LY1 + OfstY;
                                    }
                                    UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
                                    #endregion

                                    double ZLift1 = Z1;
                                    double ZLift2 = Z2;
                                    if (LiftRate != 0)
                                    {
                                        double z = (double)(GDefine.GetTickCount() - t_MoveStart) / 1000 * LiftRate;
                                        ZLift1 = ZLift1 + z;
                                        ZLift2 = ZLift2 + z;
                                    }
                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, ZLift1 + Model.DispGap, ZLift2 + Model.DispGap)) return false;

                                    #region Early Cutoff
                                    if (d_EarlyCutoff != 0 && d_TrigOffTime > 0)
                                    {
                                        if (GDefine.GetTickCount() - t_MoveStart >= d_TrigOffTime)
                                        {
                                            d_TrigOffTime = 0;//reset time
                                            if (RunMode == ERunMode.Normal)
                                            {
                                                #region Stop Trigger
                                                switch (Pump_Type)
                                                {
                                                    default:
                                                        if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) return false;
                                                        break;
                                                    case TaskDisp.EPumpType.TP:
                                                        TaskDisp.TP.TrigOff();
                                                        break;
                                                }
                                                #endregion
                                            }
                                        }
                                    }
                                    #endregion

                                    TaskDisp.CtrlError.UpdateErrorFlag();
                                }
                                break;
                            }
                        case ERunMode.Camera:
                        default:
                            {
                                if (!TaskGantry.WaitGXY()) return false;
                                break;
                            }
                    }
                    #endregion

                    int t_Temp = GDefine.GetTickCount() - t_MoveStart;


                    if (!First)
                    {
                        #region Wait DispSpeed
                        if (Disp)
                        {
                            if (Model.PumpSpeed != 0)
                                if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop;
                            if (!FPressCtrl.Thread.Set_PressUnitWait()) goto _Stop;
                        }
                        #endregion
                    }

                    if (!Last) goto _End;

                    #region End Delay
                    //if (t_EndDelay > 0)
                    //{
                    t = GDefine.GetTickCount() + (int)Model.EndDelay;
                    // if (t_EndDelay > 5) Thread.Sleep(5);
                    while (GDefine.GetTickCount() < t)
                    {
                        //TaskDisp.CheckIsFilling(b_Head1Run, b_Head2Run);
                        //Thread.Sleep(0);
                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                    }
                    //}
                    #endregion

                    #region Stop Trigger
                    if (RunMode == ERunMode.Normal)
                    {
                        switch (Pump_Type)
                        {
                            default:
                                if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) return false;
                                break;
                            case TaskDisp.EPumpType.TP:
                                TaskDisp.TP.TrigOff();
                                break;
                        }
                    }
                    #endregion

                    #region Post Wait
                    t = GDefine.GetTickCount() + Model.PostWait;
                    while (GDefine.GetTickCount() <= t)
                    {
                        //TaskDisp.CheckIsFilling(b_Head1Run, b_Head2Run);
                        //Thread.Sleep(1);
                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                    }
                    #endregion

                    #region Move ZRetGap, ZUpGap and ZPanelGap
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                if (Model.RetGap != 0)
                                {
                                    #region Move Ret
                                    if (!TaskGantry.SetMotionParamGZZ2(Model.RetStartV, Model.RetSpeed, Model.RetAccel)) return false;

                                    double Z1RetGap = Z1 + Model.RetGap;
                                    if (Z1RetGap > TaskDisp.ZDefPos) Z1RetGap = TaskDisp.ZDefPos;
                                    double Z2RetGap = Z2 + Model.RetGap;
                                    if (Z2RetGap > TaskDisp.ZDefPos) Z2RetGap = TaskDisp.ZDefPos;

                                    //if (GDefine.GantryConfig != GDefine.EGantryConfig.XY_ZX2Y2_Z2 && SyncHead2)
                                    //{
                                    //    if (!TaskGantry.MoveAbsGZ(Z1RetGap)) return false;
                                    //}
                                    //else
                                    //{
                                    //    if (b_Head1Run && b_Head2Run)
                                    //    {
                                    //        if (!TaskGantry.MoveAbsGZZ2(Z1RetGap, Z2RetGap)) return false;
                                    //    }
                                    //    else
                                    //        if (b_Head1Run)
                                    //        {
                                    //            if (!TaskGantry.MoveAbsGZ(Z1RetGap)) return false;
                                    //        }
                                    //        else
                                    //            if (b_Head2Run)
                                    //            {
                                    //                if (!TaskGantry.MoveAbsGZ2(Z2RetGap)) return false;
                                    //            }
                                    //}
                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1RetGap, Z2RetGap)) return false;
                                    #endregion
                                    #region Ret Wait
                                    t = GDefine.GetTickCount() + Model.RetWait;
                                    while (GDefine.GetTickCount() < t)
                                    {
                                        //TaskDisp.CheckIsFilling(b_Head1Run, b_Head2Run);
                                        //Thread.Sleep(0);
                                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                    }
                                    #endregion
                                }
                                if (Model.UpGap != 0)
                                {
                                    #region Move Up
                                    if (!TaskGantry.SetMotionParamGZZ2(Model.UpStartV, Model.UpSpeed, Model.UpAccel)) return false;

                                    double Z1UpGap = Z1 + Model.UpGap;
                                    if (Z1UpGap > TaskDisp.ZDefPos) Z1UpGap = TaskDisp.ZDefPos;
                                    double Z2UpGap = Z2 + Model.UpGap;
                                    if (Z2UpGap > TaskDisp.ZDefPos) Z2UpGap = TaskDisp.ZDefPos;

                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1UpGap, Z2UpGap)) return false;
                                    #endregion
                                    #region Up Wait
                                    t = GDefine.GetTickCount() + Model.UpWait;
                                    while (GDefine.GetTickCount() < t)
                                    {
                                        //TaskDisp.CheckIsFilling(b_Head1Run, b_Head2Run);
                                        //Thread.Sleep(0);
                                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                    }
                                    #endregion
                                }
                                //REM LastInCluster
                                //if (LastInCluster && b_MovePanelGap && Model.PanelGap != 0)
                                //{
                                //    #region Move Panel Gap
                                //    if (!TaskGantry.SetMotionParamGZZ2()) goto _Stop;

                                //    double Z1PanelGap = Z1 + Model.PanelGap;
                                //    if (Z1PanelGap > TaskDisp.ZDefPos) Z1PanelGap = TaskDisp.ZDefPos;
                                //    double Z2PanelGap = Z2 + Model.PanelGap;
                                //    if (Z2PanelGap > TaskDisp.ZDefPos) Z2PanelGap = TaskDisp.ZDefPos;

                                //    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1PanelGap, Z2PanelGap)) return false;
                                //    #endregion
                                //}
                                break;
                            }
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }
                    #endregion

                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            {
                                if (!TaskDisp.IsFilling())
                                {
                                    if (Disp)
                                    {
                                        if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                    }
                                }
                                break;
                            }
                        case ERunMode.Dry:
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }
                    _End:
                    { }
                    if (TaskDisp.Thread_CheckIsFilling_Error()) goto _Stop;
                }
                catch (Exception Ex)
                {
                    GDefine.Status = EStatus.ErrorInit;
                    TaskGantry.ForceStopGXY();
                    TaskDisp.TrigOff(b_Head1Run, b_Head2Run);
                    EMsg = EMsg + (char)13 + Ex.Message.ToString();
                    throw new Exception(EMsg);
                }
                GDefine.Status = EStatus.Ready;
                return true;
                _Stop:
                TaskDisp.TrigOff(b_Head1Run, b_Head2Run);
                GDefine.Status = EStatus.Stop;
                return false;
                _Error:
                TaskDisp.TrigOff(b_Head1Run, b_Head2Run);
                EMsg = EMsg + " Unknown Error";
                throw new Exception(EMsg);
            }

            //public bool DoSmCirc(TLine Line, EHeadNo HeadNo, bool SyncHead2, ERunMode RunMode, double X1P2, double Y1P2, double X1P3, double Y1P3, double Z1)
            //{
            //    string EMsg = "DoSmCirc";
            //    int t = 0;

            //    GDefine.Status = EStatus.Busy;

            //    #region Update RunMode Position
            //    switch (RunMode)
            //    {
            //        case ERunMode.Normal:
            //        case ERunMode.Dry:
            //            X1P2 = X1P2 + TaskDisp.Head_Ofst[0].X;
            //            Y1P2 = Y1P2 + TaskDisp.Head_Ofst[0].Y;
            //            X1P3 = X1P3 + TaskDisp.Head_Ofst[0].X;
            //            Y1P3 = Y1P3 + TaskDisp.Head_Ofst[0].Y;
            //            break;
            //        case ERunMode.Camera:
            //        default:
            //            break;
            //    }
            //    #endregion

            //    double StartX = TaskGantry.GXPos();
            //    double StartY = TaskGantry.GYPos();
            //    double CenterX = 0; double CenterY = 0; double Dir = 0;
            //    double SA_EndX = 0; double SA_EndY = 0;//StartArc
            //    double MA_EndX = 0; double MA_EndY = 0;//MainArc
            //    double OA_EndX = 0; double OA_EndY = 0;//OverlapArc
            //    double EA_EndX = 0; double EA_EndY = 0;//EndArc
            //    double SA_Len = Line.DPara[2];
            //    double OA_Len = Line.DPara[3];
            //    double EA_Len = Line.DPara[4];
            //    bool Disp = Line.IPara[2] > 0;
            //    int StartModelNo = Line.IPara[0];

            //    #region Compute Points
            //    double fRad = 0;
            //    double fs = 0; double fe = 0; double fd = 0;
            //    if (!GDefine.Arc3PGetInfo(StartX, StartY, X1P2, Y1P2, X1P3, Y1P3, ref CenterX, ref CenterY, ref fRad, ref fs, ref fe, ref fd, ref Dir)) goto _Error;
            //    //if (TaskGantry.GXAxis.Para.InvertPulse) Dir = -Dir;
            //    //if (TaskGantry.GYAxis.Para.InvertPulse) Dir = -Dir;

            //    bool Dir_CW = Dir > 0;

            //    double d_MainArc_Len = 0;
            //    if (!GDefine.SmCircleGetInfo(StartX, StartY, CenterX, CenterY, Dir_CW,
            //        ref Line.DPara[2], ref d_MainArc_Len, ref Line.DPara[3], ref Line.DPara[4],
            //        ref SA_EndX, ref SA_EndY, ref MA_EndX, ref MA_EndY,
            //        ref OA_EndX, ref OA_EndY, ref EA_EndX, ref EA_EndY)) goto _Error;

            //    if (SA_Len == 0) { SA_EndX = StartX; SA_EndY = StartY; }
            //    if (OA_Len == 0) { OA_EndX = StartX; OA_EndY = StartY; }
            //    if (EA_Len == 0) { EA_EndX = OA_EndX; EA_EndY = OA_EndY; }
            //    #endregion

            //    #region Update DrawOffset
            //    CenterX = CenterX + OriginDrawOfst.X;
            //    CenterY = CenterY + OriginDrawOfst.Y;
            //    SA_EndX = SA_EndX + OriginDrawOfst.X;
            //    SA_EndY = SA_EndY + OriginDrawOfst.Y;
            //    MA_EndX = MA_EndX + OriginDrawOfst.X;
            //    MA_EndY = MA_EndY + OriginDrawOfst.Y;
            //    OA_EndX = OA_EndX + OriginDrawOfst.X;
            //    OA_EndY = OA_EndY + OriginDrawOfst.Y;
            //    EA_EndX = EA_EndX + OriginDrawOfst.X;
            //    EA_EndY = EA_EndY + OriginDrawOfst.Y;
            //    Z1 = Z1 + OriginDrawOfst.Z;
            //    #endregion

            //    double CurX = 0;
            //    double CurY = 0;
            //    double LX1 = 0;
            //    double LY1 = 0;
            //    double LX2 = 0;
            //    double LY2 = 0;

            //    //StartTick = -1;
            //    //EndTick = -1;

            //    #region Select Head
            //    bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
            //    bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
            //    if (SyncHead2)
            //    {
            //        b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
            //        b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
            //    }
            //    else
            //    {
            //        b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
            //        b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
            //    }
            //    if (!b_Head1Run && !b_Head2Run) return true;
            //    #endregion

            //    #region Z Correction
            //    Z1 = Z1 + TaskDisp.Head_Ofst[0].Z;
            //    double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z) - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z);
            //    double Z2 = Z1 + ZDiff;
            //    #endregion

            //    #region Update Z Offset
            //    Z1 = Z1 + TaskDisp.Z1Offset;
            //    //Z2 = Z2 + TaskDisp.Z2Offset;
            //    Z2 = Z2 + TaskDisp.Z2Offset + TaskDisp.Head2_ZOffset;
            //    #endregion

            //    try
            //    {
            //        #region Start Arc Set Pump Speed
            //        //UpdateModelPara(StartModelNo);
            //        TModelPara Model0 = new TModelPara(ModelList, StartModelNo);
            //        TModelPara Model1 = new TModelPara(ModelList, StartModelNo + 1);
            //        TModelPara Model2 = new TModelPara(ModelList, StartModelNo + 2);

            //        if (Disp)
            //        {
            //            if (Model0.PumpSpeed != 0)
            //                if (!TaskDisp.Thread_SetDispSpeed_Run(b_Head1Run, b_Head2Run, Model0.PumpSpeed, Model0.PumpSpeed)) goto _Stop;

            //            FPressCtrl.Thread.Set_PressUnit(new double[2] { Model0.FPressA, Model0.FPressB });
            //        }
            //        else
            //            if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) return false;
            //        #endregion

            //        #region Move Z to Disp Gap
            //        CurX = TaskGantry.GXPos();
            //        CurY = TaskGantry.GYPos();
            //        LX1 = CurX - TaskDisp.Head_Ofst[0].X;
            //        LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
            //        if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
            //        {
            //            double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
            //            double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
            //            LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
            //            LY2 = LY1 + OfstY;
            //        }
            //        UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);

            //        switch (RunMode)
            //        {
            //            case ERunMode.Normal:
            //            case ERunMode.Dry:
            //                {
            //                    #region
            //                    if (!TaskGantry.SetMotionParamGZZ2(Model0.DnStartV, Model0.DnSpeed, Model0.DnAccel)) return false;
            //                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1 + Model0.DispGap, Z2 + Model0.DispGap)) return false;
            //                    if (File.Exists(GDefine.AppPath + "\\TD_Log.txt"))
            //                    {
            //                        string S =
            //                            "H1=" + RunTime.UIndex.ToString() + "," + (Z1 + Model0.DispGap).ToString() + "," +
            //                            "H2=" + RunTime.UIndex2.ToString() + "," + (Z2 + Model0.DispGap).ToString();
            //                        Log.TD_Log.WriteByMonthDay(S);
            //                    }
            //                    break;
            //                    #endregion
            //                }
            //            case ERunMode.Camera:
            //            default:
            //                {
            //                    break;
            //                }
            //        }
            //        #endregion

            //        #region Down Wait
            //        t = GDefine.GetTickCount() + Model0.DnWait;
            //        while (GDefine.GetTickCount() < t) { Thread.Sleep(1); }
            //        #endregion

            //        #region Start Trigger
            //        switch (RunMode)
            //        {
            //            case ERunMode.Normal:
            //                {
            //                    if (Disp)
            //                    {
            //                        if (Model0.PumpSpeed != 0)
            //                            if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop;

            //                        if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
            //                        if (!TaskDisp.TrigOn(b_Head1Run, b_Head2Run)) goto _Stop;
            //                        if (b_Head1Run) Stats.DispCount_Inc(0);
            //                        if (b_Head2Run) Stats.DispCount_Inc(1);
            //                        if (!TaskDisp.CtrlWaitResponse(b_Head1Run, b_Head2Run)) goto _Stop;

            //                        if (!FPressCtrl.Thread.Set_PressUnitWait()) goto _Stop;
            //                    }
            //                    break;
            //                }
            //            case ERunMode.Dry:
            //            case ERunMode.Camera:
            //                {
            //                    break;
            //                }
            //        }
            //        #endregion

            //        #region Start Delay
            //        //t = GDefine.GetTickCount() + t_StartDelay;
            //        //while (GDefine.GetTickCount() <= t) { Thread.Sleep(1); }
            //        t = GDefine.GetTickCount() + (int)Model0.StartDelay;
            //        while (GDefine.GetTickCount() < t)
            //        {
            //            if (Model0.StartDelay > 75) Thread.Sleep(1);
            //        }
            //        #endregion

            //        if (SA_Len > 0)
            //        {
            //            #region Run StartArc
            //            try
            //            {
            //                GDefine.ArcStartCenterLengthGetEndPt(TaskGantry.GXPos(), TaskGantry.GYPos(), CenterX, CenterY, Dir_CW, SA_Len, ref SA_EndX, ref SA_EndY);
            //            }
            //            catch { throw; }
            //            if (!TaskGantry.SetMotionParamGXY(Model0.LineStartV, Model0.LineSpeed, Model0.LineAccel)) return false;
            //            if (!TaskGantry.MoveConstArcCenterEndAbsGXY(CenterX, CenterY, SA_EndX, SA_EndY, Dir_CW, false)) return false;
            //            #endregion

            //            int t_Start = GDefine.GetTickCount();

            //            #region End Arc Calc Lift Rate
            //            double LiftRate = 0;

            //            double d_SV = Model0.LineStartV;
            //            double d_DV = Model0.LineSpeed;
            //            double d_AC = Model0.LineAccel;
            //            TaskGantry.GetOperationSpeed(ref d_SV, ref d_DV, ref d_AC);

            //            double d_SA_Gap = Model0.DispGap;// ModelList.Model[Line.IPara[0]].Para[(int)TModelList.EModel.DispGap];
            //            double d_MA_Gap = Model1.DispGap;// ModelList.Model[Line.IPara[0] + 1].Para[(int)TModelList.EModel.DispGap];
            //            double d_LiftDist = d_MA_Gap - d_SA_Gap;

            //            LiftRate = d_LiftDist / (SA_Len / d_DV);
            //            #endregion

            //            #region Wait Start Arc Complete
            //            if (!TaskGantry.SetMotionParamGZZ2()) return false;
            //            switch (RunMode)
            //            {
            //                case ERunMode.Normal:
            //                case ERunMode.Dry:
            //                    {
            //                        while (TaskGantry.IsBusyGXY())
            //                        {
            //                            #region If ZPlane Valid, Update Z Values
            //                            CurX = TaskGantry.GXPos();
            //                            CurY = TaskGantry.GYPos();
            //                            LX1 = CurX - TaskDisp.Head_Ofst[0].X;
            //                            LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
            //                            if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
            //                            {
            //                                double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
            //                                double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
            //                                LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
            //                                LY2 = LY1 + OfstY;
            //                            }
            //                            UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
            //                            #endregion

            //                            double ZLift1 = Z1;
            //                            double ZLift2 = Z2;
            //                            if (LiftRate != 0)
            //                            {
            //                                double z = (double)(GDefine.GetTickCount() - t_Start) / 1000 * LiftRate;
            //                                ZLift1 = ZLift1 + z;
            //                                ZLift2 = ZLift2 + z;
            //                            }

            //                            if (!MoveZAbs(b_Head1Run, b_Head2Run, ZLift1 + Model0.DispGap, ZLift2 + Model0.DispGap)) return false;
            //                        }
            //                        break;
            //                    }
            //                case ERunMode.Camera:
            //                default:
            //                    {
            //                        if (!TaskGantry.WaitGXY()) return false;
            //                        break;
            //                    }
            //            }
            //            #endregion
            //        }

            //        #region Main Arc Change Pump Speed
            //        //UpdateModelPara(StartModelNo + 1);
            //        if (Disp)
            //            if (Model1.PumpSpeed != 0)
            //                if (!TaskDisp.Thread_SetDispSpeed_Run(b_Head1Run, b_Head2Run, Model1.PumpSpeed, Model1.PumpSpeed)) goto _Stop;
            //        #endregion

            //        #region Run Main Arc
            //        if (!TaskGantry.SetMotionParamGXY(Model1.LineStartV, Model1.LineSpeed, Model1.LineAccel)) return false;
            //        if (!TaskGantry.MoveConstArcCenterEndAbsGXY(CenterX, CenterY, MA_EndX, MA_EndY, Dir_CW, false)) return false;
            //        #endregion

            //        #region Wait Main Arc Complete
            //        if (!TaskGantry.SetMotionParamGZZ2()) return false;
            //        switch (RunMode)
            //        {
            //            case ERunMode.Normal:
            //            case ERunMode.Dry:
            //                {
            //                    while (TaskGantry.IsBusyGXY())
            //                    {
            //                        #region If ZPlane Valid, Update Z Values
            //                        CurX = TaskGantry.GXPos();
            //                        CurY = TaskGantry.GYPos();
            //                        LX1 = CurX - TaskDisp.Head_Ofst[0].X;
            //                        LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
            //                        if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
            //                        {
            //                            double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
            //                            double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
            //                            LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
            //                            LY2 = LY1 + OfstY;
            //                        }
            //                        UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
            //                        #endregion

            //                        if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1 + Model1.DispGap, Z2 + Model1.DispGap)) return false;
            //                    }
            //                    break;
            //                }
            //            case ERunMode.Camera:
            //            default:
            //                {
            //                    if (!TaskGantry.WaitGXY()) return false;
            //                    break;
            //                }
            //        }
            //        #endregion

            //        if (OA_Len > 0)
            //        {
            //            #region Run Overlap Arc
            //            try
            //            {
            //                GDefine.ArcStartCenterLengthGetEndPt(TaskGantry.GXPos(), TaskGantry.GYPos(), CenterX, CenterY, Dir_CW, OA_Len, ref OA_EndX, ref OA_EndY);
            //            }
            //            catch { throw; }
            //            if (!TaskGantry.SetMotionParamGXY(Model1.LineStartV, Model1.LineSpeed, Model1.LineAccel)) return false;
            //            if (!TaskGantry.MoveConstArcCenterEndAbsGXY(CenterX, CenterY, OA_EndX, OA_EndY, Dir_CW, false)) return false;
            //            #endregion

            //            #region Wait Overlap Arc Complete
            //            if (!TaskGantry.SetMotionParamGZZ2()) return false;
            //            switch (RunMode)
            //            {
            //                case ERunMode.Normal:
            //                case ERunMode.Dry:
            //                    {
            //                        while (TaskGantry.IsBusyGXY())
            //                        {
            //                            #region If ZPlane Valid, Update Z Values
            //                            CurX = TaskGantry.GXPos();
            //                            CurY = TaskGantry.GYPos();
            //                            LX1 = CurX - TaskDisp.Head_Ofst[0].X;
            //                            LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
            //                            if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
            //                            {
            //                                double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
            //                                double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
            //                                LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
            //                                LY2 = LY1 + OfstY;
            //                            }
            //                            UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
            //                            #endregion

            //                            if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1 + Model1.DispGap, Z2 + Model1.DispGap)) return false;
            //                        }
            //                        break;
            //                    }
            //                case ERunMode.Camera:
            //                default:
            //                    {
            //                        if (!TaskGantry.WaitGXY()) return false;
            //                        break;
            //                    }
            //            }
            //            #endregion
            //        }

            //        #region Stop Trigger
            //        switch (RunMode)
            //        {
            //            case ERunMode.Normal:
            //                {
            //                    #region Stop Trigger
            //                    if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) return false;
            //                    break;
            //                    #endregion
            //                }
            //            case ERunMode.Dry:
            //            case ERunMode.Camera:
            //                {
            //                    break;
            //                }
            //        }
            //        #endregion

            //        if (Disp)
            //        {
            //            if (Model1.PumpSpeed != 0)
            //                if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop;
            //            if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop;
            //            if (!FPressCtrl.Thread.Set_PressUnitWait()) goto _Stop;
            //        }

            //        if (EA_Len > 0)
            //        {
            //            //UpdateModelPara(Line.IPara[0] + 2);

            //            #region End Arc Run
            //            if (!TaskGantry.SetMotionParamGXY(Model2.LineStartV, Model2.LineSpeed, Model2.LineAccel)) return false;
            //            double EndOfst_CX = CenterX;
            //            double EndOfst_CY = CenterY;
            //            try
            //            {
            //                //GDefine.ArcStartCenterLengthGetEndPt(TaskGantry.GXPos(), TaskGantry.GYPos(), CenterX, CenterY, Dir_CW, EA_Len, ref EA_EndX, ref EA_EndY);

            //                double EndOfst = Line.DPara[10];
            //                GDefine.ArcStartCenterLengthGetEndPt(TaskGantry.GXPos(), TaskGantry.GYPos(), ref EndOfst_CX, ref EndOfst_CY, Dir_CW, EA_Len, EndOfst, ref EA_EndX, ref EA_EndY);
            //            }
            //            catch { throw; }
            //            //if (!TaskGantry.MoveConstArcCenterEndAbsGXY(CenterX, CenterY, EA_EndX, EA_EndY, Dir_CW, false)) return false;
            //            if (!TaskGantry.MoveConstArcCenterEndAbsGXY(EndOfst_CX, EndOfst_CY, EA_EndX, EA_EndY, Dir_CW, false)) return false;
            //            #endregion

            //            int t_Start = GDefine.GetTickCount();

            //            #region End Arc Calc Lift Rate
            //            double LiftRate = 0;

            //            double d_SV = Model2.LineStartV;
            //            double d_DV = Model2.LineSpeed;
            //            double d_AC = Model2.LineAccel;
            //            TaskGantry.GetOperationSpeed(ref d_SV, ref d_DV, ref d_AC);
            //            LiftRate = Model2.LiftDist / (EA_Len / d_DV);
            //            #endregion

            //            #region End Arc Wait Complete
            //            if (!TaskGantry.SetMotionParamGZZ2()) return false;
            //            switch (RunMode)
            //            {
            //                case ERunMode.Normal:
            //                case ERunMode.Dry:
            //                    {
            //                        while (TaskGantry.IsBusyGXY())
            //                        {
            //                            #region If ZPlane Valid, Update Z Values
            //                            CurX = TaskGantry.GXPos();
            //                            CurY = TaskGantry.GYPos();
            //                            LX1 = CurX - TaskDisp.Head_Ofst[0].X;
            //                            LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
            //                            if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
            //                            {
            //                                double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
            //                                double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
            //                                LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
            //                                LY2 = LY1 + OfstY;
            //                            }
            //                            UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
            //                            #endregion

            //                            double ZLift1 = Z1;
            //                            double ZLift2 = Z2;
            //                            if (LiftRate != 0)
            //                            {
            //                                double z = (double)(GDefine.GetTickCount() - t_Start) / 1000 * LiftRate;
            //                                ZLift1 = ZLift1 + z;
            //                                ZLift2 = ZLift2 + z;
            //                            }

            //                            if (!MoveZAbs(b_Head1Run, b_Head2Run, ZLift1 + Model2.DispGap, ZLift2 + Model2.DispGap)) return false;
            //                        }
            //                        break;
            //                    }
            //                case ERunMode.Camera:
            //                default:
            //                    {
            //                        if (!TaskGantry.WaitGXY()) return false;
            //                        break;
            //                    }
            //            }
            //            #endregion
            //        }

            //        #region End Delay
            //        t = GDefine.GetTickCount() + (int)Model2.EndDelay;
            //        while (GDefine.GetTickCount() <= t)
            //        {
            //            TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
            //        }
            //        #endregion

            //        //EndTick = GDefine.GetTickCount();

            //        #region Post Wait
            //        t = GDefine.GetTickCount() + Model2.PostWait;
            //        while (GDefine.GetTickCount() <= t)
            //        {
            //            TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
            //        }
            //        #endregion

            //        #region Move ZRetGap, ZUpGap and ZPanelGap
            //        switch (RunMode)
            //        {
            //            case ERunMode.Normal:
            //            case ERunMode.Dry:
            //                {
            //                    if (Model2.RetGap != 0)
            //                    {
            //                        #region Move Ret
            //                        if (!TaskGantry.SetMotionParamGZZ2(Model2.RetStartV, Model2.RetSpeed, Model2.RetAccel)) return false;

            //                        double Z1RetGap = Z1 + Model2.RetGap;
            //                        if (Z1RetGap > TaskDisp.ZDefPos) Z1RetGap = TaskDisp.ZDefPos;
            //                        double Z2RetGap = Z2 + Model2.RetGap;
            //                        if (Z2RetGap > TaskDisp.ZDefPos) Z2RetGap = TaskDisp.ZDefPos;

            //                        if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1RetGap, Z2RetGap)) return false;
            //                        #endregion
            //                        #region Ret Wait
            //                        t = GDefine.GetTickCount() + Model2.RetWait;
            //                        while (GDefine.GetTickCount() < t)
            //                        {
            //                            TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
            //                        }
            //                        #endregion
            //                    }
            //                    if (Model2.UpGap != 0)
            //                    {
            //                        #region Move Up
            //                        if (!TaskGantry.SetMotionParamGZZ2(Model2.UpStartV, Model2.UpSpeed, Model2.UpAccel)) return false;

            //                        double Z1UpGap = Z1 + Model2.UpGap;
            //                        if (Z1UpGap > TaskDisp.ZDefPos) Z1UpGap = TaskDisp.ZDefPos;
            //                        double Z2UpGap = Z2 + Model2.UpGap;
            //                        if (Z2UpGap > TaskDisp.ZDefPos) Z2UpGap = TaskDisp.ZDefPos;

            //                        if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1UpGap, Z2UpGap)) return false;
            //                        #endregion
            //                        #region Up Wait
            //                        t = GDefine.GetTickCount() + Model2.UpWait;
            //                        while (GDefine.GetTickCount() < t)
            //                        {
            //                            TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
            //                        }
            //                        #endregion
            //                    }
            //                    //REM LastInCluster
            //                    //if (LastInCluster && b_MovePanelGap && Model2.PanelGap != 0)
            //                    //{
            //                    //    #region Move Panel Gap
            //                    //    if (!TaskGantry.SetMotionParamGZZ2()) goto _Stop;

            //                    //    double Z1PanelGap = Z1 + Model2.PanelGap;
            //                    //    if (Z1PanelGap > TaskDisp.ZDefPos) Z1PanelGap = TaskDisp.ZDefPos;
            //                    //    double Z2PanelGap = Z2 + Model2.PanelGap;

            //                    //    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1PanelGap, Z2PanelGap)) return false;
            //                    //    #endregion
            //                    //}
            //                    break;
            //                }
            //            case ERunMode.Camera:
            //                {
            //                    break;
            //                }
            //        }
            //        #endregion

            //        switch (RunMode)
            //        {
            //            case ERunMode.Normal:
            //                {
            //                    if (!TaskDisp.IsFilling())
            //                    {
            //                        if (Disp)
            //                        {
            //                            if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
            //                        }
            //                    }
            //                    break;
            //                }
            //            case ERunMode.Dry:
            //            case ERunMode.Camera:
            //                {
            //                    break;
            //                }
            //        }
            //        if (TaskDisp.Thread_CheckIsFilling_Error()) goto _Stop;

            //    }
            //    catch (Exception Ex)
            //    {
            //        GDefine.Status = EStatus.ErrorInit;
            //        TaskGantry.ForceStopGXY();
            //        TaskDisp.TrigOff(b_Head1Run, b_Head2Run);
            //        EMsg = EMsg + (char)13 + Ex.Message.ToString();
            //        throw new Exception(EMsg);
            //    }
            //    GDefine.Status = EStatus.Ready;
            //    return true;
            //    _Stop:
            //    GDefine.Status = EStatus.Stop;
            //    return false;
            //    _Error:
            //    //TaskGantry.DispATrig(TaskGantry.TOutputState.Off);
            //    TaskDisp.TrigOff(true, true);
            //    EMsg = EMsg + " Unknown Error";
            //    throw new Exception(EMsg);
            //}
            //public bool DoSmCirc2(TLine Line, EHeadNo HeadNo, bool SyncHead2, ERunMode RunMode, double X1P2, double Y1P2, double X1P3, double Y1P3, double Z1)
            //{
            //    string EMsg = "DoSmCirc";
            //    int t = 0;

            //    GDefine.Status = EStatus.Busy;

            //    #region Update RunMode Position
            //    switch (RunMode)
            //    {
            //        case ERunMode.Normal:
            //        case ERunMode.Dry:
            //            X1P2 = X1P2 + TaskDisp.Head_Ofst[0].X;
            //            Y1P2 = Y1P2 + TaskDisp.Head_Ofst[0].Y;
            //            X1P3 = X1P3 + TaskDisp.Head_Ofst[0].X;
            //            Y1P3 = Y1P3 + TaskDisp.Head_Ofst[0].Y;
            //            break;
            //        case ERunMode.Camera:
            //        default:
            //            break;
            //    }
            //    #endregion

            //    double StartX = TaskGantry.GXPos();
            //    double StartY = TaskGantry.GYPos();
            //    double CenterX = 0; double CenterY = 0; double Dir = 0;
            //    double SA_EndX = 0; double SA_EndY = 0;//StartArc
            //    double MA_EndX = 0; double MA_EndY = 0;//MainArc
            //    double OA_EndX = 0; double OA_EndY = 0;//OverlapArc
            //    double EA_EndX = 0; double EA_EndY = 0;//EndArc
            //    double SA_Len = Line.DPara[2];
            //    double OA_Len = Line.DPara[3];
            //    double EA_Len = Line.DPara[4];
            //    bool Disp = Line.IPara[2] > 0;
            //    int StartModelNo = Line.IPara[0];
            //    TModelPara[] Model = new TModelPara[3] { new TModelPara(ModelList, StartModelNo), new TModelPara(ModelList, StartModelNo + 1), new TModelPara(ModelList, StartModelNo + 2) };

            //    #region Compute Points
            //    double fRad = 0;
            //    double fs = 0; double fe = 0; double fd = 0;
            //    if (!GDefine.Arc3PGetInfo(StartX, StartY, X1P2, Y1P2, X1P3, Y1P3, ref CenterX, ref CenterY, ref fRad, ref fs, ref fe, ref fd, ref Dir)) goto _Error;

            //    bool Dir_CW = Dir > 0;

            //    double d_MainArc_Len = 0;
            //    if (!GDefine.SmCircleGetInfo(StartX, StartY, CenterX, CenterY, Dir_CW,
            //        ref Line.DPara[2], ref d_MainArc_Len, ref Line.DPara[3], ref Line.DPara[4],
            //        ref SA_EndX, ref SA_EndY, ref MA_EndX, ref MA_EndY,
            //        ref OA_EndX, ref OA_EndY, ref EA_EndX, ref EA_EndY)) goto _Error;

            //    if (SA_Len == 0) { SA_EndX = StartX; SA_EndY = StartY; }
            //    if (OA_Len == 0) { OA_EndX = StartX; OA_EndY = StartY; }
            //    if (EA_Len == 0) { EA_EndX = OA_EndX; EA_EndY = OA_EndY; }

            //    double SA_SV = 0;// Model[0].LineStartV;
            //    double SA_DV = Model[0].LineSpeed;
            //    double SA_AC = Model[0].LineAccel;
            //    TaskGantry.GetOperationSpeed(ref SA_SV, ref SA_DV, ref SA_AC);
            //    double SA_LiftDist = Model[1].DispGap - Model[0].DispGap;
            //    double SA_LiftRate = SA_LiftDist / (SA_Len / SA_DV);

            //    double EA_SV = 0;// Model[2].LineStartV;
            //    double EA_DV = Model[2].LineSpeed;
            //    double EA_AC = Model[2].LineAccel;
            //    TaskGantry.GetOperationSpeed(ref EA_SV, ref EA_DV, ref EA_AC);
            //    double EA_LiftDist = Model[2].LiftDist;
            //    double EA_LiftRate = EA_LiftDist / (EA_Len / EA_DV);
            //    #endregion

            //    #region Update DrawOffset
            //    CenterX = CenterX + OriginDrawOfst.X;
            //    CenterY = CenterY + OriginDrawOfst.Y;
            //    SA_EndX = SA_EndX + OriginDrawOfst.X;
            //    SA_EndY = SA_EndY + OriginDrawOfst.Y;
            //    MA_EndX = MA_EndX + OriginDrawOfst.X;
            //    MA_EndY = MA_EndY + OriginDrawOfst.Y;
            //    OA_EndX = OA_EndX + OriginDrawOfst.X;
            //    OA_EndY = OA_EndY + OriginDrawOfst.Y;
            //    EA_EndX = EA_EndX + OriginDrawOfst.X;
            //    EA_EndY = EA_EndY + OriginDrawOfst.Y;
            //    Z1 = Z1 + OriginDrawOfst.Z;
            //    #endregion

            //    double CurX = 0;
            //    double CurY = 0;
            //    double LX1 = 0;
            //    double LY1 = 0;
            //    double LX2 = 0;
            //    double LY2 = 0;

            //    #region Select Head
            //    bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
            //    bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
            //    if (SyncHead2)
            //    {
            //        b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
            //        b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
            //    }
            //    else
            //    {
            //        b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
            //        b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
            //    }
            //    if (!b_Head1Run && !b_Head2Run) return true;
            //    #endregion

            //    #region Z Correction
            //    Z1 = Z1 + TaskDisp.Head_Ofst[0].Z;
            //    double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z) - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z);
            //    double Z2 = Z1 + ZDiff;
            //    #endregion

            //    #region Update Z Offset
            //    Z1 = Z1 + TaskDisp.Z1Offset;
            //    Z2 = Z2 + TaskDisp.Z2Offset + TaskDisp.Head2_ZOffset;
            //    #endregion

            //    try
            //    {
            //        #region Set Pump Speed
            //        if (RunMode == ERunMode.Normal && Disp)
            //        {
            //            if (Model[0].PumpSpeed != 0)
            //                if (!TaskDisp.Thread_SetDispSpeed_Run(b_Head1Run, b_Head2Run, Model[0].PumpSpeed, Model[0].PumpSpeed)) goto _Stop;
            //            FPressCtrl.Thread.Set_PressUnit(new double[2] { Model[0].FPressA, Model[0].FPressB });
            //        }
            //        else
            //            if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) return false;
            //        #endregion

            //        #region Construct Path
            //        CommonControl.P1245.PathBlendTime(TaskGantry.GXAxis, 100);
            //        CommonControl.P1245.SetAccel(TaskGantry.GXAxis, TaskGantry.GYAxis, Model[0].LineAccel);

            //        CommonControl.P1245.PathFree(TaskGantry.GXAxis);
            //        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, CControl2.EMoveCmd.Delay, true, 0, (double)Model[0].DnWait / 1000, 0, 0, 0, 0);
            //        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, CControl2.EMoveCmd.Delay, true, 0, (double)Model[0].StartDelay / 1000, 0, 0, 0, 0);

            //        CControl2.EMoveCmd MoveCmd = CControl2.EMoveCmd.Abs2DArcCCW;
            //        if (Dir_CW) MoveCmd = CControl2.EMoveCmd.Abs2DArcCW;
            //        if (SA_Len > 0)
            //        {
            //            CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, MoveCmd, false, 0, Model[0].LineSpeed, SA_EndX, SA_EndY, CenterX, CenterY);
            //        }
            //        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, MoveCmd, false, 0, Model[1].LineSpeed, MA_EndX, MA_EndY, CenterX, CenterY);
            //        if (OA_Len > 0)
            //        {
            //            CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, MoveCmd, false, 0, Model[1].LineSpeed, OA_EndX, OA_EndY, CenterX, CenterY);
            //        }
            //        if (EA_Len > 0)
            //        {
            //            CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, MoveCmd, false, 0, Model[2].LineSpeed, EA_EndX, EA_EndY, CenterX, CenterY);
            //        }

            //        //CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, CControl2.EMoveCmd.Delay, true, 0, (double)Model[2].EndDelay / 1000, 0, 0, 0, 0);
            //        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, CControl2.EMoveCmd.Delay, true, 0, (double)Model[2].PostWait / 1000, 0, 0, 0, 0);
            //        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, CControl2.EMoveCmd.EndPath, true, 0, 0, 0, 0, 0, 0);
            //        #endregion

            //        #region Move Z to Disp Gap
            //        CurX = TaskGantry.GXPos();
            //        CurY = TaskGantry.GYPos();
            //        LX1 = CurX - TaskDisp.Head_Ofst[0].X;
            //        LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
            //        if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
            //        {
            //            double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
            //            double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
            //            LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
            //            LY2 = LY1 + OfstY;
            //        }
            //        UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);

            //        switch (RunMode)
            //        {
            //            case ERunMode.Normal:
            //            case ERunMode.Dry:
            //                {
            //                    #region
            //                    if (!TaskGantry.SetMotionParamGZZ2(Model[0].DnStartV, Model[0].DnSpeed, Model[0].DnAccel)) return false;
            //                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1 + Model[0].DispGap, Z2 + Model[0].DispGap)) return false;
            //                    break;
            //                    #endregion
            //                }
            //            case ERunMode.Camera:
            //            default:
            //                {
            //                    break;
            //                }
            //        }
            //        #endregion

            //        if (!TaskGantry.SetMotionParamGZZ2()) return false;

            //        if (RunMode == ERunMode.Normal && Disp)
            //        {
            //            if (Model[0].PumpSpeed != 0)
            //                if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop;
            //            if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
            //            if (!FPressCtrl.Thread.Set_PressUnitWait()) goto _Stop;
            //        }

            //        CommonControl.P1245.PathMove(TaskGantry.GXAxis);

            //        uint cStartIndex = 2;
            //        uint cSAIndex = cStartIndex; if (SA_Len > 0) cSAIndex++;
            //        uint cMAIndex = cSAIndex; cMAIndex++;
            //        uint cOAIndex = cMAIndex; if (OA_Len > 0) cOAIndex++;
            //        uint cEAIndex = cOAIndex; if (EA_Len > 0) cEAIndex++;
            //        uint cPostWaitIndex = cEAIndex + 2;

            //        double d_Gap = 0;
            //        double d_LiftRate = 0;
            //        int t_Start = 0;

            //        int Index = -1;
            //        while (CommonControl.P1245.AxisBusy(TaskGantry.GXAxis, TaskGantry.GYAxis))
            //        //TaskGantry.isIsBusyGXY())
            //        {
            //            uint IndexNo = 0; uint CurCmd = 0; uint Remain = 0;
            //            CommonControl.P1245.PathInfo(TaskGantry.GXAxis, ref IndexNo, ref CurCmd, ref Remain);

            //            if (IndexNo >= cStartIndex)
            //            {
            //                if (Index < cStartIndex)
            //                {
            //                    Index = (int)cStartIndex;

            //                    if (RunMode == ERunMode.Normal && Disp)
            //                    {
            //                        if (!TaskDisp.TrigOn(b_Head1Run, b_Head2Run)) goto _Stop;
            //                        if (!TaskDisp.CtrlWaitResponse(b_Head1Run, b_Head2Run)) goto _Stop;
            //                        if (b_Head1Run) Stats.DispCount_Inc(0);
            //                        if (b_Head2Run) Stats.DispCount_Inc(1);
            //                    }
            //                }
            //            }

            //            if (IndexNo == cSAIndex)
            //            {
            //                if (Index != cSAIndex)
            //                {
            //                    Index = (int)cSAIndex;

            //                    t_Start = GDefine.GetTickCount();

            //                    if (RunMode == ERunMode.Normal && Disp)
            //                    {
            //                        //if (Model[0].PumpSpeed != 0)
            //                        //if (!TaskDisp.Thread2_SetDispSpeed2_Run(b_Head1Run, b_Head2Run, Model[0].PumpSpeed, Model[0].PumpSpeed)) goto _Stop;
            //                    }

            //                    d_Gap = Model[0].DispGap;
            //                    d_LiftRate = SA_LiftRate;
            //                }
            //            }
            //            if (IndexNo == cMAIndex)
            //            {
            //                #region
            //                if (Index != cMAIndex)
            //                {
            //                    Index = (int)cMAIndex;

            //                    if (RunMode == ERunMode.Normal && Disp)
            //                    {
            //                        if (Model[1].PumpSpeed != 0)
            //                            if (!TaskDisp.Thread_SetDispSpeed_Run(b_Head1Run, b_Head2Run, Model[1].PumpSpeed, Model[1].PumpSpeed)) goto _Stop;
            //                    }

            //                    d_Gap = Model[1].DispGap;
            //                    d_LiftRate = 0;
            //                }
            //                #endregion
            //            }
            //            if (IndexNo == cOAIndex)
            //            {
            //                #region
            //                if (Index != cOAIndex)
            //                {
            //                    Index = (int)cOAIndex;

            //                    d_Gap = Model[1].DispGap;
            //                    d_LiftRate = 0;
            //                }
            //                #endregion
            //            }
            //            if (IndexNo == cEAIndex)
            //            {
            //                #region
            //                if (Index != cEAIndex)
            //                {
            //                    Index = (int)cEAIndex;

            //                    if (RunMode == ERunMode.Normal)
            //                        if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) goto _Stop;

            //                    t_Start = GDefine.GetTickCount();
            //                    d_Gap = Model[2].DispGap;
            //                    d_LiftRate = EA_LiftRate;
            //                }
            //                #endregion
            //            }

            //            #region Wait Arcs Complete
            //            if (IndexNo == cSAIndex || IndexNo == cMAIndex || IndexNo == cOAIndex || IndexNo == cEAIndex)
            //                switch (RunMode)
            //                {
            //                    case ERunMode.Normal:
            //                    case ERunMode.Dry:
            //                        {
            //                            //while (TaskGantry.IsBusyGXY())
            //                            //{
            //                            #region If ZPlane Valid, Update Z Values
            //                            CurX = TaskGantry.GXPos();
            //                            CurY = TaskGantry.GYPos();
            //                            LX1 = CurX - TaskDisp.Head_Ofst[0].X;
            //                            LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
            //                            if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
            //                            {
            //                                double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
            //                                double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
            //                                LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
            //                                LY2 = LY1 + OfstY;
            //                            }
            //                            UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
            //                            #endregion

            //                            double ZLift1 = Z1;
            //                            double ZLift2 = Z2;
            //                            if (d_LiftRate != 0)
            //                            {
            //                                double z = (double)(GDefine.GetTickCount() - t_Start) / 1000 * d_LiftRate;
            //                                ZLift1 = ZLift1 + z;
            //                                ZLift2 = ZLift2 + z;
            //                            }

            //                            if (!MoveZAbs(b_Head1Run, b_Head2Run, ZLift1 + d_Gap, ZLift2 + d_Gap)) goto _Stop;
            //                            //}
            //                            break;
            //                        }
            //                    case ERunMode.Camera:
            //                    default:
            //                        {
            //                            //if (!TaskGantry.WaitGXY()) return false;
            //                            break;
            //                        }
            //                }
            //            #endregion
            //        }
            //        if (RunMode == ERunMode.Normal)
            //            if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) goto _Stop;

            //        #region Move ZRetGap, ZUpGap and ZPanelGap
            //        switch (RunMode)
            //        {
            //            case ERunMode.Normal:
            //            case ERunMode.Dry:
            //                {
            //                    if (Model[2].RetGap != 0)
            //                    {
            //                        #region Move Ret
            //                        if (!TaskGantry.SetMotionParamGZZ2(Model[2].RetStartV, Model[2].RetSpeed, Model[2].RetAccel)) return false;

            //                        double Z1RetGap = Z1 + Model[2].RetGap;
            //                        if (Z1RetGap > TaskDisp.ZDefPos) Z1RetGap = TaskDisp.ZDefPos;
            //                        double Z2RetGap = Z2 + Model[2].RetGap;
            //                        if (Z2RetGap > TaskDisp.ZDefPos) Z2RetGap = TaskDisp.ZDefPos;

            //                        if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1RetGap, Z2RetGap)) return false;
            //                        #endregion
            //                        #region Ret Wait
            //                        t = GDefine.GetTickCount() + Model[2].RetWait;
            //                        while (GDefine.GetTickCount() < t)
            //                        {
            //                            TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
            //                        }
            //                        #endregion
            //                    }
            //                    if (Model[2].UpGap != 0)
            //                    {
            //                        #region Move Up
            //                        if (!TaskGantry.SetMotionParamGZZ2(Model[2].UpStartV, Model[2].UpSpeed, Model[2].UpAccel)) return false;

            //                        double Z1UpGap = Z1 + Model[2].UpGap;
            //                        if (Z1UpGap > TaskDisp.ZDefPos) Z1UpGap = TaskDisp.ZDefPos;
            //                        double Z2UpGap = Z2 + Model[2].UpGap;
            //                        if (Z2UpGap > TaskDisp.ZDefPos) Z2UpGap = TaskDisp.ZDefPos;

            //                        if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1UpGap, Z2UpGap)) return false;
            //                        #endregion
            //                        #region Up Wait
            //                        t = GDefine.GetTickCount() + Model[2].UpWait;
            //                        while (GDefine.GetTickCount() < t)
            //                        {
            //                            TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
            //                        }
            //                        #endregion
            //                    }
            //                    //REM LastInCluster
            //                    //if (LastInCluster && b_MovePanelGap && Model[2].PanelGap != 0)
            //                    //{
            //                    //    #region Move Panel Gap
            //                    //    if (!TaskGantry.SetMotionParamGZZ2()) goto _Stop;

            //                    //    double Z1PanelGap = Z1 + Model[2].PanelGap;
            //                    //    if (Z1PanelGap > TaskDisp.ZDefPos) Z1PanelGap = TaskDisp.ZDefPos;
            //                    //    double Z2PanelGap = Z2 + Model[2].PanelGap;

            //                    //    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1PanelGap, Z2PanelGap)) return false;
            //                    //    #endregion
            //                    //}
            //                    break;
            //                }
            //            case ERunMode.Camera:
            //                {
            //                    break;
            //                }
            //        }
            //        #endregion

            //        if (RunMode == ERunMode.Normal && Disp)
            //        {
            //            if (Model[1].PumpSpeed != 0)
            //                if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop;
            //        }
            //    }
            //    catch (Exception Ex)
            //    {
            //        GDefine.Status = EStatus.ErrorInit;
            //        TaskGantry.ForceStopGXY();
            //        TaskDisp.TrigOff(b_Head1Run, b_Head2Run);
            //        EMsg = EMsg + (char)13 + Ex.Message.ToString();
            //        throw new Exception(EMsg);
            //    }
            //    GDefine.Status = EStatus.Ready;
            //    return true;
            //    _Stop:
            //    TaskGantry.DispATrigSet(TaskGantry.TOutputState.Off);
            //    TaskGantry.DispBTrigSet(TaskGantry.TOutputState.Off);
            //    GDefine.Status = EStatus.Stop;
            //    return false;
            //    _Error:
            //    TaskGantry.DispATrigSet(TaskGantry.TOutputState.Off);
            //    TaskGantry.DispBTrigSet(TaskGantry.TOutputState.Off);
            //    EMsg = EMsg + " Unknown Error";
            //    throw new Exception(EMsg);
            //}
            //public bool DoSmCirc3(TLine Line, EHeadNo HeadNo, bool SyncHead2, ERunMode RunMode, double X1P2, double Y1P2, double X1P3, double Y1P3, double Z1)
            //{
            //    string EMsg = "DoSmCirc";
            //    int t = 0;

            //    GDefine.Status = EStatus.Busy;

            //    #region Update RunMode Position
            //    switch (RunMode)
            //    {
            //        case ERunMode.Normal:
            //        case ERunMode.Dry:
            //            X1P2 = X1P2 + TaskDisp.Head_Ofst[0].X;
            //            Y1P2 = Y1P2 + TaskDisp.Head_Ofst[0].Y;
            //            X1P3 = X1P3 + TaskDisp.Head_Ofst[0].X;
            //            Y1P3 = Y1P3 + TaskDisp.Head_Ofst[0].Y;
            //            break;
            //        case ERunMode.Camera:
            //        default:
            //            break;
            //    }
            //    #endregion

            //    double StartX = TaskGantry.GXPos();
            //    double StartY = TaskGantry.GYPos();
            //    double CenterX = 0; double CenterY = 0; double Dir = 0;
            //    double SA_EndX = 0; double SA_EndY = 0;//StartArc
            //    double MA_EndX = 0; double MA_EndY = 0;//MainArc
            //    double OA_EndX = 0; double OA_EndY = 0;//OverlapArc
            //    double EA_EndX = 0; double EA_EndY = 0;//EndArc
            //    double SA_Len = Line.DPara[2];
            //    double OA_Len = Line.DPara[3];
            //    double EA_Len = Line.DPara[4];
            //    bool Disp = Line.IPara[2] > 0;
            //    int StartModelNo = Line.IPara[0];
            //    TModelPara[] Model = new TModelPara[3] { new TModelPara(ModelList, StartModelNo), new TModelPara(ModelList, StartModelNo + 1), new TModelPara(ModelList, StartModelNo + 2) };

            //    #region Compute Points
            //    double fRad = 0;
            //    double fs = 0; double fe = 0; double fd = 0;
            //    if (!GDefine.Arc3PGetInfo(StartX, StartY, X1P2, Y1P2, X1P3, Y1P3, ref CenterX, ref CenterY, ref fRad, ref fs, ref fe, ref fd, ref Dir)) goto _Error;

            //    bool Dir_CW = Dir > 0;

            //    double d_MainArc_Len = 0;
            //    if (!GDefine.SmCircleGetInfo(StartX, StartY, CenterX, CenterY, Dir_CW,
            //        ref Line.DPara[2], ref d_MainArc_Len, ref Line.DPara[3], ref Line.DPara[4],
            //        ref SA_EndX, ref SA_EndY, ref MA_EndX, ref MA_EndY,
            //        ref OA_EndX, ref OA_EndY, ref EA_EndX, ref EA_EndY)) goto _Error;

            //    if (SA_Len == 0) { SA_EndX = StartX; SA_EndY = StartY; }
            //    if (OA_Len == 0) { OA_EndX = StartX; OA_EndY = StartY; }
            //    if (EA_Len == 0) { EA_EndX = OA_EndX; EA_EndY = OA_EndY; }

            //    double SA_SV = 0;// Model[0].LineStartV;
            //    double SA_DV = Model[0].LineSpeed;
            //    double SA_AC = Model[0].LineAccel;
            //    TaskGantry.GetOperationSpeed(ref SA_SV, ref SA_DV, ref SA_AC);
            //    double SA_LiftDist = Model[1].DispGap - Model[0].DispGap;
            //    double SA_LiftRate = SA_LiftDist / (SA_Len / SA_DV);

            //    double EA_SV = 0;// Model[2].LineStartV;
            //    double EA_DV = Model[2].LineSpeed;
            //    double EA_AC = Model[2].LineAccel;
            //    TaskGantry.GetOperationSpeed(ref EA_SV, ref EA_DV, ref EA_AC);
            //    double EA_LiftDist = Model[2].LiftDist;
            //    double EA_LiftRate = EA_LiftDist / (EA_Len / EA_DV);
            //    #endregion

            //    #region Update DrawOffset
            //    CenterX = CenterX + OriginDrawOfst.X;
            //    CenterY = CenterY + OriginDrawOfst.Y;
            //    SA_EndX = SA_EndX + OriginDrawOfst.X;
            //    SA_EndY = SA_EndY + OriginDrawOfst.Y;
            //    MA_EndX = MA_EndX + OriginDrawOfst.X;
            //    MA_EndY = MA_EndY + OriginDrawOfst.Y;
            //    OA_EndX = OA_EndX + OriginDrawOfst.X;
            //    OA_EndY = OA_EndY + OriginDrawOfst.Y;
            //    EA_EndX = EA_EndX + OriginDrawOfst.X;
            //    EA_EndY = EA_EndY + OriginDrawOfst.Y;
            //    Z1 = Z1 + OriginDrawOfst.Z;
            //    #endregion

            //    double CurX = 0;
            //    double CurY = 0;
            //    double LX1 = 0;
            //    double LY1 = 0;
            //    double LX2 = 0;
            //    double LY2 = 0;

            //    #region Select Head
            //    bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
            //    bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
            //    if (SyncHead2)
            //    {
            //        b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
            //        b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
            //    }
            //    else
            //    {
            //        b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
            //        b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
            //    }
            //    if (!b_Head1Run && !b_Head2Run) return true;
            //    #endregion

            //    #region Z Correction
            //    Z1 = Z1 + TaskDisp.Head_Ofst[0].Z;
            //    double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z) - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z);
            //    double Z2 = Z1 + ZDiff;
            //    #endregion

            //    #region Update Z Offset
            //    Z1 = Z1 + TaskDisp.Z1Offset;
            //    Z2 = Z2 + TaskDisp.Z2Offset + TaskDisp.Head2_ZOffset;
            //    #endregion

            //    try
            //    {
            //        #region Set Pump Speed
            //        if (RunMode == ERunMode.Normal && Disp)
            //        {
            //            if (Model[0].PumpSpeed != 0)
            //                if (!TaskDisp.Thread_SetDispSpeed_Run(b_Head1Run, b_Head2Run, Model[0].PumpSpeed, Model[0].PumpSpeed)) goto _Stop;
            //            //FPressCtrl.Thread.Set_PressUnit(new double[2] { Model[0].FPressA, Model[0].FPressB });
            //            if (Model[0].FPressA != pressVal[0] || Model[0].FPressB != pressVal[1])
            //            {
            //                FPressCtrl.Thread.Set_PressUnit(new double[2] { Model[0].FPressA, Model[0].FPressB });
            //                pressVal = new double[] { Model[0].FPressA, Model[0].FPressB };
            //            }
            //        }
            //        else
            //            if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) return false;
            //        #endregion

            //        #region Construct Path
            //        CommonControl.P1245.PathBlendTime(TaskGantry.GXAxis, 100);
            //        CommonControl.P1245.SetAccel(TaskGantry.GXAxis, TaskGantry.GYAxis, Model[0].LineAccel);

            //        CommonControl.P1245.PathFree(TaskGantry.GXAxis);
            //        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, CControl2.EMoveCmd.Delay, true, 0, (double)Model[0].DnWait / 1000, 0, 0, 0, 0);
            //        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, CControl2.EMoveCmd.Delay, true, 0, (double)Model[0].StartDelay / 1000, 0, 0, 0, 0);

            //        CControl2.EMoveCmd MoveCmd = CControl2.EMoveCmd.Abs2DArcCCW;
            //        if (Dir_CW) MoveCmd = CControl2.EMoveCmd.Abs2DArcCW;
            //        if (SA_Len > 0)
            //        {
            //            CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, MoveCmd, false, 0, Model[0].LineSpeed, SA_EndX, SA_EndY, CenterX, CenterY);
            //        }
            //        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, MoveCmd, false, 0, Model[1].LineSpeed, MA_EndX, MA_EndY, CenterX, CenterY);
            //        if (OA_Len > 0)
            //        {
            //            CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, MoveCmd, false, 0, Model[1].LineSpeed, OA_EndX, OA_EndY, CenterX, CenterY);
            //        }
            //        if (EA_Len > 0)
            //        {
            //            CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, MoveCmd, false, 0, Model[2].LineSpeed, EA_EndX, EA_EndY, CenterX, CenterY);
            //        }

            //        //CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, CControl2.EMoveCmd.Delay, true, 0, (double)Model[2].EndDelay / 1000, 0, 0, 0, 0);
            //        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, CControl2.EMoveCmd.Delay, true, 0, (double)Model[2].PostWait / 1000, 0, 0, 0, 0);
            //        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, CControl2.EMoveCmd.EndPath, true, 0, 0, 0, 0, 0, 0);
            //        #endregion

            //        #region Move Z to Disp Gap
            //        CurX = TaskGantry.GXPos();
            //        CurY = TaskGantry.GYPos();
            //        LX1 = CurX - TaskDisp.Head_Ofst[0].X;
            //        LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
            //        if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
            //        {
            //            double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
            //            double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
            //            LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
            //            LY2 = LY1 + OfstY;
            //        }
            //        UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);

            //        switch (RunMode)
            //        {
            //            case ERunMode.Normal:
            //            case ERunMode.Dry:
            //                {
            //                    #region
            //                    if (!TaskGantry.SetMotionParamGZZ2(Model[0].DnStartV, Model[0].DnSpeed, Model[0].DnAccel)) return false;
            //                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1 + Model[0].DispGap, Z2 + Model[0].DispGap)) return false;

            //                    if (File.Exists(GDefine.AppPath + "\\TD_Log.txt"))
            //                    {
            //                        string S =
            //                            "H1=" + RunTime.UIndex.ToString() + "," + (Z1 + Model[0].DispGap).ToString() + "," +
            //                            "H2=" + RunTime.UIndex2.ToString() + "," + (Z2 + Model[0].DispGap).ToString();
            //                        Log.TD_Log.WriteByMonthDay(S);
            //                    }
            //                    break;
            //                    #endregion
            //                }
            //            case ERunMode.Camera:
            //            default:
            //                {
            //                    break;
            //                }
            //        }
            //        #endregion

            //        if (!TaskGantry.SetMotionParamGZZ2()) return false;

            //        if (RunMode == ERunMode.Normal && Disp)
            //        {
            //            if (Model[0].PumpSpeed != 0)
            //                if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop;
            //            if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
            //            if (!FPressCtrl.Thread.Set_PressUnitWait()) goto _Stop;
            //        }

            //        CommonControl.P1245.PathMove(TaskGantry.GXAxis);

            //        uint cStartIndex = 2;
            //        uint cSAIndex = cStartIndex; if (SA_Len > 0) cSAIndex++;
            //        uint cMAIndex = cSAIndex; cMAIndex++;
            //        uint cOAIndex = cMAIndex; if (OA_Len > 0) cOAIndex++;
            //        uint cEAIndex = cOAIndex; if (EA_Len > 0) cEAIndex++;
            //        uint cPostWaitIndex = cEAIndex + 2;

            //        double d_Gap = 0;
            //        double d_LiftRate = 0;
            //        int t_Start = 0;

            //        int Index = -1;
            //        while (CommonControl.P1245.AxisBusy(TaskGantry.GXAxis, TaskGantry.GYAxis))
            //        //TaskGantry.isIsBusyGXY())
            //        {
            //            uint IndexNo = 0; uint CurCmd = 0; uint Remain = 0;
            //            CommonControl.P1245.PathInfo(TaskGantry.GXAxis, ref IndexNo, ref CurCmd, ref Remain);

            //            if (IndexNo >= cStartIndex)
            //            {
            //                #region
            //                if (Index < cStartIndex)
            //                {
            //                    Index = (int)cStartIndex;

            //                    if (RunMode == ERunMode.Normal && Disp)
            //                    {
            //                        if (!TaskDisp.TrigOn(b_Head1Run, b_Head2Run)) goto _Stop;
            //                        if (!TaskDisp.CtrlWaitResponse(b_Head1Run, b_Head2Run)) goto _Stop;
            //                        if (b_Head1Run) Stats.DispCount_Inc(0);
            //                        if (b_Head2Run) Stats.DispCount_Inc(1);
            //                    }
            //                }
            //                #endregion
            //            }

            //            if (IndexNo == cSAIndex)
            //            {
            //                #region
            //                if (Index != cSAIndex)
            //                {
            //                    Index = (int)cSAIndex;

            //                    switch (RunMode)
            //                    {
            //                        case ERunMode.Normal:
            //                        case ERunMode.Dry:
            //                            {
            //                                if (!TaskGantry.SetMotionParamGZZ2(TaskGantry.GZAxis.Para.StartV, SA_LiftRate, TaskGantry.GZAxis.Para.Accel)) goto _Stop;
            //                                if (!MoveRelZ(b_Head1Run, b_Head2Run, SA_LiftDist, SA_LiftDist)) goto _Stop;
            //                                break;
            //                            }
            //                        case ERunMode.Camera:
            //                        default:
            //                            {
            //                                break;
            //                            }
            //                    }
            //                }
            //                #endregion
            //            }
            //            if (IndexNo == cMAIndex)
            //            {
            //                #region
            //                if (Index != cMAIndex)
            //                {
            //                    Index = (int)cMAIndex;

            //                    if (RunMode == ERunMode.Normal && Disp)
            //                    {
            //                        if (Model[1].PumpSpeed != 0)
            //                            if (!TaskDisp.Thread_SetDispSpeed_Run(b_Head1Run, b_Head2Run, Model[1].PumpSpeed, Model[1].PumpSpeed)) goto _Stop;
            //                    }

            //                    d_Gap = Model[1].DispGap;
            //                    d_LiftRate = 0;
            //                }
            //                #endregion
            //            }
            //            if (IndexNo == cOAIndex)
            //            {
            //                #region
            //                if (Index != cOAIndex)
            //                {
            //                    Index = (int)cOAIndex;

            //                    d_Gap = Model[1].DispGap;
            //                    d_LiftRate = 0;
            //                }
            //                #endregion
            //            }
            //            if (IndexNo == cEAIndex)
            //            {
            //                #region
            //                if (Index != cEAIndex)
            //                {
            //                    Index = (int)cEAIndex;

            //                    if (RunMode == ERunMode.Normal)
            //                        if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) goto _Stop;

            //                    t_Start = GDefine.GetTickCount();
            //                    d_Gap = Model[2].DispGap;
            //                    d_LiftRate = EA_LiftRate;

            //                    switch (RunMode)
            //                    {
            //                        case ERunMode.Normal:
            //                        case ERunMode.Dry:
            //                            {
            //                                if (!TaskGantry.SetMotionParamGZZ2(TaskGantry.GZAxis.Para.StartV, EA_LiftRate, TaskGantry.GZAxis.Para.Accel)) goto _Stop;
            //                                if (!MoveRelZ(b_Head1Run, b_Head2Run, EA_LiftDist, EA_LiftDist)) goto _Stop;
            //                                break;
            //                            }
            //                        case ERunMode.Camera:
            //                        default:
            //                            {
            //                                break;
            //                            }
            //                    }

            //                }
            //                #endregion
            //            }

            //            #region Wait Arcs Complete
            //            //if (IndexNo == cSAIndex || IndexNo == cMAIndex || IndexNo == cOAIndex || IndexNo == cEAIndex)
            //            //    switch (RunMode)
            //            //    {
            //            //        case ERunMode.Normal:
            //            //        case ERunMode.Dry:
            //            //            {
            //            //                #region If ZPlane Valid, Update Z Values
            //            //                CurX = TaskGantry.GXPos();
            //            //                CurY = TaskGantry.GYPos();
            //            //                LX1 = CurX - TaskDisp.Head_Ofst[0].X;
            //            //                LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
            //            //                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
            //            //                {
            //            //                    double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
            //            //                    double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
            //            //                    LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
            //            //                    LY2 = LY1 + OfstY;
            //            //                }
            //            //                UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
            //            //                #endregion

            //            //                double ZLift1 = Z1;
            //            //                double ZLift2 = Z2;
            //            //                if (d_LiftRate != 0)
            //            //                {
            //            //                    double z = (double)(GDefine.GetTickCount() - t_Start) / 1000 * d_LiftRate;
            //            //                    ZLift1 = ZLift1 + z;
            //            //                    ZLift2 = ZLift2 + z;
            //            //                }

            //            //                if (!MoveZAbs(b_Head1Run, b_Head2Run, ZLift1 + d_Gap, ZLift2 + d_Gap)) goto _Stop;
            //            //                break;
            //            //            }
            //            //        case ERunMode.Camera:
            //            //        default:
            //            //            {
            //            //                break;
            //            //            }
            //            //    }
            //            #endregion
            //        }
            //        if (RunMode == ERunMode.Normal)
            //            if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) goto _Stop;

            //        #region Move ZRetGap, ZUpGap and ZPanelGap
            //        switch (RunMode)
            //        {
            //            case ERunMode.Normal:
            //            case ERunMode.Dry:
            //                {
            //                    if (Model[2].RetGap != 0)
            //                    {
            //                        #region Move Ret
            //                        if (!TaskGantry.SetMotionParamGZZ2(Model[2].RetStartV, Model[2].RetSpeed, Model[2].RetAccel)) return false;

            //                        double Z1RetGap = Z1 + Model[2].RetGap;
            //                        if (Z1RetGap > TaskDisp.ZDefPos) Z1RetGap = TaskDisp.ZDefPos;
            //                        double Z2RetGap = Z2 + Model[2].RetGap;
            //                        if (Z2RetGap > TaskDisp.ZDefPos) Z2RetGap = TaskDisp.ZDefPos;

            //                        if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1RetGap, Z2RetGap)) return false;
            //                        #endregion
            //                        #region Ret Wait
            //                        t = GDefine.GetTickCount() + Model[2].RetWait;
            //                        while (GDefine.GetTickCount() < t)
            //                        {
            //                            TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
            //                        }
            //                        #endregion
            //                    }
            //                    if (Model[2].UpGap != 0)
            //                    {
            //                        #region Move Up
            //                        if (!TaskGantry.SetMotionParamGZZ2(Model[2].UpStartV, Model[2].UpSpeed, Model[2].UpAccel)) return false;

            //                        double Z1UpGap = Z1 + Model[2].UpGap;
            //                        if (Z1UpGap > TaskDisp.ZDefPos) Z1UpGap = TaskDisp.ZDefPos;
            //                        double Z2UpGap = Z2 + Model[2].UpGap;
            //                        if (Z2UpGap > TaskDisp.ZDefPos) Z2UpGap = TaskDisp.ZDefPos;

            //                        if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1UpGap, Z2UpGap)) return false;
            //                        #endregion
            //                        #region Up Wait
            //                        t = GDefine.GetTickCount() + Model[2].UpWait;
            //                        while (GDefine.GetTickCount() < t)
            //                        {
            //                            TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
            //                        }
            //                        #endregion
            //                    }
            //                    //REM LastInCluster
            //                    //if (LastInCluster && b_MovePanelGap && Model[2].PanelGap != 0)
            //                    //{
            //                    //    #region Move Panel Gap
            //                    //    if (!TaskGantry.SetMotionParamGZZ2()) goto _Stop;

            //                    //    double Z1PanelGap = Z1 + Model[2].PanelGap;
            //                    //    if (Z1PanelGap > TaskDisp.ZDefPos) Z1PanelGap = TaskDisp.ZDefPos;
            //                    //    double Z2PanelGap = Z2 + Model[2].PanelGap;

            //                    //    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1PanelGap, Z2PanelGap)) return false;
            //                    //    #endregion
            //                    //}
            //                    break;
            //                }
            //            case ERunMode.Camera:
            //                {
            //                    break;
            //                }
            //        }
            //        #endregion

            //        if (RunMode == ERunMode.Normal && Disp)
            //        {
            //            if (Model[1].PumpSpeed != 0)
            //                if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop;
            //        }
            //    }
            //    catch (Exception Ex)
            //    {
            //        GDefine.Status = EStatus.ErrorInit;
            //        TaskGantry.ForceStopGXY();
            //        TaskDisp.TrigOff(b_Head1Run, b_Head2Run);
            //        EMsg = EMsg + (char)13 + Ex.Message.ToString();
            //        throw new Exception(EMsg);
            //    }
            //    GDefine.Status = EStatus.Ready;
            //    return true;
            //    _Stop:
            //    TaskGantry.DispATrigSet(TaskGantry.TOutputState.Off);
            //    TaskGantry.DispBTrigSet(TaskGantry.TOutputState.Off);
            //    GDefine.Status = EStatus.Stop;
            //    return false;
            //    _Error:
            //    TaskGantry.DispATrigSet(TaskGantry.TOutputState.Off);
            //    TaskGantry.DispBTrigSet(TaskGantry.TOutputState.Off);
            //    EMsg = EMsg + " Unknown Error";
            //    throw new Exception(EMsg);
            //}

            public bool DoDwell(TLine Line, EHeadNo HeadNo, bool SyncHead2, ERunMode RunMode, double Z1, bool First, bool Last)
            {
                string EMsg = "DO_DWELL";
                int t = 0;

                GDefine.Status = EStatus.Busy;

                Z1 = Z1 + OriginDrawOfst.Z;

                double CurX = 0;
                double CurY = 0;
                double LX1 = 0;
                double LY1 = 0;
                double LX2 = 0;
                double LY2 = 0;

                #region Select Head
                bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
                bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
                if (SyncHead2)
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
                }
                else
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
                }

                if (!b_Head1Run && !b_Head2Run) return true;
                #endregion
                TModelPara Model = new TModelPara(ModelList, Line.IPara[0]);

                #region Z Correction
                Z1 = Z1 + TaskDisp.Head_Ofst[0].Z;
                double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z) - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z);
                double Z2 = Z1 + ZDiff;
                #endregion

                #region Update Z Offset
                Z1 = Z1 + TaskDisp.Z1Offset;
                //Z2 = Z2 + TaskDisp.Z2Offset;
                Z2 = Z2 + TaskDisp.Z2Offset + TaskDisp.Head2_ZOffset;
                #endregion

                bool Disp = (Line.IPara[2] > 0);
                if (Disp)
                {
                    //double d_PumpSpeed = (short)ModelList.Model[Line.IPara[0]].Para[(int)TModelList.EModel.PumpSpeed];
                    if (Model.PumpSpeed != 0)
                        if (!TaskDisp.Thread_SetDispSpeed_Run(b_Head1Run, b_Head2Run, Model.PumpSpeed, Model.PumpSpeed)) goto _Stop;
                }
                else
                {
                    if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) return false;
                }

                try
                {
                    if (!First) goto _Cont;

                    switch (RunMode)
                    {
                        case ERunMode.Camera:
                        case ERunMode.Normal:
                            //if (d_DispVol > 0)
                            //{
                            //    TaskDisp.SetDispVolume(b_Head1Run, b_Head2Run, d_DispVol, d_DispVol);
                            //}
                            double VolToDispA_ul = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj;
                            double VolToDispB_ul = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj;
                            //double OfstA = 0;
                            //double OfstB = 0;

                            //if (rt_HeadVolumeMap != 0)
                            //{
                            //    GetVolumeMapOffset(ref OfstA, ref OfstB);

                            //    VolToDispA_ul = VolToDispA_ul + OfstA;
                            //    VolToDispB_ul = VolToDispB_ul + OfstB;
                            //}
                            if (Model.DispVol > 0)
                            {
                                VolToDispA_ul = Model.DispVol;
                                VolToDispB_ul = Model.DispVol;
                            }

                            if (Disp)
                            {
                                switch (Pump_Type)
                                {
                                    case TaskDisp.EPumpType.PP:
                                    case TaskDisp.EPumpType.PP2D:
                                    case TaskDisp.EPumpType.PPD:
                                        //if (!TaskDisp.Thread_SetDispVolume_Run(b_Head1Run, b_Head2Run, VolToDispA_ul, VolToDispB_ul)) goto _Stop;
                                        if (VolToDispA_ul != progDispVol[0] || VolToDispB_ul != progDispVol[1])
                                        {
                                            if (!TaskDisp.SetDispVolume(b_Head1Run, b_Head2Run, VolToDispA_ul, VolToDispB_ul))
                                            {
                                                Msg MsgBox = new Msg();
                                                MsgBox.Show(ErrCode.DISPCTRL1_COMM_ERR, "SetDispVolume ");
                                                goto _Stop;
                                            }
                                            if (b_Head1Run) progDispVol[0] = VolToDispA_ul;
                                            if (b_Head2Run) progDispVol[1] = VolToDispB_ul;
                                        }
                                        break;
                                }
                            }
                            break;
                    }

                    #region Move Z to Disp Gap
                    #region If ZPlane Valid, Update Z Values
                    CurX = TaskGantry.GXPos();
                    CurY = TaskGantry.GYPos();
                    LX1 = CurX - TaskDisp.Head_Ofst[0].X;
                    LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                    {
                        double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
                        double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
                        LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
                        LY2 = LY1 + OfstY;
                    }
                    UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
                    #endregion

                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                #region
                                if (!TaskGantry.SetMotionParamGZZ2(Model.DnStartV, Model.DnSpeed, Model.DnAccel)) return false;
                                //if (GDefine.GantryConfig != GDefine.EGantryConfig.XY_ZX2Y2_Z2 && SyncHead2)
                                //{
                                //    if (!TaskGantry.MoveAbsGZ(Z1 + Model.DispGap)) return false;
                                //}
                                //else
                                //{
                                //    if (b_Head1Run && b_Head2Run)
                                //    {
                                //        if (!TaskGantry.MoveAbsGZZ2(Z1 + Model.DispGap, Z2 + Model.DispGap)) return false;
                                //    }
                                //    else
                                //        if (b_Head1Run)
                                //        {
                                //            if (!TaskGantry.MoveAbsGZ(Z1 + Model.DispGap)) return false;
                                //        }
                                //        else
                                //            if (b_Head2Run)
                                //            {
                                //                if (!TaskGantry.MoveAbsGZ2(Z2 + Model.DispGap)) return false;
                                //            }
                                //}
                                if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1 + Model.DispGap, Z2 + Model.DispGap)) return false;
                                break;
                                #endregion
                            }
                        case ERunMode.Camera:
                        default:
                            {
                                break;
                            }
                    }
                    #endregion

                    #region Down Wait
                    t = GDefine.GetTickCount() + Model.DnWait;
                    while (GDefine.GetTickCount() < t) { }
                    { Thread.Sleep(1); }
                    #endregion

                    #region Start Trigger
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            {
                                if (Disp)
                                {
                                    if (!TaskDisp.Thread_SetDispVolume_Wait()) goto _Stop;

                                    if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                    if (!TaskDisp.TrigOn(b_Head1Run, b_Head2Run)) goto _Stop;
                                    //if (!TaskDisp.HPCWaitNotReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                    if (!TaskDisp.CtrlWaitResponse(b_Head1Run, b_Head2Run)) goto _Stop;
                                }
                                break;
                            }
                        case ERunMode.Dry:
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }

                    #endregion

                    #region Start Delay
                    //t = GDefine.GetTickCount() + t_StartDelay;
                    //while (GDefine.GetTickCount() < t) { Thread.Sleep(1); }
                    t = GDefine.GetTickCount() + (int)Model.StartDelay;
                    while (GDefine.GetTickCount() < t)
                    {
                        if (Model.StartDelay > 75) Thread.Sleep(1);
                    }
                    #endregion

                    _Cont:
                    #region Continuous Trigger
                    if (Disp && RunMode == ERunMode.Normal)
                    {
                        //try
                        //{
                        //    if (b_Head1Run) TaskGantry.DispATrig(TaskGantry.TOutputState.On);
                        //    if (b_Head2Run) TaskGantry.DispBTrig(TaskGantry.TOutputState.On);
                        //}
                        //catch { };
                        TaskDisp.TrigOn(b_Head1Run, b_Head2Run);
                    }
                    #endregion

                    #region calc LiftRate
                    int Time = Line.IPara[1];

                    double LiftRate = 0;
                    if (Last)
                    {
                        if (Time > 0)
                            LiftRate = Model.LiftDist / ((double)Time / 1000);
                    }
                    int t_Start = GDefine.GetTickCount();
                    #endregion

                    #region Dwell - wait complete
                    int t_Dwell = GDefine.GetTickCount() + Time;
                    if (!TaskGantry.SetMotionParamGZZ2()) return false;
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                while (GDefine.GetTickCount() <= t_Dwell)
                                {
                                    //#region Update Z1 Z2 plane
                                    //CurX = TaskGantry.GXPos();
                                    //CurY = TaskGantry.GYPos();

                                    //if (rt_Head1HeightData.C != 0)
                                    //{
                                    //    LX1 = CurX - TaskDisp.Head_Ofst[0].X;
                                    //    LY1 = CurY - TaskDisp.Head_Ofst[0].Y;

                                    //    Z1 = TaskDisp.Head_ZSensor_RefPosZ[0] + rt_Head1HeightData.A * LX1 + rt_Head1HeightData.B * LY1 + rt_Head1HeightData.C;
                                    //    Z2 = TaskDisp.Head_ZSensor_RefPosZ[1] + rt_Head1HeightData.A * LX1 + rt_Head1HeightData.B * LY1 + rt_Head1HeightData.C;
                                    //}
                                    //if (SyncHead2)
                                    //{
                                    //    if (rt_Head2HeightData.C != 0)
                                    //    {
                                    //        if (GDefine.GantryConfig == GDefine.EGantryConfigType.XY_ZX2Y2_Z2)
                                    //        {
                                    //            double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
                                    //            double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
                                    //            LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
                                    //            LY2 = LY1 + OfstY;
                                    //            Z2 = TaskDisp.Head_ZSensor_RefPosZ[1] + rt_Head2HeightData.A * LX2 + rt_Head2HeightData.B * LY2 + rt_Head2HeightData.C;
                                    //        }
                                    //    }
                                    //    Z2 = Z2 + TaskDisp.Head2_ZOffset;
                                    //}
                                    //#endregion

                                    #region Update Z1 Z2 plane
                                    CurX = TaskGantry.GXPos();
                                    CurY = TaskGantry.GYPos();
                                    LX1 = CurX - TaskDisp.Head_Ofst[0].X;
                                    LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
                                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                                    {
                                        double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
                                        double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
                                        LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
                                        LY2 = LY1 + OfstY;
                                    }
                                    UpdateZHeight(SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
                                    #endregion

                                    #region Move LiftRate
                                    double ZLift1 = Z1;
                                    double ZLift2 = Z2;
                                    if (LiftRate > 0)
                                    {
                                        double z = (double)(GDefine.GetTickCount() - t_Start) / 1000 * LiftRate;
                                        ZLift1 = ZLift1 + z;
                                        ZLift2 = ZLift2 + z;
                                    }

                                    //if (GDefine.GantryConfig != GDefine.EGantryConfig.XY_ZX2Y2_Z2 && SyncHead2)
                                    //{
                                    //    if (!TaskGantry.MoveAbsGZ(ZLift1 + d_DispGap, false)) return false;
                                    //    if (!TaskGantry.WaitGZ()) return false;
                                    //}
                                    //else
                                    //{
                                    //    if (b_Head1Run && b_Head2Run)
                                    //    {
                                    //        if (!TaskGantry.MoveAbsGZ(ZLift1 + d_DispGap, false)) return false;
                                    //        if (!TaskGantry.MoveAbsGZ2(ZLift2 + d_DispGap, false)) return false;
                                    //        if (!TaskGantry.WaitGZZ2()) return false;
                                    //    }
                                    //    else
                                    //        if (b_Head1Run)
                                    //        {
                                    //            if (!TaskGantry.MoveAbsGZ(ZLift1 + d_DispGap, false)) return false;
                                    //            if (!TaskGantry.WaitGZ()) return false;
                                    //        }
                                    //        else
                                    //            if (b_Head2Run)
                                    //            {
                                    //                if (!TaskGantry.MoveAbsGZ2(ZLift2 + d_DispGap, false)) return false;
                                    //                if (!TaskGantry.WaitGZ2()) return false;
                                    //            }
                                    //}
                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, ZLift1 + Model.DispGap, ZLift2 + Model.DispGap)) return false;
                                    #endregion
                                }
                                break;
                            }
                        case ERunMode.Camera:
                        default:
                            {
                                while (GDefine.GetTickCount() <= t)
                                {
                                    Thread.Sleep(0);
                                }
                                break;
                            }
                    }
                    #endregion

                    if (!Last) goto _End;

                    #region End Delay
                    t = GDefine.GetTickCount() + (int)Model.EndDelay;
                    while (GDefine.GetTickCount() < t)
                    {
                        //TaskDisp.CheckIsFilling(b_Head1Run, b_Head2Run);
                        //Thread.Sleep(0);
                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                    }
                    #endregion

                    #region Stop Trigger
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            {
                                #region Stop Trigger
                                if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) return false;
                                break;
                                #endregion
                            }
                        case ERunMode.Dry:
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }
                    #endregion

                    #region Post Wait
                    t = GDefine.GetTickCount() + Model.PostWait;
                    while (GDefine.GetTickCount() < t)
                    {
                        //TaskDisp.CheckIsFilling(b_Head1Run, b_Head2Run);
                        //Thread.Sleep(1);
                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                    }
                    #endregion

                    #region Move ZRetGap, ZUpGap and ZPanelGap
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                if (Model.RetGap != 0)
                                {
                                    #region Move Ret
                                    if (!TaskGantry.SetMotionParamGZZ2(Model.RetStartV, Model.RetSpeed, Model.RetAccel)) return false;

                                    double Z1RetGap = Z1 + Model.RetGap;
                                    if (Z1RetGap > TaskDisp.ZDefPos) Z1RetGap = TaskDisp.ZDefPos;
                                    double Z2RetGap = Z2 + Model.RetGap;
                                    if (Z2RetGap > TaskDisp.ZDefPos) Z2RetGap = TaskDisp.ZDefPos;

                                    //if (GDefine.GantryConfig != GDefine.EGantryConfig.XY_ZX2Y2_Z2 && SyncHead2)
                                    //{
                                    //    if (!TaskGantry.MoveAbsGZ(Z1RetGap)) return false;
                                    //}
                                    //else
                                    //{
                                    //    if (b_Head1Run && b_Head2Run)
                                    //    {
                                    //        if (!TaskGantry.MoveAbsGZZ2(Z1RetGap, Z2RetGap)) return false;
                                    //    }
                                    //    else
                                    //        if (b_Head1Run)
                                    //        {
                                    //            if (!TaskGantry.MoveAbsGZ(Z1RetGap)) return false;
                                    //        }
                                    //        else
                                    //            if (b_Head2Run)
                                    //            {
                                    //                if (!TaskGantry.MoveAbsGZ2(Z2RetGap)) return false;
                                    //            }
                                    //}
                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1RetGap, Z2RetGap)) return false;
                                    #endregion
                                    #region Ret Wait
                                    t = GDefine.GetTickCount() + Model.RetWait;
                                    while (GDefine.GetTickCount() < t)
                                    {
                                        //TaskDisp.CheckIsFilling(b_Head1Run, b_Head2Run);
                                        //Thread.Sleep(0);
                                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                    }
                                    #endregion
                                }
                                if (Model.UpGap != 0)
                                {
                                    #region Move Up
                                    if (!TaskGantry.SetMotionParamGZZ2(Model.UpStartV, Model.UpSpeed, Model.UpAccel)) return false;

                                    double Z1UpGap = Z1 + Model.UpGap;
                                    if (Z1UpGap > TaskDisp.ZDefPos) Z1UpGap = TaskDisp.ZDefPos;
                                    double Z2UpGap = Z2 + Model.UpGap;
                                    if (Z2UpGap > TaskDisp.ZDefPos) Z2UpGap = TaskDisp.ZDefPos;

                                    //if (GDefine.GantryConfig != GDefine.EGantryConfig.XY_ZX2Y2_Z2 && SyncHead2)
                                    //{
                                    //    if (!TaskGantry.MoveAbsGZ(Z1UpGap)) return false;
                                    //}
                                    //else
                                    //{
                                    //    if (b_Head1Run && b_Head2Run)
                                    //    {
                                    //        if (!TaskGantry.MoveAbsGZZ2(Z1UpGap, Z2UpGap)) return false;
                                    //    }
                                    //    else
                                    //        if (b_Head1Run)
                                    //        {
                                    //            if (!TaskGantry.MoveAbsGZ(Z1UpGap)) return false;
                                    //        }
                                    //        else
                                    //            if (b_Head2Run)
                                    //            {
                                    //                if (!TaskGantry.MoveAbsGZ2(Z2UpGap)) return false;
                                    //            }
                                    //}
                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1UpGap, Z2UpGap)) return false;
                                    #endregion
                                    #region Up Wait
                                    t = GDefine.GetTickCount() + Model.UpWait;
                                    while (GDefine.GetTickCount() < t)
                                    {
                                        //TaskDisp.CheckIsFilling(b_Head1Run, b_Head2Run);
                                        //Thread.Sleep(0);
                                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                    }
                                    #endregion
                                }
                                //REM LastInCluster
                                //if (LastInCluster && b_MovePanelGap && Model.PanelGap != 0)
                                //{
                                //    #region Move Panel Gap
                                //    if (!TaskGantry.SetMotionParamGZZ2()) goto _Stop;

                                //    double Z1PanelGap = Z1 + Model.PanelGap;
                                //    if (Z1PanelGap > TaskDisp.ZDefPos) Z1PanelGap = TaskDisp.ZDefPos;
                                //    double Z2PanelGap = Z2 + Model.PanelGap;
                                //    if (Z2PanelGap > TaskDisp.ZDefPos) Z2PanelGap = TaskDisp.ZDefPos;

                                //    //if (GDefine.GantryConfig != GDefine.EGantryConfig.XY_ZX2Y2_Z2 && SyncHead2)
                                //    //{
                                //    //    if (!TaskGantry.MoveAbsGZ(Z1PanelGap)) return false;
                                //    //}
                                //    //else
                                //    //{
                                //    //    if (b_Head1Run && b_Head2Run)
                                //    //    {
                                //    //        if (!TaskGantry.MoveAbsGZZ2(Z1PanelGap, Z2PanelGap)) return false;
                                //    //    }
                                //    //    else
                                //    //        if (b_Head1Run)
                                //    //        {
                                //    //            if (!TaskGantry.MoveAbsGZ(Z1PanelGap)) return false;
                                //    //        }
                                //    //        else
                                //    //            if (b_Head2Run)
                                //    //            {
                                //    //                if (!TaskGantry.MoveAbsGZ2(Z2PanelGap)) return false;
                                //    //            }
                                //    //}
                                //    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1PanelGap, Z2PanelGap)) return false;
                                //    #endregion
                                //}
                                break;
                            }
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }
                    #endregion

                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            {
                                if (!TaskDisp.IsFilling())
                                {
                                    if (Disp)
                                    {

                                        if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                    }
                                }
                                break;
                            }
                        case ERunMode.Dry:
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }
                    _End:
                    { }
                }
                catch (Exception Ex)
                {
                    GDefine.Status = EStatus.ErrorInit;
                    TaskGantry.ForceStopGXY();
                    TaskDisp.TrigOff(b_Head1Run, b_Head2Run);
                    EMsg = EMsg + (char)13 + Ex.Message.ToString();
                    throw new Exception(EMsg);
                }
                GDefine.Status = EStatus.Ready;
                return true;
                _Stop:
                GDefine.Status = EStatus.Stop;
                return false;
            }
            private void DoWait(EHeadNo HeadNo, bool SyncHead2, int Time)
            {
                #region Select Head
                bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
                bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
                if (SyncHead2)
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
                }
                else
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
                }

                if (!b_Head1Run && !b_Head2Run) goto _End;
                #endregion

                GDefine.Status = EStatus.Busy;
                int t = GDefine.GetTickCount() + Time;
                while (GDefine.GetTickCount() <= t)
                {
                    if (Time > 75) Thread.Sleep(1);
                }
                _End:
                GDefine.Status = EStatus.Ready;
            }

            public bool MoveTo(int UnitNo, bool temp = true)
            {
                //Use last RefData
                int RefID = 0;
                for (int L = 0; L < CmdList.Count; L++)
                {
                    if (CmdList.Line[L].Cmd == ECmd.USE_REF)
                    {
                        RefID = CmdList.Line[L].ID;
                    }
                }

                if (!TaskDisp.TaskMoveGZZ2Up()) return false;

                if (!temp) RunTime.UIndex = UnitNo;
                double X = Origin(rt_StationNo).X + rt_Start.X + rt_LayoutRelPos[UnitNo].X;
                double Y = Origin(rt_StationNo).Y + rt_Start.Y + rt_LayoutRelPos[UnitNo].Y;

                TranslatePos(X, Y, rt_RefDatas[RefID].Data[UnitNo], ref X, ref Y);

                if (!TaskGantry.SetMotionParamGXY()) return false;
                if (!TaskGantry.MoveAbsGXY(X, Y)) return false;

                return true;
            }

            Point2D Pt_Prev_Start = new Point2D(0, 0);
            Point2D Pt_Prev2_Start = new Point2D(0, 0);
            Point2D Pt_Prev_End = new Point2D(0, 0);
            Point2D Pt_Prev2_End = new Point2D(0, 0);
            //public bool DoCLine(TLine Line, int LineNo, EHeadNo HeadNo, ERunMode RunMode, double dx, double dy, double dz, double dx2, double dy2, bool First, bool Last)
            //{
            //    #region Select Head
            //    bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
            //    bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
            //    if (rt_SyncHead2)
            //    {
            //        b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
            //        b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
            //    }
            //    else
            //    {
            //        b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
            //        b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
            //    }
            //    if (!b_Head1Run && !b_Head2Run) return true;
            //    #endregion

            //    dx = dx + OriginDrawOfst.X;
            //    dy = dy + OriginDrawOfst.Y;
            //    dx2 = dx2 + OriginDrawOfst.X;
            //    dy2 = dy2 + OriginDrawOfst.Y;

            //    int ModelNo = Line.IPara[0];
            //    TModelPara Model = new TModelPara(ModelList, ModelNo);

            //    CControl2.TOutput[] Output_DTrig = new CControl2.TOutput[] { };
            //    CControl2.TOutput[] Output_DPortA = new CControl2.TOutput[] { };
            //    CControl2.TOutput[] Output_DPortB = new CControl2.TOutput[] { };

            //    CControl2.TAxis[] Axis = new CControl2.TAxis[] { TaskGantry.GXAxis, TaskGantry.GYAxis };

            //    if (First)
            //    {
            //        FPressCtrl.Thread.Set_PressUnit(new double[2] { Model.FPressA, Model.FPressB });
            //        PathNew();
            //        PathLineNo = LineNo;
            //        if (Model.DnWait > 0) //PathAddDelay(Line, Model.DnWait);
            //        CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.DnWait, 0, null, null);

            //    }

            //    if (b_Head1Run && b_Head2Run)
            //    {
            //        Output_DTrig = new CControl2.TOutput[] { TaskGantry._DispATrg, TaskGantry._DispBTrg };
            //    }
            //    else
            //        if (b_Head1Run)
            //    {
            //        Output_DTrig = new CControl2.TOutput[] { TaskGantry._DispATrg };
            //        switch (Pump_Type)
            //        {
            //            case TaskDisp.EPumpType.TP:
            //                Output_DTrig = new CControl2.TOutput[] { TaskGantry._SvFPress1 };
            //                break;
            //            case TaskDisp.EPumpType.TPRV:
            //                Output_DTrig = new CControl2.TOutput[] { TaskGantry._SvFPress1 };
            //                Output_DPortA = new CControl2.TOutput[] { TaskGantry._SvPortA1 };
            //                Output_DPortB = new CControl2.TOutput[] { TaskGantry._SvPortB1 };
            //                break;
            //        }
            //    }
            //    else
            //            if (b_Head2Run)
            //    {
            //        Output_DTrig = new CControl2.TOutput[] { TaskGantry._DispBTrg };
            //    }

            //    //PathAddDelay(Line, 0);
            //    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //    bool Disp = Line.IPara[2] > 0;
            //    bool b_DispPrev = CmdList.Line[LineNo - 1].IPara[2] > 0;

            //    TLine DLine = new TLine(Line);
            //    DLine.Cmd = ECmd.NONE;

            //    switch (Pump_Type)
            //    {
            //        case TaskDisp.EPumpType.TP:
            //            #region
            //            if (RunMode == ERunMode.Normal && Disp)
            //                TaskDisp.TP.AddOnPaths(Axis);
            //            else
            //                TaskDisp.TP.AddOffPaths(Axis);
            //            break;
            //        #endregion
            //        case TaskDisp.EPumpType.TPRV:
            //            #region
            //            CommonControl.P1245.PathAddDO(Axis, Output_DTrig, (RunMode == ERunMode.Normal && Disp));
            //            bool Trig = RunMode == ERunMode.Normal && Disp;
            //            if (Trig)
            //            {
            //                //PathAddDelay(Line, 0);
            //                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                CommonControl.P1245.PathAddDO(Axis, Output_DPortA, true);
            //                //PathAddDelay(Line, 0);
            //                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                CommonControl.P1245.PathAddDO(Axis, Output_DPortB, false);
            //            }
            //            else
            //            {
            //                //PathAddDelay(Line, 0);
            //                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                CommonControl.P1245.PathAddDO(Axis, Output_DPortA, false);
            //                //PathAddDelay(Line, 0);
            //                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                CommonControl.P1245.PathAddDO(Axis, Output_DPortB, true);
            //            }
            //            break;
            //        #endregion
            //        case TaskDisp.EPumpType.SP:
            //            #region
            //            if (RunMode == ERunMode.Normal && Disp)
            //                TaskDisp.SP.SP_AddOnPaths(Axis);
            //            else
            //                TaskDisp.SP.SP_AddOffPaths(Axis);
            //            break;
            //        #endregion
            //        default:
            //            CommonControl.P1245.PathAddDO(Axis, Output_DTrig, (RunMode == ERunMode.Normal && Disp));
            //            break;
            //    }

            //    if (First)
            //    {
            //        if (Model.StartDelay > 0)
            //            //PathAddDelay(Line, Model.StartDelay);
            //          CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.StartDelay, 0, null, null);
            //    }

            //    double Radius = Line.DPara[10];
            //    double PrevRadius = CmdList.Line[LineNo - 1].DPara[10];
            //    bool b_RadiusPauseDisp = CmdList.Line[LineNo - 1].IPara[12] > 0;

            //    if (Radius > 0 || PrevRadius > 0)//radius mode
            //    {
            //        Line L_Prev = new Line(Pt_Prev_Start, Pt_Prev_End);
            //        Line L_Curr = new Line(Pt_Prev_End, new Point2D(dx, dy));
            //        Line L2_Curr = new Line(Pt_Prev2_End, new Point2D(dx2, dy2));

            //        Point2D Pt_Arc_Start = new Point2D(0, 0);
            //        Point2D Pt_Arc_End = new Point2D(0, 0);
            //        Point2D Pt_Arc_Center = new Point2D(0, 0);
            //        Point2D Pt_Arc2_End = new Point2D(0, 0);
            //        bool CW = false;

            //        if (CmdList.Line[LineNo - 1].Cmd == ECmd.LINE)
            //        {
            //            Pt_Arc_Start = L_Prev.TrimEnd(PrevRadius);
            //            Pt_Arc_End = L_Curr.TrimStart(PrevRadius);

            //            Line L_Prev_Perpend = L_Prev.GetPerpendAt(Pt_Arc_Start);
            //            Line L_Curr_Perpend = L_Curr.GetPerpendAt(Pt_Arc_End);

            //            Pt_Arc_Center = L_Prev_Perpend.Intersect(L_Curr_Perpend);

            //            CW = L_Prev.PointLocation(Pt_Arc_Center) < 0;

            //            Pt_Arc2_End = L2_Curr.TrimStart(PrevRadius);

            //            if (b_RadiusPauseDisp)
            //            #region
            //            {
            //                switch (Pump_Type)
            //                {
            //                    case TaskDisp.EPumpType.TP:
            //                        #region
            //                        if (RunMode == ERunMode.Normal && b_DispPrev) TaskDisp.TP.AddOffPaths(Axis);
            //                        break;
            //                    #endregion
            //                    case TaskDisp.EPumpType.SP:
            //                        #region
            //                        if (RunMode == ERunMode.Normal && b_DispPrev) TaskDisp.SP.SP_AddPausePaths(Axis);
            //                        break;
            //                    #endregion
            //                    default:
            //                        //CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                        CommonControl.P1245.PathAddDO(Axis, Output_DTrig, false);
            //                        //CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                        break;
            //                }
            //            }
            //            #endregion

            //            PathAddArc2(CmdList.Line[LineNo - 1], HeadNo, rt_SyncHead2, RunMode, 10, Pt_Arc_End.X, Pt_Arc_End.Y, Pt_Arc_Center.X, Pt_Arc_Center.Y,
            //                CW, false, dz);

            //            if (b_RadiusPauseDisp)
            //            #region
            //            {
            //                switch (Pump_Type)
            //                {
            //                    case TaskDisp.EPumpType.TP:
            //                        #region
            //                        if (RunMode == ERunMode.Normal && b_DispPrev) TaskDisp.TP.AddOffPaths(Axis);
            //                        break;
            //                    #endregion
            //                    case TaskDisp.EPumpType.SP:
            //                        #region
            //                        if (RunMode == ERunMode.Normal && Disp) TaskDisp.SP.SP_AddResumePaths(Axis);
            //                        break;
            //                    #endregion
            //                    default:
            //                        //CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                        CommonControl.P1245.PathAddDO(Axis, Output_DTrig, RunMode == ERunMode.Normal && Disp);
            //                        break;
            //                }
            //            }
            //            #endregion
            //        }

            //        Point2D Pt_End = new Point2D(dx, dy);
            //        Point2D Pt_End2 = new Point2D(0, 0);

            //        if (CmdList.Line[LineNo + 1].Cmd == ECmd.LINE)
            //        {
            //            double NextRadius = Radius;
            //            Pt_End = L_Curr.TrimEnd(NextRadius);
            //            Pt_End2 = L2_Curr.TrimEnd(NextRadius);
            //        }

            //        PathAddLine(Line, HeadNo, rt_SyncHead2, RunMode, 10, Pt_End.X, Pt_End.Y, dz, Pt_End2.X, Pt_End2.Y);
            //    }
            //    else
            //    {
            //        int i_Blending = CmdList.Line[LineNo].IPara[11];
            //        if (i_Blending % 2 != 0) i_Blending++;

            //        PathAddLine(Line, HeadNo, rt_SyncHead2, RunMode, i_Blending, dx, dy, dz, dx2, dy2);
            //    }

            //    if (Last)
            //    {
            //        #region
            //        uint IndexNo = 0;
            //        uint CurPath = 0;
            //        uint Remain = 0;
            //        CommonControl.P1245.PathInfo(TaskGantry.GXAxis, ref IndexNo, ref CurPath, ref Remain);

            //        LastLineNo = (int)Remain - 1;
            //        LastLineLiftDist = Model.LiftDist;

            //        if (Model.EndDelay > 0) 
            //            //PathAddDelay(Line, Model.EndDelay);
            //        CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.EndDelay, 0, null, null);

            //        switch (Pump_Type)
            //        {
            //            case TaskDisp.EPumpType.TP:
            //                TaskDisp.TP.AddOffPaths(Axis);
            //                break;
            //            case TaskDisp.EPumpType.TPRV:
            //                #region
            //                CommonControl.P1245.PathAddDO(Axis, Output_DTrig, false);

            //                //PathAddDelay(Line, 0);
            //                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                CommonControl.P1245.PathAddDO(Axis, Output_DPortA, false);

            //                //PathAddDelay(Line, 0);
            //                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                CommonControl.P1245.PathAddDO(Axis, Output_DPortB, true);

            //                //PathAddDelay(Line, 20);
            //                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 20, 0, null, null);
            //                CommonControl.P1245.PathAddDO(Axis, Output_DPortB, false);
            //                break;
            //            #endregion
            //            case TaskDisp.EPumpType.SP:
            //                TaskDisp.SP.SP_AddOffPaths(Axis);
            //                break;
            //            default:
            //                CommonControl.P1245.PathAddDO(Axis, Output_DTrig, false);
            //                break;
            //        }

            //        if (Model.PostWait > 0) 
            //            //PathAddDelay(Line, Model.PostWait);
            //        CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.PostWait, 0, null, null);


            //        if (!FPressCtrl.Thread.Set_PressUnitWait()) return false;

            //        CommonControl.P1245.PathInfo(TaskGantry.GXAxis, ref IndexNo, ref CurPath, ref Remain);
            //        if (!PathExecute(HeadNo, RunMode)) return false;
            //        #endregion
            //    }

            //    Pt_Prev_Start.X = Pt_Prev_End.X;
            //    Pt_Prev_Start.Y = Pt_Prev_End.Y;
            //    Pt_Prev2_Start.X = Pt_Prev2_End.X;
            //    Pt_Prev2_Start.Y = Pt_Prev2_End.Y;
            //    Pt_Prev_End.X = dx;
            //    Pt_Prev_End.Y = dy;
            //    Pt_Prev2_End.X = dx2;
            //    Pt_Prev2_End.Y = dy2;

            //    return true;
            //}
            //public bool DoCArc(TLine Line, int LineNo, EHeadNo HeadNo, ERunMode RunMode, double dx2, double dy2, double dx3, double dy3, double dz, bool Circ, bool First, bool Last)
            //{
            //    #region Select Head
            //    bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
            //    bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
            //    if (rt_SyncHead2)
            //    {
            //        b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
            //        b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
            //    }
            //    else
            //    {
            //        b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
            //        b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
            //    }
            //    if (!b_Head1Run && !b_Head2Run) return true;
            //    #endregion

            //    dx2 = dx2 + OriginDrawOfst.X;
            //    dy2 = dy2 + OriginDrawOfst.Y;
            //    dx3 = dx3 + OriginDrawOfst.X;
            //    dy3 = dy3 + OriginDrawOfst.Y;

            //    int ModelNo = Line.IPara[0];
            //    TModelPara Model = new TModelPara(ModelList, ModelNo);

            //    CControl2.TOutput[] Output_DTrig = new CControl2.TOutput[] { };
            //    CControl2.TOutput[] Output_DPortA = new CControl2.TOutput[] { };
            //    CControl2.TOutput[] Output_DPortB = new CControl2.TOutput[] { };
            //    CControl2.TAxis[] Axis = new CControl2.TAxis[] { TaskGantry.GXAxis, TaskGantry.GYAxis };

            //    if (First)
            //    {
            //        FPressCtrl.Thread.Set_PressUnit(new double[2] { Model.FPressA, Model.FPressB });
            //        PathNew();
            //        PathLineNo = LineNo;
            //        //if (Model.DnWait > 0) PathAddDelay(Line, Model.DnWait);
            //        //PathAddDelay(Line, Model.DnWait);
            //        CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.DnWait, 0, null, null);
            //    }

            //    if (b_Head1Run && b_Head2Run)
            //    {
            //        Output_DTrig = new CControl2.TOutput[] { TaskGantry._DispATrg, TaskGantry._DispBTrg };
            //    }
            //    else
            //        if (b_Head1Run)
            //    {
            //        Output_DTrig = new CControl2.TOutput[] { TaskGantry._DispATrg };
            //        switch (Pump_Type)
            //        {
            //            case TaskDisp.EPumpType.TP:
            //                Output_DTrig = new CControl2.TOutput[] { TaskGantry._SvFPress1 };
            //                break;
            //            case TaskDisp.EPumpType.TPRV:
            //                Output_DTrig = new CControl2.TOutput[] { TaskGantry._SvFPress1 };
            //                Output_DPortA = new CControl2.TOutput[] { TaskGantry._SvPortA1 };
            //                Output_DPortB = new CControl2.TOutput[] { TaskGantry._SvPortB1 };
            //                break;
            //        }
            //    }
            //    else
            //            if (b_Head2Run)
            //    {
            //        Output_DTrig = new CControl2.TOutput[] { TaskGantry._DispBTrg };
            //    }

            //    //PathAddDelay(Line, 0);
            //    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //    bool Disp = Line.IPara[2] > 0;

            //    TLine DLine = new TLine(Line);
            //    DLine.Cmd = ECmd.NONE;

            //    switch (Pump_Type)
            //    {
            //        case TaskDisp.EPumpType.TP:
            //            #region
            //            if (RunMode == ERunMode.Normal && Disp)
            //                TaskDisp.TP.AddOnPaths(Axis);
            //            else
            //                TaskDisp.TP.AddOffPaths(Axis);
            //            break;
            //        #endregion
            //        case TaskDisp.EPumpType.TPRV:
            //            #region
            //            CommonControl.P1245.PathAddDO(Axis, Output_DTrig, (RunMode == ERunMode.Normal && Disp));
            //            bool Trig = RunMode == ERunMode.Normal && Disp;
            //            if (Trig)
            //            {
            //                //PathAddDelay(Line, 0);
            //                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                CommonControl.P1245.PathAddDO(Axis, Output_DPortA, true);
            //                //PathAddDelay(Line, 0);
            //                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                CommonControl.P1245.PathAddDO(Axis, Output_DPortB, false);
            //            }
            //            else
            //            {
            //                //PathAddDelay(Line, 0);
            //                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                CommonControl.P1245.PathAddDO(Axis, Output_DPortA, false);
            //                //PathAddDelay(Line, 0);
            //                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                CommonControl.P1245.PathAddDO(Axis, Output_DPortB, true);
            //            }
            //            break;
            //        #endregion
            //        case TaskDisp.EPumpType.SP:
            //            #region
            //            if (RunMode == ERunMode.Normal && Disp)
            //                TaskDisp.SP.SP_AddOnPaths(Axis);
            //            else
            //                TaskDisp.SP.SP_AddOffPaths(Axis);
            //            break;
            //        #endregion
            //        default:
            //            CommonControl.P1245.PathAddDO(Axis, Output_DTrig, (RunMode == ERunMode.Normal && Disp));
            //            break;
            //    }

            //    if (First)
            //    {
            //        if (Model.StartDelay > 0) //PathAddDelay(Line, Model.StartDelay);
            //        CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.StartDelay, 0, null, null);
            //    }

            //    PathAddArc(Line, HeadNo, rt_SyncHead2, RunMode, 10, dx3, dy3, dx2, dy2, Circ, dz);

            //    if (Last)
            //    {
            //        #region
            //        uint IndexNo = 0;
            //        uint CurPath = 0;
            //        uint Remain = 0;
            //        CommonControl.P1245.PathInfo(TaskGantry.GXAxis, ref IndexNo, ref CurPath, ref Remain);

            //        LastLineNo = (int)Remain - 1;
            //        LastLineLiftDist = Model.LiftDist;

            //        //if (Model.EndDelay > 0) PathAddDelay(Line, Model.EndDelay);
            //        //PathAddDelay(Line, Model.EndDelay);
            //        CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.EndDelay, 0, null, null);

            //        switch (Pump_Type)
            //        {
            //            case TaskDisp.EPumpType.TP:
            //                TaskDisp.TP.AddOffPaths(Axis);
            //                break;
            //            case TaskDisp.EPumpType.TPRV:
            //                #region
            //                CommonControl.P1245.PathAddDO(Axis, Output_DTrig, false);

            //                //PathAddDelay(Line, 0);
            //                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                CommonControl.P1245.PathAddDO(Axis, Output_DPortA, false);

            //                //PathAddDelay(Line, 0);
            //                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
            //                CommonControl.P1245.PathAddDO(Axis, Output_DPortB, true);

            //                //PathAddDelay(Line, 20);
            //                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 20, 0, null, null);
            //                CommonControl.P1245.PathAddDO(Axis, Output_DPortB, false);
            //                break;
            //            #endregion
            //            case TaskDisp.EPumpType.SP:
            //                TaskDisp.SP.SP_AddOffPaths(Axis);
            //                break;
            //            default:
            //                CommonControl.P1245.PathAddDO(Axis, Output_DTrig, false);
            //                break;
            //        }

            //        if (Model.PostWait > 0)// PathAddDelay(Line, Model.PostWait);
            //        CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.PostWait, 0, null, null);

            //        if (!FPressCtrl.Thread.Set_PressUnitWait()) return false;

            //        if (!PathExecute(HeadNo, RunMode)) return false;
            //        #endregion
            //    }

            //    return true;
            //}

            public bool DoCLine(TLine Line, int LineNo, EHeadNo HeadNo, ERunMode RunMode, double dx, double dy, double dz, double dx2, double dy2, bool First, bool Last)
            {
                #region Select Head
                bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
                bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
                if (rt_SyncHead2)
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
                }
                else
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
                }
                if (!b_Head1Run && !b_Head2Run) return true;
                #endregion

                dx = dx + OriginDrawOfst.X;
                dy = dy + OriginDrawOfst.Y;
                dx2 = dx2 + OriginDrawOfst.X;
                dy2 = dy2 + OriginDrawOfst.Y;

                int ModelNo = Line.IPara[0];
                TModelPara Model = new TModelPara(ModelList, ModelNo);

                CControl2.TOutput[] Output_DTrig = new CControl2.TOutput[] { };
                CControl2.TOutput[] Output_DPortA = new CControl2.TOutput[] { };
                CControl2.TOutput[] Output_DPortB = new CControl2.TOutput[] { };

                CControl2.TAxis[] Axis = new CControl2.TAxis[] { TaskGantry.GXAxis, TaskGantry.GYAxis };

                if (First)
                {
                    if (Model.FPressA != pressVal[0] || Model.FPressB != pressVal[1])
                    {
                        FPressCtrl.Thread.Set_PressUnit(new double[2] { Model.FPressA, Model.FPressB });
                        pressVal = new double[] { Model.FPressA, Model.FPressB };
                    }
                    PathNew();
                    PathLineNo = LineNo;
                    if (Model.DnWait > 0) PathAddDelay(Line, Model.DnWait);
                }

                if (b_Head1Run && b_Head2Run)
                {
                    Output_DTrig = new CControl2.TOutput[] { TaskGantry._DispATrg, TaskGantry._DispBTrg };
                }
                else
                    if (b_Head1Run)
                {
                    Output_DTrig = new CControl2.TOutput[] { TaskGantry._DispATrg };
                    switch (Pump_Type)
                    {
                        case TaskDisp.EPumpType.TP:
                            Output_DTrig = new CControl2.TOutput[] { TaskGantry._SvFPress1 };
                            break;
                        case TaskDisp.EPumpType.TPRV:
                            Output_DTrig = new CControl2.TOutput[] { TaskGantry._SvFPress1 };
                            Output_DPortA = new CControl2.TOutput[] { TaskGantry._SvPortA1 };
                            Output_DPortB = new CControl2.TOutput[] { TaskGantry._SvPortB1 };
                            break;
                    }
                }
                else
                        if (b_Head2Run)
                {
                    Output_DTrig = new CControl2.TOutput[] { TaskGantry._DispBTrg };
                }

                PathAddDelay(Line, 0);
                bool Disp = Line.IPara[2] > 0;
                bool b_DispPrev = CmdList.Line[LineNo - 1].IPara[2] > 0;

                TLine DLine = new TLine(Line);
                DLine.Cmd = ECmd.NONE;

                switch (Pump_Type)
                {
                    case TaskDisp.EPumpType.TP:
                        #region
                        if (RunMode == ERunMode.Normal && Disp)
                            TaskDisp.TP.AddOnPaths(Axis);
                        else
                            TaskDisp.TP.AddOffPaths(Axis);
                        break;
                    #endregion  
                    case TaskDisp.EPumpType.TPRV:
                        #region
                        CommonControl.P1245.PathAddDO(Axis, Output_DTrig, (RunMode == ERunMode.Normal && Disp));
                        bool Trig = RunMode == ERunMode.Normal && Disp;
                        if (Trig)
                        {
                            PathAddDelay(Line, 0);
                            CommonControl.P1245.PathAddDO(Axis, Output_DPortA, true);
                            PathAddDelay(Line, 0);
                            CommonControl.P1245.PathAddDO(Axis, Output_DPortB, false);
                        }
                        else
                        {
                            PathAddDelay(Line, 0);
                            CommonControl.P1245.PathAddDO(Axis, Output_DPortA, false);
                            PathAddDelay(Line, 0);
                            CommonControl.P1245.PathAddDO(Axis, Output_DPortB, true);
                        }
                        break;
                    #endregion
                    case TaskDisp.EPumpType.SP:
                        {
                            if (RunMode == ERunMode.Normal && Disp)
                            {
                                TaskDisp.SP.SP_AddOnPaths(Axis);
                            }
                            else
                            {
                                if (DispProg.SP.IntPulseOffDelay[0] == 0)
                                {//default execute, do not execute if != 0 to handle SMC valve diff.
                                    TaskDisp.SP.SP_AddOffPaths(Axis);
                                }
                            }
                        }
                        break;
                    default:
                        CommonControl.P1245.PathAddDO(Axis, Output_DTrig, (RunMode == ERunMode.Normal && Disp));
                        break;
                }

                if (First)
                {
                    if (Model.StartDelay > 0) PathAddDelay(Line, Model.StartDelay);
                }

                double Radius = Line.DPara[10];
                double PrevRadius = CmdList.Line[LineNo - 1].DPara[10];
                bool b_RadiusPauseDisp = CmdList.Line[LineNo - 1].IPara[12] > 0;

                if (Radius > 0 || PrevRadius > 0)//radius mode
                {
                    Line L_Prev = new Line(Pt_Prev_Start, Pt_Prev_End);
                    Line L_Curr = new Line(Pt_Prev_End, new Point2D(dx, dy));
                    Line L2_Curr = new Line(Pt_Prev2_End, new Point2D(dx2, dy2));

                    Point2D Pt_Arc_Start = new Point2D(0, 0);
                    Point2D Pt_Arc_End = new Point2D(0, 0);
                    Point2D Pt_Arc_Center = new Point2D(0, 0);
                    Point2D Pt_Arc2_End = new Point2D(0, 0);
                    bool CW = false;

                    if (CmdList.Line[LineNo - 1].Cmd == ECmd.LINE)
                    {
                        Pt_Arc_Start = L_Prev.TrimEnd(PrevRadius);
                        Pt_Arc_End = L_Curr.TrimStart(PrevRadius);

                        Line L_Prev_Perpend = L_Prev.GetPerpendAt(Pt_Arc_Start);
                        Line L_Curr_Perpend = L_Curr.GetPerpendAt(Pt_Arc_End);

                        Pt_Arc_Center = L_Prev_Perpend.Intersect(L_Curr_Perpend);

                        CW = L_Prev.PointLocation(Pt_Arc_Center) < 0;

                        Pt_Arc2_End = L2_Curr.TrimStart(PrevRadius);

                        if (b_RadiusPauseDisp)
                        #region
                        {
                            switch (Pump_Type)
                            {
                                case TaskDisp.EPumpType.TP:
                                    #region
                                    if (RunMode == ERunMode.Normal && b_DispPrev) TaskDisp.TP.AddOffPaths(Axis);
                                    break;
                                #endregion
                                case TaskDisp.EPumpType.SP:
                                    #region
                                    if (RunMode == ERunMode.Normal && b_DispPrev) TaskDisp.SP.SP_AddPausePaths(Axis);
                                    break;
                                #endregion
                                default:
                                    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
                                    CommonControl.P1245.PathAddDO(Axis, Output_DTrig, false);
                                    //CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
                                    break;
                            }
                        }
                        #endregion

                        PathAddArc2(CmdList.Line[LineNo - 1], HeadNo, rt_SyncHead2, RunMode, 10, Pt_Arc_End.X, Pt_Arc_End.Y, Pt_Arc_Center.X, Pt_Arc_Center.Y,
                            CW, false, dz);

                        if (b_RadiusPauseDisp)
                        #region
                        {
                            switch (Pump_Type)
                            {
                                case TaskDisp.EPumpType.TP:
                                    #region
                                    if (RunMode == ERunMode.Normal && b_DispPrev) TaskDisp.TP.AddOffPaths(Axis);
                                    break;
                                #endregion
                                case TaskDisp.EPumpType.SP:
                                    #region
                                    if (RunMode == ERunMode.Normal && Disp) TaskDisp.SP.SP_AddResumePaths(Axis);
                                    break;
                                #endregion
                                default:
                                    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, 0, 0, null, null);
                                    CommonControl.P1245.PathAddDO(Axis, Output_DTrig, RunMode == ERunMode.Normal && Disp);
                                    break;
                            }
                        }
                        #endregion
                    }

                    Point2D Pt_End = new Point2D(dx, dy);
                    Point2D Pt_End2 = new Point2D(0, 0);

                    if (CmdList.Line[LineNo + 1].Cmd == ECmd.LINE)
                    {
                        double NextRadius = Radius;
                        Pt_End = L_Curr.TrimEnd(NextRadius);
                        Pt_End2 = L2_Curr.TrimEnd(NextRadius);
                    }

                    PathAddLine(Line, HeadNo, rt_SyncHead2, RunMode, 10, Pt_End.X, Pt_End.Y, dz, Pt_End2.X, Pt_End2.Y);
                }
                else
                {
                    int i_Blending = CmdList.Line[LineNo].IPara[11];
                    if (i_Blending % 2 != 0) i_Blending++;

                    switch (Pump_Type)
                    {
                        case TaskDisp.EPumpType.SP:
                            #region
                            if (DispProg.SP.IntPulseOffDelay[0] != 0 && CmdList.Line[LineNo + 1].Cmd == ECmd.LINE && CmdList.Line[LineNo + 1].IPara[2] == 0)
                            {//special condition for SMC valve to cut P Press dynamically.
                                double dist = Model.LineSpeed * Math.Abs(DispProg.SP.IntPulseOffDelay[0]);//dist to move IntPulseOffDelay

                                Point2D Pt_End = new Point2D(dx, dy);
                                Point2D Pt_End2 = new Point2D(0, 0);

                                //Line L_Prev = new Line(Pt_Prev_Start, Pt_Prev_End);
                                Line L_Curr = new Line(Pt_Prev_End, new Point2D(dx, dy));
                                Line L2_Curr = new Line(Pt_Prev2_End, new Point2D(dx2, dy2));
                                if (CmdList.Line[LineNo + 1].Cmd == ECmd.LINE)
                                {
                                    double NextRadius = Radius;
                                    Pt_End = L_Curr.TrimEnd(dist);
                                    Pt_End2 = L2_Curr.TrimEnd(dist);
                                }

                                CControl2.TOutput[] FPress = new CControl2.TOutput[] { TaskGantry._SvFPress1 };
                                CControl2.TOutput[] Vac = new CControl2.TOutput[] { TaskGantry._SvFVac1 };
                                CControl2.TOutput[] PPress = new CControl2.TOutput[] { TaskGantry._SvPortC1 };

                                if (DispProg.SP.IntPulseOffDelay[0] < 0)
                                {
                                    PathAddLine(Line, HeadNo, rt_SyncHead2, RunMode, i_Blending, Pt_End.X, Pt_End.Y, dz, Pt_End2.X, Pt_End2.Y);
                                    CommonControl.P1245.PathAddDO(Axis, PPress, false);
                                    PathAddLine(Line, HeadNo, rt_SyncHead2, RunMode, i_Blending, dx, dy, dz, dx2, dy2);
                                    CommonControl.P1245.PathAddDO(Axis, FPress, false);
                                    CommonControl.P1245.PathAddDO(Axis, Vac, true);
                                }
                                else
                                {
                                    PathAddLine(Line, HeadNo, rt_SyncHead2, RunMode, i_Blending, Pt_End.X, Pt_End.Y, dz, Pt_End2.X, Pt_End2.Y);
                                    CommonControl.P1245.PathAddDO(Axis, FPress, false);
                                    CommonControl.P1245.PathAddDO(Axis, Vac, true);
                                    PathAddLine(Line, HeadNo, rt_SyncHead2, RunMode, i_Blending, dx, dy, dz, dx2, dy2);
                                    CommonControl.P1245.PathAddDO(Axis, PPress, false);
                                }
                            }
                            else
                            {//no compensation
                                PathAddLine(Line, HeadNo, rt_SyncHead2, RunMode, i_Blending, dx, dy, dz, dx2, dy2);
                            }
                            break;
                        #endregion
                        default:
                            PathAddLine(Line, HeadNo, rt_SyncHead2, RunMode, i_Blending, dx, dy, dz, dx2, dy2);
                            break;
                    }

                    if (Last)//5.2.97
                    {
                        Line L_Curr = new Line(Pt_Prev_End, new Point2D(dx, dy));
                        double extLen = TaskDisp.Option_ExtendLastCLine;
                        double len = Math.Sqrt(Math.Pow(Pt_Prev_End.X - dx, 2) + Math.Pow(Pt_Prev_End.Y - dy, 2));
                        if (len > 0)
                        {
                            Point2D relExtPos = new Point2D((dx - Pt_Prev_End.X) * extLen / len, (dy - Pt_Prev_End.Y) * extLen / len);
                            PathAddLine(Line, HeadNo, rt_SyncHead2, RunMode, i_Blending, dx + relExtPos.X, dy + relExtPos.Y, dz, 0, 0);
                        }
                    }
                }

                if (Last)
                {
                    #region
                    uint IndexNo = 0;
                    uint CurPath = 0;
                    uint Remain = 0;
                    CommonControl.P1245.PathInfo(TaskGantry.GXAxis, ref IndexNo, ref CurPath, ref Remain);

                    LastLineNo = (int)Remain - 1;
                    LastLineLiftDist = Model.LiftDist;

                    if (Model.EndDelay > 0) PathAddDelay(Line, Model.EndDelay);

                    switch (Pump_Type)
                    {
                        case TaskDisp.EPumpType.TP:
                            TaskDisp.TP.AddOffPaths(Axis);
                            break;
                        case TaskDisp.EPumpType.TPRV:
                            #region
                            CommonControl.P1245.PathAddDO(Axis, Output_DTrig, false);

                            PathAddDelay(Line, 0);
                            CommonControl.P1245.PathAddDO(Axis, Output_DPortA, false);

                            PathAddDelay(Line, 0);
                            CommonControl.P1245.PathAddDO(Axis, Output_DPortB, true);

                            PathAddDelay(Line, 20);
                            CommonControl.P1245.PathAddDO(Axis, Output_DPortB, false);
                            break;
                        #endregion
                        case TaskDisp.EPumpType.SP:
                            TaskDisp.SP.SP_AddOffPaths(Axis);
                            break;
                        default:
                            CommonControl.P1245.PathAddDO(Axis, Output_DTrig, false);
                            break;
                    }

                    if (Model.PostWait > 0) PathAddDelay(Line, Model.PostWait);

                    if (!FPressCtrl.Thread.Set_PressUnitWait()) return false;

                    CommonControl.P1245.PathInfo(TaskGantry.GXAxis, ref IndexNo, ref CurPath, ref Remain);
                    if (!PathExecute(HeadNo, RunMode)) return false;
                    #endregion
                }

                Pt_Prev_Start.X = Pt_Prev_End.X;
                Pt_Prev_Start.Y = Pt_Prev_End.Y;
                Pt_Prev2_Start.X = Pt_Prev2_End.X;
                Pt_Prev2_Start.Y = Pt_Prev2_End.Y;
                Pt_Prev_End.X = dx;
                Pt_Prev_End.Y = dy;
                Pt_Prev2_End.X = dx2;
                Pt_Prev2_End.Y = dy2;

                return true;
            }
            public bool DoCArc(TLine Line, int LineNo, EHeadNo HeadNo, ERunMode RunMode, double dx2, double dy2, double dx3, double dy3, double dz, bool Circ, bool First, bool Last)
            {
                #region Select Head
                bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
                bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
                if (rt_SyncHead2)
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
                }
                else
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
                }
                if (!b_Head1Run && !b_Head2Run) return true;
                #endregion

                dx2 = dx2 + OriginDrawOfst.X;
                dy2 = dy2 + OriginDrawOfst.Y;
                dx3 = dx3 + OriginDrawOfst.X;
                dy3 = dy3 + OriginDrawOfst.Y;

                int ModelNo = Line.IPara[0];
                TModelPara Model = new TModelPara(ModelList, ModelNo);

                CControl2.TOutput[] Output_DTrig = new CControl2.TOutput[] { };
                CControl2.TOutput[] Output_DPortA = new CControl2.TOutput[] { };
                CControl2.TOutput[] Output_DPortB = new CControl2.TOutput[] { };
                CControl2.TAxis[] Axis = new CControl2.TAxis[] { TaskGantry.GXAxis, TaskGantry.GYAxis };

                if (First)
                {
                    if (Model.FPressA != pressVal[0] || Model.FPressB != pressVal[1])
                    {
                        FPressCtrl.Thread.Set_PressUnit(new double[2] { Model.FPressA, Model.FPressB });
                        pressVal = new double[] { Model.FPressA, Model.FPressB };
                    }
                    PathNew();
                    PathLineNo = LineNo;
                    PathAddDelay(Line, Model.DnWait);
                }

                if (b_Head1Run && b_Head2Run)
                {
                    Output_DTrig = new CControl2.TOutput[] { TaskGantry._DispATrg, TaskGantry._DispBTrg };
                }
                else
                    if (b_Head1Run)
                {
                    Output_DTrig = new CControl2.TOutput[] { TaskGantry._DispATrg };
                    switch (Pump_Type)
                    {
                        case TaskDisp.EPumpType.TP:
                            Output_DTrig = new CControl2.TOutput[] { TaskGantry._SvFPress1 };
                            break;
                        case TaskDisp.EPumpType.TPRV:
                            Output_DTrig = new CControl2.TOutput[] { TaskGantry._SvFPress1 };
                            Output_DPortA = new CControl2.TOutput[] { TaskGantry._SvPortA1 };
                            Output_DPortB = new CControl2.TOutput[] { TaskGantry._SvPortB1 };
                            break;
                    }
                }
                else
                        if (b_Head2Run)
                {
                    Output_DTrig = new CControl2.TOutput[] { TaskGantry._DispBTrg };
                }

                PathAddDelay(Line, 0);
                bool Disp = Line.IPara[2] > 0;

                TLine DLine = new TLine(Line);
                DLine.Cmd = ECmd.NONE;

                switch (Pump_Type)
                {
                    case TaskDisp.EPumpType.TP:
                        #region
                        if (RunMode == ERunMode.Normal && Disp)
                            TaskDisp.TP.AddOnPaths(Axis);
                        else
                            TaskDisp.TP.AddOffPaths(Axis);
                        break;
                    #endregion
                    case TaskDisp.EPumpType.TPRV:
                        #region
                        CommonControl.P1245.PathAddDO(Axis, Output_DTrig, (RunMode == ERunMode.Normal && Disp));
                        bool Trig = RunMode == ERunMode.Normal && Disp;
                        if (Trig)
                        {
                            PathAddDelay(Line, 0);
                            CommonControl.P1245.PathAddDO(Axis, Output_DPortA, true);
                            PathAddDelay(Line, 0);
                            CommonControl.P1245.PathAddDO(Axis, Output_DPortB, false);
                        }
                        else
                        {
                            PathAddDelay(Line, 0);
                            CommonControl.P1245.PathAddDO(Axis, Output_DPortA, false);
                            PathAddDelay(Line, 0);
                            CommonControl.P1245.PathAddDO(Axis, Output_DPortB, true);
                        }
                        break;
                    #endregion
                    case TaskDisp.EPumpType.SP:
                        #region
                        if (RunMode == ERunMode.Normal && Disp)
                            TaskDisp.SP.SP_AddOnPaths(Axis);
                        else
                            TaskDisp.SP.SP_AddOffPaths(Axis);
                        break;
                    #endregion
                    default:
                        CommonControl.P1245.PathAddDO(Axis, Output_DTrig, (RunMode == ERunMode.Normal && Disp));
                        break;
                }

                if (First)
                {
                    if (Model.StartDelay > 0) PathAddDelay(Line, Model.StartDelay);
                }

                PathAddArc(Line, HeadNo, rt_SyncHead2, RunMode, 10, dx3, dy3, dx2, dy2, Circ, dz);

                if (Last)
                {
                    #region
                    uint IndexNo = 0;
                    uint CurPath = 0;
                    uint Remain = 0;
                    CommonControl.P1245.PathInfo(TaskGantry.GXAxis, ref IndexNo, ref CurPath, ref Remain);

                    LastLineNo = (int)Remain - 1;
                    LastLineLiftDist = Model.LiftDist;

                    //if (Model.EndDelay > 0) PathAddDelay(Line, Model.EndDelay);
                    PathAddDelay(Line, Model.EndDelay);

                    switch (Pump_Type)
                    {
                        case TaskDisp.EPumpType.TP:
                            TaskDisp.TP.AddOffPaths(Axis);
                            break;
                        case TaskDisp.EPumpType.TPRV:
                            #region
                            CommonControl.P1245.PathAddDO(Axis, Output_DTrig, false);

                            PathAddDelay(Line, 0);
                            CommonControl.P1245.PathAddDO(Axis, Output_DPortA, false);

                            PathAddDelay(Line, 0);
                            CommonControl.P1245.PathAddDO(Axis, Output_DPortB, true);

                            PathAddDelay(Line, 20);
                            CommonControl.P1245.PathAddDO(Axis, Output_DPortB, false);
                            break;
                        #endregion
                        case TaskDisp.EPumpType.SP:
                            TaskDisp.SP.SP_AddOffPaths(Axis);
                            break;
                        default:
                            CommonControl.P1245.PathAddDO(Axis, Output_DTrig, false);
                            break;
                    }

                    if (Model.PostWait > 0) PathAddDelay(Line, Model.PostWait);

                    if (!FPressCtrl.Thread.Set_PressUnitWait()) return false;

                    if (!PathExecute(HeadNo, RunMode)) return false;
                    #endregion
                }

                return true;
            }

            public int PathLineNo = 0;
            public bool FirstPath = false;//first path
            public bool LineStart = false;//first line draw
            public int LastLineNo = 0;
            public double LastLineLiftDist = 0;
            public double PathZ1 = 0;
            double X_Last = 0;
            double Y_Last = 0;

            public bool PathNew()
            {
                try
                {
                    FirstPath = true;
                    LineStart = true;
                    CommonControl.P1245.PathFree(TaskGantry.GXAxis);
                }
                catch { throw; }
                return true;
            }
            public bool PathAddLine(TLine Line, EHeadNo HeadNo, bool SyncHead2, ERunMode RunMode, int BlendTime,
                double X_End, double Y_End, double Z1,
                double X2_End, double Y2_End)
            {
                try
                {
                    double X_Start = 0;
                    double Y_Start = 0;

                    if (FirstPath)
                    {
                        CommonControl.P1245.PathFree(TaskGantry.GXAxis);
                    }

                    TModelPara Model = new TModelPara(ModelList, Line.IPara[0]);

                    if (LineStart)//FirstPath)
                    {
                        X_Start = TaskGantry.GXPos();
                        Y_Start = TaskGantry.GYPos();
                    }
                    else
                    {
                        X_Start = X_Last;
                        Y_Start = Y_Last;
                    }


                    TPos2 GXY_S = new TPos2(X_Start, Y_Start);
                    TPos2 GXY = new TPos2(X_End, Y_End);
                    TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                if (!SyncHead2)
                                {
                                    if (HeadNo == EHeadNo.Head1)
                                    {
                                        GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                        GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;
                                    }
                                    if (HeadNo == EHeadNo.Head2)
                                    {
                                        GXY.X = GXY.X + TaskDisp.Head_Ofst[1].X;
                                        GXY.Y = GXY.Y + TaskDisp.Head_Ofst[1].Y;
                                    }
                                }
                                else
                                {
                                    GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                    GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;

                                    double X2_Ofst = X2_End - X_End;
                                    double Y2_Ofst = Y2_End - Y_End;

                                    GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + X2_Ofst;
                                    GX2Y2.Y = GX2Y2.Y + Y2_Ofst;
                                }
                                break;
                            }
                        case ERunMode.Camera:
                        default:
                            {
                                break;
                            }
                    }
                    X_Last = GXY.X;
                    Y_Last = GXY.Y;

                    CommonControl.P1245.PathBlendTime(TaskGantry.GXAxis, (uint)BlendTime);

                        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, CControl2.EMoveCmd.Abs2DLine, true,
                        Model.LineSpeed, Model.LineSpeed,
                        GXY.X, GXY.Y, 0, 0);

                    if (LineStart)//FirstPath) 
                        CommonControl.P1245.SetAccel(TaskGantry.GXAxis, TaskGantry.GYAxis, Model.LineAccel);

                    PathZ1 = Z1;

                    FirstPath = false;
                    LineStart = false;

                    if (DispProg.Options_EnableProcessLog)
                    {
                        string str = $"CLine\t";
                        //str += $"Head\t{Line.ID}\t";
                        //str += $"UnitNo\t{RunTime.UIndex}\t";
                        str += $"DispGap={Model.DispGap:f3}\t";
                        str += $"C,R={RunTime.Head_CR[0].X},{RunTime.Head_CR[0].Y}\t";
                        str += $"X,Y={GXY.X:f3},{GXY.Y:f3}\t";

                        GLog.WriteProcessLog(str);
                    }
                }
                catch { throw; }
                return true;
            }
            public bool PathAddArc(TLine Line, EHeadNo HeadNo, bool SyncHead2, ERunMode RunMode, int BlendTime,
                double X_End, double Y_End, double X_Thru, double Y_Thru, bool Circ, double Z1)
            {
                try
                {
                    double X_Start = 0;
                    double Y_Start = 0;

                    if (FirstPath)
                    {
                        CommonControl.P1245.PathFree(TaskGantry.GXAxis);
                    }

                    if (LineStart)//FirstPath)
                    {
                        X_Start = TaskGantry.GXPos();
                        Y_Start = TaskGantry.GYPos();
                    }
                    else
                    {
                        X_Start = X_Last;
                        Y_Start = Y_Last;
                    }

                    TPos2 GXY_S = new TPos2(X_Start, Y_Start);
                    TPos2 GXY_T = new TPos2(X_Thru, Y_Thru);
                    TPos2 GXY_E = new TPos2(X_End, Y_End);

                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            GXY_T.X = GXY_T.X + TaskDisp.Head_Ofst[0].X;
                            GXY_T.Y = GXY_T.Y + TaskDisp.Head_Ofst[0].Y;
                            GXY_E.X = GXY_E.X + TaskDisp.Head_Ofst[0].X;
                            GXY_E.Y = GXY_E.Y + TaskDisp.Head_Ofst[0].Y;
                            break;
                        case ERunMode.Camera:
                        default:
                            break;
                    }

                    double XCenter = 0;
                    double YCenter = 0;
                    TPos2 GXY_C = new TPos2(XCenter, YCenter);
                    double Rad = 0;
                    double StartA = 0;
                    double EndA = 0;
                    double Sweep = 0;
                    double Dir = 0;
                    GDefine.Arc3PGetInfo(GXY_S.X, GXY_S.Y, GXY_T.X, GXY_T.Y, GXY_E.X, GXY_E.Y, ref GXY_C.X, ref GXY_C.Y, ref Rad, ref StartA, ref EndA, ref Sweep, ref Dir);

                    if (Circ)
                    {
                        X_Last = GXY_S.X;
                        Y_Last = GXY_S.Y;
                    }
                    else
                    {
                        X_Last = GXY_E.X;
                        Y_Last = GXY_E.Y;
                    }

                    TModelPara Model = new TModelPara(ModelList, Line.IPara[0]);
                    CommonControl.P1245.PathBlendTime(TaskGantry.GXAxis, (uint)BlendTime);

                    CControl2.EMoveCmd MoveCmd = CControl2.EMoveCmd.Abs2DArcCCW;
                    if (Dir > 0) MoveCmd = CControl2.EMoveCmd.Abs2DArcCW;

                    if (Circ)
                        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, MoveCmd, true, Model.LineStartV, Model.LineSpeed, GXY_S.X, GXY_S.Y, GXY_C.X, GXY_C.Y);
                    else
                        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, MoveCmd, true, Model.LineStartV, Model.LineSpeed, GXY_E.X, GXY_E.Y, GXY_C.X, GXY_C.Y);

                    if (LineStart)//FirstPath) 
                        CommonControl.P1245.SetAccel(TaskGantry.GXAxis, TaskGantry.GYAxis, Model.LineAccel);

                    PathZ1 = Z1;

                    FirstPath = false;
                    LineStart = false;

                    if (DispProg.Options_EnableProcessLog)
                    {
                        string str = $"CLine\t";
                        //str += $"Head\t{Line.ID}\t";
                        //str += $"UnitNo\t{RunTime.UIndex}\t";
                        str += $"DispGap={Model.DispGap:f3}\t";
                        str += $"C,R={RunTime.Head_CR[0].X},{RunTime.Head_CR[0].Y}\t";
                        if (Circ)
                            str += $"X,Y={GXY_S.X:f3},{GXY_S.Y:f3}\t";
                        else
                            str += $"X,Y={GXY_E.X:f3},{GXY_E.Y:f3}\t";

                        GLog.WriteProcessLog(str);
                    }
                }
                catch { throw; }
                return true;
            }
            public bool PathAddArc2(TLine Line, EHeadNo HeadNo, bool SyncHead2, ERunMode RunMode, int BlendTime,
                double X_End, double Y_End, double X_Center, double Y_Center, bool CW, bool Circ, double Z1)//UseStartV)
            {
                try
                {
                    double X_Start = 0;
                    double Y_Start = 0;

                    if (FirstPath)
                    {
                        CommonControl.P1245.PathFree(TaskGantry.GXAxis);
                    }

                    if (LineStart)//FirstPath)
                    {
                        X_Start = TaskGantry.GXPos();
                        Y_Start = TaskGantry.GYPos();
                    }
                    else
                    {
                        X_Start = X_Last;
                        Y_Start = Y_Last;
                    }

                    TPos2 GXY_S = new TPos2(X_Start, Y_Start);
                    TPos2 GXY_C = new TPos2(X_Center, Y_Center);
                    TPos2 GXY_E = new TPos2(X_End, Y_End);

                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            GXY_C.X = GXY_C.X + TaskDisp.Head_Ofst[0].X;
                            GXY_C.Y = GXY_C.Y + TaskDisp.Head_Ofst[0].Y;
                            GXY_E.X = GXY_E.X + TaskDisp.Head_Ofst[0].X;
                            GXY_E.Y = GXY_E.Y + TaskDisp.Head_Ofst[0].Y;
                            break;
                        case ERunMode.Camera:
                        default:
                            break;
                    }

                    X_Last = GXY_E.X;
                    Y_Last = GXY_E.Y;

                    TModelPara Model = new TModelPara(ModelList, Line.IPara[0]);
                    CommonControl.P1245.PathBlendTime(TaskGantry.GXAxis, (uint)BlendTime);

                    CControl2.EMoveCmd MoveCmd = CControl2.EMoveCmd.Abs2DArcCCW;
                    if (CW) MoveCmd = CControl2.EMoveCmd.Abs2DArcCW;

                    if (Model.LineSpeed2 > 0)
                        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, MoveCmd, true, Model.LineSpeed2, Model.LineSpeed2, GXY_E.X, GXY_E.Y, GXY_C.X, GXY_C.Y);
                    else
                        CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, MoveCmd, true, /*Model.LineStartV*/Model.LineSpeed, Model.LineSpeed, GXY_E.X, GXY_E.Y, GXY_C.X, GXY_C.Y);

                    if (LineStart)//FirstPath) 
                        CommonControl.P1245.SetAccel(TaskGantry.GXAxis, TaskGantry.GYAxis, Model.LineAccel);

                    PathZ1 = Z1;

                    FirstPath = false;
                    LineStart = false;

                    if (DispProg.Options_EnableProcessLog)
                    {
                        string str = $"CLine\t";
                        //str += $"Head\t{Line.ID}\t";
                        //str += $"UnitNo\t{RunTime.UIndex}\t";
                        str += $"DispGap={Model.DispGap:f3}\t";
                        str += $"C,R={RunTime.Head_CR[0].X},{RunTime.Head_CR[0].Y}\t";
                        if (Circ)
                            str += $"X,Y={GXY_S.X:f3},{GXY_S.Y:f3}\t";
                        else
                            str += $"X,Y={GXY_E.X:f3},{GXY_E.Y:f3}\t";

                        GLog.WriteProcessLog(str);
                    }
                }
                catch { throw; }
                return true;
            }
            public bool PathAddDelay(TLine Line, double Delay)
            {
                try
                {
                    Line.Cmd = ECmd.NONE;
                    if (FirstPath)
                    {
                        CommonControl.P1245.PathFree(TaskGantry.GXAxis);
                    }

                    CControl2.EMoveCmd MoveCmd = CControl2.EMoveCmd.Delay;
                    CommonControl.P1245.PathAdd(TaskGantry.GXAxis, TaskGantry.GYAxis, MoveCmd, true, 0, Delay, 0, 0, 0, 0);

                    //if (FirstPath)
                    //{
                    FirstPath = false;
                    //}
                }
                catch { throw; }
                return true;
            }
            public bool PathExecute(EHeadNo HeadNo, ERunMode RunMode)
            {
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                    CommonControl.P1245.PathEnd(TaskGantry.GXAxis);

                string EMsg = "Path.Execute ";

                GDefine.Status = EStatus.Busy;

                int t = 0;
                double CurX = 0; double CurY = 0;
                double LX1 = 0; double LY1 = 0;
                double LX2 = 0; double LY2 = 0;

                #region Select Head
                bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
                bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
                if (rt_SyncHead2)
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
                }
                else
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
                }
                if (!b_Head1Run && !b_Head2Run) return true;
                #endregion

                #region Z Correction
                PathZ1 = PathZ1 + TaskDisp.Head_Ofst[0].Z;
                double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z) - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z);
                double Z2 = PathZ1 + ZDiff;
                #endregion

                #region Update Z Offset
                PathZ1 = PathZ1 + TaskDisp.Z1Offset;
                Z2 = Z2 + TaskDisp.Z2Offset + TaskDisp.Head2_ZOffset;
                #endregion

                try
                {
                    if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) return false;

                    TModelPara Model = new TModelPara(ModelList, CmdList.Line[PathLineNo].IPara[0]);
                    bool Disp = CmdList.Line[PathLineNo].IPara[2] > 0;

                    #region Set PumpSpeed and DispVolume
                    switch (RunMode)
                    {
                        case ERunMode.Camera:
                        case ERunMode.Normal:
                            double VolToDispA_ul = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj;
                            double VolToDispB_ul = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj;

                            if (rt_Head1VolumeOfst != 0)
                            {
                                VolToDispA_ul = VolToDispA_ul + rt_Head1VolumeOfst;
                            }
                            if (rt_Head2VolumeOfst != 0)
                            {
                                VolToDispB_ul = VolToDispB_ul + rt_Head2VolumeOfst;
                            }

                            if (Model.DispVol > 0)
                            {
                                VolToDispA_ul = Model.DispVol;
                                VolToDispB_ul = Model.DispVol;
                            }

                            if (Disp)
                            {
                                if (Model.PumpSpeed != 0)
                                    if (!TaskDisp.Thread_SetDispSpeed_Run(b_Head1Run, b_Head2Run, Model.PumpSpeed, Model.PumpSpeed)) goto _Stop;

                                switch (Pump_Type)
                                {
                                    case TaskDisp.EPumpType.PP:
                                    case TaskDisp.EPumpType.PP2D:
                                    case TaskDisp.EPumpType.PPD:
                                        if (VolToDispA_ul != progDispVol[0] || VolToDispB_ul != progDispVol[1])
                                        {
                                            if (!TaskDisp.SetDispVolume(b_Head1Run, b_Head2Run, VolToDispA_ul, VolToDispB_ul))
                                            {
                                                Msg MsgBox = new Msg();
                                                MsgBox.Show(ErrCode.DISPCTRL1_COMM_ERR, "SetDispVolume ");
                                                goto _Stop;
                                            }
                                            if (b_Head1Run) progDispVol[0] = VolToDispA_ul;
                                            if (b_Head2Run) progDispVol[1] = VolToDispB_ul;
                                        }
                                        if (Model.BSuckVol > 0)
                                        {
                                            if (!TaskDisp.Thread_SetBackSuckVolume_Run(b_Head1Run, b_Head2Run, Model.BSuckVol, Model.BSuckVol)) goto _Stop;
                                        }
                                        break;
                                }
                            }
                            break;
                    }
                    #endregion

                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            {
                                switch (Pump_Type)
                                {
                                    case TaskDisp.EPumpType.None:
                                    case TaskDisp.EPumpType.Single:
                                    case TaskDisp.EPumpType.TP:
                                    case TaskDisp.EPumpType.TPRV:
                                    case TaskDisp.EPumpType.SP:
                                        break;
                                    case TaskDisp.EPumpType.Vermes:
                                        for (int i = 0; i < 2; i++)
                                        {
                                            if (TaskDisp.Vermes3200[i].IsOpen)
                                            {
                                                if (TaskDisp.Vermes3200[i].Param.NP != 0)
                                                {
                                                    TaskDisp.Vermes3200[i].Param.NP = 0;
                                                    TaskDisp.Vermes3200[i].Set();
                                                }
                                            }
                                        }
                                        break;
                                    case TaskDisp.EPumpType.Vermes1560:
                                        for (int i = 0; i < 2; i++)
                                        {
                                            if (TaskDisp.Vermes1560[i].IsOpen)
                                            {
                                                if (TaskDisp.Vermes1560[i].NP[0] != 0)
                                                {
                                                    TaskDisp.Vermes1560[i].NP[0] = 0;
                                                    TaskDisp.Vermes1560[i].UpdateSetup();
                                                }
                                            }
                                        }
                                        break;
                                    default:
                                        if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                        break;
                                }
                                break;
                            }
                        case ERunMode.Dry:
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }


                    #region Move Z to Disp Gap
                    CurX = TaskGantry.GXPos();
                    CurY = TaskGantry.GYPos();
                    LX1 = CurX - TaskDisp.Head_Ofst[0].X;
                    LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                    {
                        double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
                        double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
                        LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
                        LY2 = LY1 + OfstY;
                    }
                    UpdateZHeight(rt_SyncHead2, LX1, LY1, LX2, LY2, ref PathZ1, ref Z2);
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                #region
                                if (!TaskGantry.SetMotionParamGZZ2(Model.DnStartV, Model.DnSpeed, Model.DnAccel)) return false;
                                if (!MoveZAbs(b_Head1Run, b_Head2Run, PathZ1 + Model.DispGap, Z2 + Model.DispGap)) return false;
                                break;
                                #endregion
                            }
                        case ERunMode.Camera:
                        default:
                            {
                                break;
                            }
                    }
                    #endregion

                    #region Wait PumpSpeed and DispVolume
                    switch (RunMode)
                    {
                        case ERunMode.Camera:
                        case ERunMode.Normal:
                            {
                                if (Disp)
                                {
                                    if (Model.PumpSpeed != 0)
                                        if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop;

                                    if (!TaskDisp.Thread_SetDispVolume_Wait()) goto _Stop;
                                    if (Model.BSuckVol > 0) { if (!TaskDisp.Thread_SetBackSuckVolume_Wait()) goto _Stop; }
                                }
                                break;
                            }
                        case ERunMode.Dry:
                            {
                                break;
                            }
                    }

                    #endregion

                    CommonControl.P1245.PathMove(TaskGantry.GXAxis);

                    bool Lifted = false;
                    while (true)//wait complete path
                    {
                        uint IndexNo = 0;
                        uint CurPath = 0;
                        uint Remain = 0;
                        CommonControl.P1245.PathInfo(TaskGantry.GXAxis, ref IndexNo, ref CurPath, ref Remain);

                        if (!Lifted && IndexNo >= LastLineNo)
                        {
                            Lifted = true;
                            switch (RunMode)
                            {
                                case ERunMode.Normal:
                                case ERunMode.Dry:
                                    {
                                        if (!MoveRelZ(b_Head1Run, b_Head2Run, LastLineLiftDist, LastLineLiftDist)) return false;
                                    }
                                    break;
                            }
                        }

                        if (!CommonControl.P1245.AxisBusy(TaskGantry.GXAxis, TaskGantry.GYAxis)) break;

                        TaskDisp.CtrlError.UpdateErrorFlag();
                    }

                    #region Stop Trigger
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            {
                                #region Stop Trigger
                                if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) return false;
                                if (b_Head1Run) Stats.DispCount_Inc(0);// HeadAShotCount++;
                                if (b_Head2Run) Stats.DispCount_Inc(1);// HeadBShotCount++;

                                break;
                                #endregion
                            }
                        case ERunMode.Dry:
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }
                    #endregion

                    #region Move ZRetGap, ZUpGap
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                if (Model.RetGap != 0)
                                {
                                    #region Move Ret
                                    if (!TaskGantry.SetMotionParamGZZ2(Model.RetStartV, Model.RetSpeed, Model.RetAccel)) return false;

                                    double Z1RetGap = PathZ1 + Model.RetGap;
                                    if (Z1RetGap > TaskDisp.ZDefPos) Z1RetGap = TaskDisp.ZDefPos;
                                    double Z2RetGap = Z2 + Model.RetGap;
                                    if (Z2RetGap > TaskDisp.ZDefPos) Z2RetGap = TaskDisp.ZDefPos;

                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1RetGap, Z2RetGap)) return false;
                                    #endregion
                                    #region Ret Wait
                                    t = GDefine.GetTickCount() + Model.RetWait;
                                    while (GDefine.GetTickCount() < t)
                                    {
                                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                    }
                                    #endregion
                                }
                                if (videoStop)
                                {
                                    videoStop = false;
                                    TProcessCamera.StopVideoLog();
                                }
                                if (Model.UpGap != 0)
                                {
                                    #region Move Up
                                    if (!TaskGantry.SetMotionParamGZZ2(Model.UpStartV, Model.UpSpeed, Model.UpAccel)) return false;

                                    double Z1UpGap = PathZ1 + Model.UpGap;
                                    if (Z1UpGap > TaskDisp.ZDefPos) Z1UpGap = TaskDisp.ZDefPos;
                                    double Z2UpGap = Z2 + Model.UpGap;
                                    if (Z2UpGap > TaskDisp.ZDefPos) Z2UpGap = TaskDisp.ZDefPos;

                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1UpGap, Z2UpGap)) return false;
                                    #endregion
                                    #region Up Wait
                                    t = GDefine.GetTickCount() + Model.UpWait;
                                    while (GDefine.GetTickCount() < t)
                                    {
                                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                    }
                                    #endregion
                                }
                                break;
                            }
                        case ERunMode.Camera:
                            {
                                break;
                            }
                    }
                    #endregion
                }
                catch (Exception Ex)
                {
                    GDefine.Status = EStatus.ErrorInit;
                    TaskGantry.ForceStopGXY();
                    TaskDisp.TrigOff(b_Head1Run, b_Head2Run);
                    EMsg = EMsg + (char)13 + Ex.Message.ToString();
                    throw new Exception(EMsg);
                }
                GDefine.Status = EStatus.Ready;
                return true;
                _Stop:
                TaskDisp.TrigOff(b_Head1Run, b_Head2Run);
                GDefine.Status = EStatus.Stop;
                return false;
            }
        }

        public static bool MoveZAbs(bool Head1, bool Head2, double Z1Pos, double Z2Pos)
        {
            if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
            {
                if (Head1 && Head2)
                {
                    if (!TaskGantry.MoveAbsGZZ2(Z1Pos, Z2Pos)) return false;
                }
                else
                    if (Head1)
                {
                    if (!TaskGantry.MoveAbsGZ(Z1Pos)) return false;
                }
                else
                        if (Head2)
                {
                    if (!TaskGantry.MoveAbsGZ2(Z2Pos)) return false;
                }
            }
            else
            {
                if (!TaskGantry.MoveAbsGZ(Z1Pos)) return false;
            }
            return true;
        }
        public static bool MoveRelZ(bool Head1, bool Head2, double Z1Pos, double Z2Pos)
        {
            if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
            {
                if (Head1 && Head2)
                {
                    if (!TaskGantry.MoveRelGZZ2(Z1Pos, Z2Pos)) return false;
                }
                else
                    if (Head1)
                {
                    if (!TaskGantry.MoveRelGZ(Z1Pos, true)) return false;
                }
                else
                        if (Head2)
                {
                    if (!TaskGantry.MoveRelGZ2(Z2Pos, true)) return false;
                }
            }
            else
            {
                if (!TaskGantry.MoveRelGZ(Z1Pos, true)) return false;
            }
            return true;
        }

        public static void TranslatePos(double x, double y, TRefData RefData, ref double newX, ref double newY)
        {
            Point2D OriPt = new Point2D(x, y);
            Point2D NewPt = OriPt.Translate(new Point2D(RefData.DatumX, RefData.DatumY), new Point2D(RefData.NewDatumX, RefData.NewDatumY));
            NewPt = NewPt.Rotate(new Point2D(RefData.NewDatumX, RefData.NewDatumY), RefData.Angle);
            newX = (double)NewPt.X;
            newY = (double)NewPt.Y;
        }
        public static void UpdateZHeight(bool SyncHead2, double LX1, double LY1, double LX2, double LY2, ref double Z1, ref double Z2)
        {
            if (rt_Head1HeightData.C != 0)
            {
                Z1 = TaskDisp.Head_ZSensor_RefPosZ[0] + rt_Head1HeightData.A * LX1 + rt_Head1HeightData.B * LY1 + rt_Head1HeightData.C;
                Z2 = TaskDisp.Head_ZSensor_RefPosZ[1] + rt_Head1HeightData.A * LX1 + rt_Head1HeightData.B * LY1 + rt_Head1HeightData.C;
                Z2 = Z2 + TaskDisp.Head2_ZOffset;
            }
            if (SyncHead2)
            {
                if (rt_Head2HeightData.C != 0)
                {
                    Z2 = TaskDisp.Head_ZSensor_RefPosZ[1] + rt_Head2HeightData.A * LX2 + rt_Head2HeightData.B * LY2 + rt_Head2HeightData.C;
                    Z2 = Z2 + TaskDisp.Head2_ZOffset;
                }
            }

            Z1 = Z1 + DispProg.BiasKernel.Z[DispProg.RunTime.Bias_Head_CR.X, DispProg.RunTime.Bias_Head_CR.Y];
        }

        public static double[] rt_MapX = new double[TLayout.MAX_UNITS];
        public static double[] rt_MapY = new double[TLayout.MAX_UNITS];
        public static double[] rt_MapS = new double[TLayout.MAX_UNITS];
        public static void CreateMatchMap(TLine Line, Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> Image, List<VisUtils.EMatchResult> MatchResults)
        {
            string EMsg = "MatchMap";

            try
            {
                VisUtils.Match(Image, TaskVision.CreateMapTemplate, (float)Line.DPara[0], -1, MatchResults);
            }
            catch (Exception Ex)
            {
                EMsg = EMsg + (char)13 + Ex.Message.ToString();
            }
        }
        public static bool GenerateMap(TLine Line, TLayout Layout, List<VisUtils.EMatchResult> MatchResults, ref EMapBin[] MapBin)
        {
            if (Layout.ULayoutType == TLayout.EULayoutType.Random) return false;

            TPos2[] Pos = new TPos2[TLayout.MAX_UNITS];
            for (int i = 0; i < TLayout.MAX_UNITS; i++)
            {
                Pos[i] = new TPos2();
            }
            double ActualW = 0;
            double ActualH = 0;

            for (int i = 0; i < Layout.TUCount; i++)
            {
                double urx = 0;//unit relative x
                double ury = 0;//unit relative y
                int CColNo = 0;
                int CRowNo = 0;
                int UColNo = 0;
                int URowNo = 0;

                Layout.UnitNoGetRC(i, ref UColNo, ref URowNo, ref CColNo, ref CRowNo);

                urx = Layout.UColPX * UColNo + Layout.URowPX * URowNo;
                ury = Layout.UColPY * UColNo + Layout.URowPY * URowNo;


                double crx = 0;//clstr relative x
                double cry = 0;//clstr relative y
                switch (Layout.CColLayoutType)
                {
                    case TLayout.ECLayoutType.Matrix:
                    default:
                        crx = crx + Layout.CColPX * CColNo;// +Layout.CRowPX * CRowNo;
                        cry = cry + Layout.CColPY * CColNo;// +Layout.CRowPY * CRowNo;
                        break;
                    case TLayout.ECLayoutType.MultiP:
                        crx = crx + Layout.CColX[CColNo];
                        cry = cry + Layout.CColY[CColNo];
                        break;
                }
                switch (Layout.CRowLayoutType)
                {
                    case TLayout.ECLayoutType.Matrix:
                    default:
                        crx = crx + Layout.CRowPX * CRowNo;
                        cry = cry + Layout.CRowPY * CRowNo;
                        break;
                    case TLayout.ECLayoutType.MultiP:
                        crx = crx + Layout.CRowX[CRowNo];
                        cry = cry + Layout.CRowY[CRowNo];
                        break;
                }

                Pos[i].X = Math.Abs(urx + crx);
                Pos[i].Y = Math.Abs(ury + cry);
                ActualW = Math.Max(ActualW, Pos[i].X);
                ActualH = Math.Max(ActualH, Pos[i].Y);
            }

            double XRatio = Line.X[2] / ActualW;
            if (Layout.MapOrigin == TLayout.EMapOrigin.Right) XRatio = -XRatio;
            double YRatio = Line.Y[2] / ActualH;


            for (int i = 0; i < Layout.TUCount; i++)
            {
                Pos[i].X = (Line.X[0] + Line.X[1] / 2) + (Pos[i].X * XRatio);
                Pos[i].Y = (Line.Y[0] + Line.Y[1] / 2) + (Pos[i].Y * YRatio);
            }

            for (int i = 0; i < Layout.TUCount; i++)
            {
                int W = (int)Line.X[1];
                int H = (int)Line.Y[1];
                for (int m = 0; m < MatchResults.Count; m++)
                {
                    double X1 = Pos[i].X - Line.X[1] / 2;// (int)(Line.X[0] + (Line.X[1] * CUC) + (Line.X[2] * CUR) + (Line.X[3] * CCC) + (Line.X[4] * CCR));
                    double Y1 = Pos[i].Y - Line.Y[1] / 2;//(int)(Line.Y[0] + (Line.Y[1] * CUC) + (Line.Y[2] * CUR) + (Line.Y[3] * CCC) + (Line.Y[4] * CCR));
                    double X2 = X1 + W;//;Line.X[5]);
                    double Y2 = Y1 + H;//Line.Y[5]);

                    double UX = MatchResults[m].X + ((double)W / 2);
                    double UY = MatchResults[m].Y + ((double)H / 2);

                    DispProg.rt_MapX[i] = X1;
                    DispProg.rt_MapY[i] = Y1;
                    DispProg.rt_MapS[i] = 0;

                    if (UX > X1 && UX < X2 && UY > Y1 && UY < Y2)
                    {
                        DispProg.rt_MapX[i] = MatchResults[m].X;
                        DispProg.rt_MapY[i] = MatchResults[m].Y;
                        DispProg.rt_MapS[i] = MatchResults[m].S;

                        if (MapBin[i] == EMapBin.PreMapNG) break;//continue;
                        if (MapBin[i] == EMapBin.Bypass) break;//continue;
                        MapBin[i] = EMapBin.MapOK;
                        rt_GenMap_OKCount++;
                        break;
                    }
                }
                if (MapBin[i] != EMapBin.MapOK)
                {
                    MapBin[i] = EMapBin.MapNG;
                    rt_GenMap_NGCount++;
                }
            }
            return true;
        }

        public static double rt_RefWhitePixelPcnt = 0;
        public static double rt_MinWhitePixelPcnt = 0;
        public static double rt_MaxWhitePixelPcnt = 0;
        public static double rt_OKMinWhitePixelPcnt = 0;
        public static double rt_OKMaxWhitePixelPcnt = 0;
        public static double rt_NGMinWhitePixelPcnt = 0;
        public static double rt_NGMaxWhitePixelPcnt = 0;
        public static int rt_GenMap_OKCount = 0;
        public static int rt_GenMap_NGCount = 0;
        public static bool GenerateMap(TLine Line, TLayout Layout, Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> Image, ref EMapBin[] MapBin)
        {
            rt_RefWhitePixelPcnt = 0;
            rt_MinWhitePixelPcnt = 1;
            rt_MaxWhitePixelPcnt = 0;
            rt_OKMinWhitePixelPcnt = 1;
            rt_OKMaxWhitePixelPcnt = 0;
            rt_OKMinWhitePixelPcnt = 1;
            rt_OKMaxWhitePixelPcnt = 0;
            rt_NGMinWhitePixelPcnt = 1;
            rt_NGMaxWhitePixelPcnt = 0;
            rt_GenMap_OKCount = 0;
            rt_GenMap_NGCount = 0;

            if (Layout.ULayoutType == TLayout.EULayoutType.Random) return false;

            TPos2[] Pos = new TPos2[TLayout.MAX_UNITS];
            for (int i = 0; i < TLayout.MAX_UNITS; i++)
            {
                Pos[i] = new TPos2();
            }
            double ActualW = 0;
            double ActualH = 0;

            for (int i = 0; i < Layout.TUCount; i++)
            {
                double urx = 0;//unit relative x
                double ury = 0;//unit relative y
                int CColNo = 0;
                int CRowNo = 0;
                int UColNo = 0;
                int URowNo = 0;

                Layout.UnitNoGetRC(i, ref UColNo, ref URowNo, ref CColNo, ref CRowNo);

                urx = Layout.UColPX * UColNo + Layout.URowPX * URowNo;
                ury = Layout.UColPY * UColNo + Layout.URowPY * URowNo;


                double crx = 0;//clstr relative x
                double cry = 0;//clstr relative y
                switch (Layout.CColLayoutType)
                {
                    case TLayout.ECLayoutType.Matrix:
                    default:
                        crx = crx + Layout.CColPX * CColNo;// +Layout.CRowPX * CRowNo;
                        cry = cry + Layout.CColPY * CColNo;// +Layout.CRowPY * CRowNo;
                        break;
                    case TLayout.ECLayoutType.MultiP:
                        crx = crx + Layout.CColX[CColNo];
                        cry = cry + Layout.CColY[CColNo];
                        break;
                }
                switch (Layout.CRowLayoutType)
                {
                    case TLayout.ECLayoutType.Matrix:
                    default:
                        crx = crx + Layout.CRowPX * CRowNo;
                        cry = cry + Layout.CRowPY * CRowNo;
                        break;
                    case TLayout.ECLayoutType.MultiP:
                        crx = crx + Layout.CRowX[CRowNo];
                        cry = cry + Layout.CRowY[CRowNo];
                        break;
                }

                Pos[i].X = Math.Abs(urx + crx);
                Pos[i].Y = Math.Abs(ury + cry);
                ActualW = Math.Max(ActualW, Pos[i].X);
                ActualH = Math.Max(ActualH, Pos[i].Y);
            }

            double XRatio = Line.X[2] / ActualW;
            if (Layout.MapOrigin == TLayout.EMapOrigin.Right) XRatio = -XRatio;
            double YRatio = Line.Y[2] / ActualH;


            for (int i = 0; i < Layout.TUCount; i++)
            {
                Pos[i].X = (Line.X[0] + Line.X[1] / 2) + (Pos[i].X * XRatio);
                Pos[i].Y = (Line.Y[0] + Line.Y[1] / 2) + (Pos[i].Y * YRatio);
            }

            int Thld = Line.IPara[10];
            Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> ImgThld = Image.ThresholdBinary(new Emgu.CV.Structure.Gray(Thld), new Emgu.CV.Structure.Gray(255));

            for (int i = 0; i < Layout.TUCount; i++)
            {
                int W = (int)Line.X[1];
                int H = (int)Line.Y[1];

                int X1 = (int)Pos[i].X - (int)Line.X[1] / 2;
                int Y1 = (int)Pos[i].Y - (int)Line.Y[1] / 2;
                int X2 = (int)X1 + W;
                int Y2 = (int)Y1 + H;

                DispProg.rt_MapX[i] = X1;
                DispProg.rt_MapY[i] = Y1;
                DispProg.rt_MapS[i] = 0;

                ImgThld.ROI = new Rectangle(X1, Y1, W, H);
                //Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> RoiImage = ImgThld.Copy();
                //byte[, ,] data = RoiImage.Data;
                int[] Pixels;
                Pixels = ImgThld.CountNonzero();

                //uint TotalPix = 0;
                //uint WhitePix = 0;

                //uint sq = 0;
                //for (int r = 0; r < H - 1; r++)
                //    for (int c = 0; c < W - 1; c++)
                //    {
                //        byte b = data[r, c, 0];
                //        if (b == 255) WhitePix++;
                //        TotalPix++;
                //    }
                int WhitePix = Pixels[0];
                int TotalPix = W * H;

                double Score = Line.DPara[10];
                double WhitePixelPcnt = (double)WhitePix / TotalPix;
                if (i == 0)
                {
                    rt_RefWhitePixelPcnt = WhitePixelPcnt;
                    rt_OKMinWhitePixelPcnt = rt_RefWhitePixelPcnt;
                    rt_OKMaxWhitePixelPcnt = rt_RefWhitePixelPcnt;
                }

                //double d_UnitPixPcnt = (double)WhitePix / TotalPix;
                rt_MinWhitePixelPcnt = Math.Min(WhitePixelPcnt, rt_MinWhitePixelPcnt);
                rt_MaxWhitePixelPcnt = Math.Max(WhitePixelPcnt, rt_MaxWhitePixelPcnt);

                if (WhitePixelPcnt >= Score)
                {
                    rt_OKMinWhitePixelPcnt = Math.Min(WhitePixelPcnt, rt_OKMinWhitePixelPcnt);
                    rt_OKMaxWhitePixelPcnt = Math.Max(WhitePixelPcnt, rt_OKMaxWhitePixelPcnt);
                }
                else
                {
                    rt_NGMinWhitePixelPcnt = Math.Min(WhitePixelPcnt, rt_NGMinWhitePixelPcnt);
                    rt_NGMaxWhitePixelPcnt = Math.Max(WhitePixelPcnt, rt_NGMaxWhitePixelPcnt);
                }

                if (MapBin[i] == EMapBin.PreMapNG) continue;// break;//continue;
                if (MapBin[i] == EMapBin.Bypass) continue;//break;//continue;

                if ((double)WhitePix / TotalPix >= Score)
                {
                    MapBin[i] = EMapBin.MapOK;
                    rt_GenMap_OKCount++;
                }
                else
                {
                    MapBin[i] = EMapBin.MapNG;
                    rt_GenMap_NGCount++;
                }
            }

            return true;
        }

        public static void ClearRTDispData()//clear rt dispense data
        {
            for (int i = 0; i < MAX_IDS; i++)
            {
                rtLoopActive[i] = false;
            }
            ResetMaps();
            RunTime.UIndex = 0;
            RunTime.UIndex2 = 0;
            LastLine = -1;
            b_InLoop = false;

            rt_Head1MapBin = EMapBin.None;
            rt_Head2MapBin = EMapBin.None;
            for (int i = 0; i < MAX_IDS; i++)
            {
                rt_RefDatas[i] = new TRefDatas();
            }

            rt_Head1RefData.Clear();
            rt_Head2RefData.Clear();
            for (int i = 0; i < MAX_IDS; i++)
                for (int j = 0; j < TLayout.MAX_UNITS; j++)
                {
                    rt_HeightData[i, j] = new THeightData();
                }
            rt_Head1HeightData.Clear();
            rt_Head2HeightData.Clear();

            SaveHData();
            rt_MeasL_HData.Clear();

            rt_HDataArr.Save();
            rt_HDataArr.Clear();

            rt_MeniscusDatas.Clear();

            string lastID = rt_Read_IDs[0, 0];
            for (int i = 0; i < MAX_IDS; i++)
            {
                for (int j = 0; j < TLayout.MAX_UNITS; j++)
                    rt_Read_IDs[i, j] = "";
            }
            if (TaskDisp.Preference == TaskDisp.EPreference.Unisem && TaskDisp.SECSGEMProtocol == TaskDisp.ESECSGEMProtocol.SECSGEMConnect2 && (GDefine.sgc2.EnableDnloadStripMapE142 || GDefine.sgc2.EnableUploadStripMapE142))
            {
                if (TaskConv.Pre.rt_StType == TaskConv.EPreStType.Disp1) rt_Read_IDs[0, 0] = lastID;
            }

            for (int i = 0; i < TLayout.MAX_UNITS; i++)
                for (int j = 0; j < MAX_VIS_VI_RESULT_DATA; j++)
                {
                    rt_VisVIResult[i, j] = new List<double>();
                }

            Stats.Board.ResetUnitCount();
            Stats.Board.ResetProcUnitCount();
            Stats.Board.ResetDispCount();
        }

        internal class PP_VolComp
        {
            public static bool Do(TLine Line)
            {
                string EMsg = "DoPPVolComp";

                switch (Pump_Type)
                {
                    case TaskDisp.EPumpType.PP:
                    case TaskDisp.EPumpType.PP2D:
                    case TaskDisp.EPumpType.PPD:
                        break;
                    default:
                        throw new Exception("Pump Type Not Supported.");
                }

                double PA_Vol = Line.DPara[0];
                double PB_Vol = Line.DPara[1];

                if (Target_Weight > 0)
                {
                    double PA_Weight = Line.DPara[2];
                    double PB_Weight = Line.DPara[3];

                    if (TaskWeight.CurrentCal[0] <= 0 || TaskWeight.CurrentCal[1] <= 0)
                    {
                        throw new Exception("Weight Not Calibrated.");
                    }

                    try
                    {
                        PA_Vol = PA_Weight / TaskWeight.CurrentCal[0];
                        PB_Vol = PB_Weight / TaskWeight.CurrentCal[1];
                    }
                    catch (Exception ex)
                    {
                        throw;
                    }
                }

                bool b_Head1Run = (PA_Vol != 0);
                bool b_Head2Run = (PB_Vol != 0);

                try
                {
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            {
                                if (PA_Vol < 0)
                                {
                                    //TaskDisp.Thread_SetDispVolume_Run(b_Head1Run, false, 0, 0);
                                    //TaskDisp.Thread_SetDispVolume_Wait();
                                    //TaskDisp.Thread_SetBackSuckVolume_Run(b_Head1Run, false, Math.Abs(PA_Vol), Math.Abs(PB_Vol));
                                    //TaskDisp.Thread_SetBackSuckVolume_Wait();
                                    TaskDisp.SetDispVolume(b_Head1Run, false, 0, 0);
                                    TaskDisp.SetBackSuckVolume(b_Head1Run, false, Math.Abs(PA_Vol), Math.Abs(PB_Vol));
                                }
                                if (PA_Vol > 0)
                                {
                                    //TaskDisp.Thread_SetDispVolume_Run(b_Head1Run, false, Math.Abs(PA_Vol), Math.Abs(PB_Vol));
                                    //TaskDisp.Thread_SetDispVolume_Wait();
                                    //TaskDisp.Thread_SetBackSuckVolume_Run(b_Head1Run, false, 0, 0);
                                    //TaskDisp.Thread_SetBackSuckVolume_Wait();
                                    TaskDisp.SetDispVolume(b_Head1Run, false, Math.Abs(PA_Vol), Math.Abs(PB_Vol));
                                    TaskDisp.SetBackSuckVolume(b_Head1Run, false, 0, 0);
                                }
                                if (PB_Vol < 0)
                                {
                                    //TaskDisp.Thread_SetDispVolume_Run(false, b_Head2Run, 0, 0);
                                    //TaskDisp.Thread_SetDispVolume_Wait();
                                    //TaskDisp.Thread_SetBackSuckVolume_Run(false, b_Head2Run, Math.Abs(PA_Vol), Math.Abs(PB_Vol));
                                    //TaskDisp.Thread_SetBackSuckVolume_Wait();
                                    TaskDisp.SetDispVolume(false, b_Head2Run, 0, 0);
                                    TaskDisp.SetBackSuckVolume(false, b_Head2Run, Math.Abs(PA_Vol), Math.Abs(PB_Vol));
                                }
                                if (PB_Vol > 0)
                                {
                                    //TaskDisp.Thread_SetDispVolume_Run(false, b_Head2Run, Math.Abs(PA_Vol), Math.Abs(PB_Vol));
                                    //TaskDisp.Thread_SetDispVolume_Wait();
                                    //TaskDisp.Thread_SetBackSuckVolume_Run(false, b_Head1Run, 0, 0);
                                    //TaskDisp.Thread_SetBackSuckVolume_Wait();
                                    TaskDisp.SetDispVolume(false, b_Head2Run, Math.Abs(PA_Vol), Math.Abs(PB_Vol));
                                    TaskDisp.SetBackSuckVolume(false, b_Head1Run, 0, 0);
                                }

                                if (b_Head1Run || b_Head2Run)
                                {
                                    if (!TaskDisp.SetDispCtrlTimedMode(true, true)) goto _Stop;

                                    if (!TaskDisp.CtrlWaitReady(b_Head1Run, b_Head2Run)) goto _Stop;
                                    if (!TaskDisp.TrigOn(b_Head1Run, b_Head2Run)) goto _Stop;
                                    if (!TaskDisp.CtrlWaitResponse(b_Head1Run, b_Head2Run)) goto _Stop;
                                    if (!TaskDisp.TrigOff(b_Head1Run, b_Head2Run)) goto _Stop;

                                    //TaskDisp.UpdatePPDispVol(LogPump.EVolAdjType.Auto, true, true);
                                    double headA_Vol = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj + DispProg.rt_Head1VolumeOfst;
                                    double headB_Vol = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj + DispProg.rt_Head2VolumeOfst;
                                    TaskDisp.SetDispVolume(true, true, headA_Vol, headB_Vol);
                                    //TaskDisp.UpdatePPBSuckVol(LogPump.EVolAdjType.Auto, true, true);
                                    TaskDisp.SetBackSuckVolume(true, true, DispProg.PP_HeadA_BackSuckVol, DispProg.PP_HeadB_BackSuckVol);
                                }
                                break;
                            }
                    }
                }
                catch (Exception Ex)
                {
                    GDefine.Status = EStatus.ErrorInit;
                    TaskDisp.TrigOff(b_Head1Run, b_Head2Run);
                    EMsg = EMsg + (char)13 + Ex.Message.ToString();
                    throw new Exception(EMsg);
                }
                return true;
                _Stop:
                GDefine.Status = EStatus.Stop;
                return false;
            }
            public static bool Get(int Index, ref double HeadA, ref double HeadB)
            {
                if (rt_VolComp.Count == 0) return false;

                int LineNo = rt_VolComp[Index];
                if (Script[0].CmdList.Line[LineNo].Cmd != ECmd.PP_VOL_COMP) return false;

                HeadA = Script[0].CmdList.Line[LineNo].DPara[0];
                HeadB = Script[0].CmdList.Line[LineNo].DPara[1];

                return true;
            }
            public static bool Set(int Index, double HeadA, double HeadB)
            {
                if (rt_VolComp.Count == 0) return false;

                int LineNo = rt_VolComp[Index];
                if (Script[0].CmdList.Line[LineNo].Cmd != ECmd.PP_VOL_COMP) return false;

                Script[0].CmdList.Line[LineNo].DPara[0] = HeadA;
                Script[0].CmdList.Line[LineNo].DPara[1] = HeadB;

                return true;
            }
        }

        public static bool SelectHead(TLine Line, ref bool[] HeadRun, ref bool Head2Valid, ref bool SyncHead2)
        {
            EHeadNo HeadNo = (EHeadNo)Line.ID;

            #region Update Head2Valid Head, SyncHead2
            switch (TaskDisp.Head_Operation)
            {
                case TaskDisp.EHeadOperation.Single:
                    HeadNo = EHeadNo.Head1;
                    break;
                case TaskDisp.EHeadOperation.Sync:
                    {
                        int rt_UIndex2 = 0;
                        rt_Layouts[rt_LayoutID].UnitNoGetHead2UnitNo(RunTime.UIndex, ref rt_UIndex2, ref Head2Valid);

                        if (!Head2Valid) HeadNo = HeadNo & EHeadNo.Head1;
                        SyncHead2 = TaskDisp.Head_Operation == TaskDisp.EHeadOperation.Sync;
                    }
                    break;
            }
            #endregion

            #region Force Head Operation
            if (b_ForceHead1)
            {
                if (HeadNo == EHeadNo.Head2)
                {
                    Msg MsgBox = new Msg();
                    MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                    return false;
                }
                HeadNo = EHeadNo.Head1;
            }
            if (b_ForceHead2)
            {
                if (GDefine.HeadConfig != GDefine.EHeadConfig.Dual || DispProg.Head_Operation == TaskDisp.EHeadOperation.Single)
                {
                    Msg MsgBox = new Msg();
                    MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                    return false;
                }
                HeadNo = EHeadNo.Head2;
            }
            #endregion

            HeadRun[0] = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
            HeadRun[1] = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));

            #region Update Map
            if (SyncHead2)
            {
                HeadRun[0] = HeadRun[0] && (rt_Head1MapBin < EMapBin.BinNG);
                HeadRun[1] = HeadRun[1] && (rt_Head2MapBin < EMapBin.BinNG);
            }
            else
            {
                HeadRun[0] = HeadRun[0] && (rt_Head1MapBin < EMapBin.BinNG);
                HeadRun[1] = HeadRun[1] && (rt_Head1MapBin < EMapBin.BinNG);
            }

            if (!HeadRun[0] && !HeadRun[1]) return false;
            #endregion

            return true;
        }
        public static void Outputs(bool[] HeadRun, ref CControl2.TOutput[] Outputs)
        {
            if (HeadRun[0] && HeadRun[1])
            {
                Outputs = new CControl2.TOutput[] { TaskGantry._DispATrg, TaskGantry._DispBTrg };
            }
            else
                if (HeadRun[0])
            {
                Outputs = new CControl2.TOutput[] { TaskGantry._DispATrg };
            }
            else
                    if (HeadRun[1])
            {
                Outputs = new CControl2.TOutput[] { TaskGantry._DispBTrg };
            }
        }
        private static void Vac_Outputs(bool[] HeadRun, ref CControl2.TOutput[] Outputs)
        {
            if (HeadRun[0] && HeadRun[1])
            {
                Outputs = new CControl2.TOutput[] { TaskGantry._SvFVac1 };
            }
            else
                if (HeadRun[0])
            {
                Outputs = new CControl2.TOutput[] { TaskGantry._SvFVac1 };
            }
            else
                    if (HeadRun[1])
            {
                Outputs = new CControl2.TOutput[] { };
            }
        }

        public static bool Dot_P(TLine Line, ERunMode RunMode, double f_origin_x, double f_origin_y, double f_origin_z)
        {
            string EMsg = "Dot_P";
            int t = 0;

            GDefine.Status = EStatus.Busy;

            EDotMode DotMode = (EDotMode)Line.IPara[1];

            try
            {
                bool b_Head2IsValid = false;
                bool b_SyncHead2 = false;
                bool[] b_HeadRun = new bool[2] { false, false };
                if (!SelectHead(Line, ref b_HeadRun, ref b_Head2IsValid, ref b_SyncHead2)) goto _End;

                TModelPara Model = new TModelPara(ModelList, Line.IPara[0]);
                bool Disp = (Line.IPara[2] > 0);

                #region Set Pump Para
                switch (RunMode)
                {
                    case ERunMode.Normal:
                        #region
                        double VolToDispA_ul = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj;
                        double VolToDispB_ul = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj;

                        if (rt_Head1VolumeOfst != 0)
                        {
                            VolToDispA_ul = VolToDispA_ul + rt_Head1VolumeOfst;
                        }
                        if (rt_Head2VolumeOfst != 0)
                        {
                            VolToDispB_ul = VolToDispB_ul + rt_Head2VolumeOfst;
                        }
                        if (Model.DispVol > 0)
                        {
                            VolToDispA_ul = Model.DispVol;
                            VolToDispB_ul = Model.DispVol;
                        }

                        if (Disp)
                        {
                            switch (Pump_Type)
                            {
                                case TaskDisp.EPumpType.PP:
                                case TaskDisp.EPumpType.PP2D:
                                case TaskDisp.EPumpType.PPD:
                                    //if (!TaskDisp.Thread_SetDispVolume_Run(b_HeadRun[0], b_HeadRun[1], VolToDispA_ul, VolToDispB_ul)) goto _Stop;
                                    if (VolToDispA_ul != progDispVol[0] || VolToDispB_ul != progDispVol[1])
                                    {
                                        if (!TaskDisp.SetDispVolume(b_HeadRun[0], b_HeadRun[1], VolToDispA_ul, VolToDispB_ul))
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.DISPCTRL1_COMM_ERR, "SetDispVolume ");
                                            goto _Stop;
                                        }
                                        if (b_HeadRun[0]) progDispVol[0] = VolToDispA_ul;
                                        if (b_HeadRun[1]) progDispVol[1] = VolToDispB_ul;
                                    }
                                    if (Model.BSuckVol > 0)
                                    {
                                        if (!TaskDisp.Thread_SetBackSuckVolume_Run(b_HeadRun[0], b_HeadRun[1], Model.BSuckVol, Model.BSuckVol)) goto _Stop;
                                    }
                                    if (Model.PumpSpeed > 0)
                                    {
                                        if (!TaskDisp.Thread_SetDispSpeed_Run(b_HeadRun[0], b_HeadRun[1], Model.PumpSpeed, Model.PumpSpeed)) goto _Stop;
                                    }
                                    break;
                                case TaskDisp.EPumpType.Vermes:
                                    for (int i = 0; i < 2; i++)
                                    {
                                        if (TaskDisp.Vermes3200[i].IsOpen)
                                        {
                                            if (TaskDisp.Vermes3200[i].Param.NP != 1)
                                            {
                                                TaskDisp.Vermes3200[i].Param.NP = 1;
                                                TaskDisp.Vermes3200[i].Set();
                                            }
                                        }
                                    }
                                    break;
                                case TaskDisp.EPumpType.Vermes1560:
                                    for (int i = 0; i < 2; i++)
                                    {
                                        if (TaskDisp.Vermes1560[i].IsOpen)
                                        {
                                            if (TaskDisp.Vermes1560[i].NP[0] != 1)
                                            {
                                                TaskDisp.Vermes1560[i].NP[0] = 1;
                                                TaskDisp.Vermes1560[i].UpdateSetup();
                                            }
                                        }
                                    }
                                    break;
                            }
                            if (Model.FPressA != pressVal[0] || Model.FPressB != pressVal[1])
                            {
                                FPressCtrl.Thread.Set_PressUnit(new double[2] { Model.FPressA, Model.FPressB });
                                pressVal = new double[] { Model.FPressA, Model.FPressB };
                            }
                        }
                        #endregion
                        break;
                    case ERunMode.Camera:
                    case ERunMode.Dry:
                        break;
                }
                #endregion

                #region Move GZ2 Up if invalid
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2 && !b_Head2IsValid)
                {
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            if (!TaskDisp.TaskMoveGZ2Up()) return false;
                            break;
                    }
                }
                #endregion

                #region assign and translate position
                double dx = f_origin_x + rt_LayoutRelPos[RunTime.UIndex].X + Line.X[0];
                double dy = f_origin_y + rt_LayoutRelPos[RunTime.UIndex].Y + Line.Y[0];
                TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);

                double dx2 = f_origin_x + rt_LayoutRelPos[RunTime.UIndex2].X + Line.X[0];
                double dy2 = f_origin_y + rt_LayoutRelPos[RunTime.UIndex2].Y + Line.Y[0];
                TranslatePos(dx2, dy2, rt_Head2RefData, ref dx2, ref dy2);

                dx = dx + BiasKernel.X[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XZ_YTABLE)
                    dy = dy - BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                else
                    dy = dy + BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];

                double X1 = dx;
                double Y1 = dy;
                double X2 = dx2;
                double Y2 = dy2;
                #endregion

                double X2_Ofst = X2 - X1;
                double Y2_Ofst = Y2 - Y1;

                TPos2 GXY = new TPos2(X1, Y1);
                TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                #region Move To Pos
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                        {
                            if (!b_SyncHead2)
                            {
                                if (b_HeadRun[0])//(HeadNo == EHeadNo.Head1)
                                {
                                    GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                    GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;
                                }
                                if (b_HeadRun[1])//(HeadNo == EHeadNo.Head2)
                                {
                                    GXY.X = GXY.X + TaskDisp.Head_Ofst[1].X;
                                    GXY.Y = GXY.Y + TaskDisp.Head_Ofst[1].Y;
                                }
                            }
                            else
                            {
                                GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;

                                GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + X2_Ofst + TaskDisp.Head2_XOffset;
                                GX2Y2.Y = GX2Y2.Y + Y2_Ofst + TaskDisp.Head2_YOffset;
                            }
                            break;
                        }
                    case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }

                if (!TaskGantry.SetMotionParamGXY()) goto _Error;
                if (!TaskGantry.MoveAbsGXY(GXY.X, GXY.Y, false)) goto _Error;
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                {
                    if (b_HeadRun[1])
                    {
                        if (!TaskGantry.SetMotionParamGX2Y2()) goto _Error;
                        if (!TaskGantry.MoveAbsGX2Y2(GX2Y2.X, GX2Y2.Y, false)) goto _Error;
                    }
                }
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                    TaskGantry.WaitGX2Y2();
                TaskGantry.WaitGXY();
                #endregion

                double Z1 = 0;
                double Z2 = 0;
                #region Assign Z positions
                double dz = f_origin_z;
                dz = dz + TaskDisp.Head_Ofst[0].Z;
                double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z));
                double dz2 = dz + ZDiff;
                Z1 = dz;
                Z2 = dz2;
                #endregion
                #region Update Z Offset
                Z1 = Z1 + TaskDisp.Z1Offset;
                Z2 = Z2 + TaskDisp.Z2Offset + TaskDisp.Head2_ZOffset;
                #endregion

                #region If ZPlane Valid, Update Z Values
                double LX1 = GXY.X - TaskDisp.Head_Ofst[0].X;
                double LY1 = GXY.Y - TaskDisp.Head_Ofst[0].Y;
                double LX2 = LX1 + (X2 - X1);
                double LY2 = LY1 + (Y2 - Y1);
                UpdateZHeight(b_SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
                #endregion

                double Z1RetGapPos = Z1 + Model.DispGap + Model.RetGap;
                if (Z1RetGapPos > TaskDisp.ZDefPos) Z1RetGapPos = TaskDisp.ZDefPos;
                double Z2RetGapPos = Z2 + Model.DispGap + Model.RetGap;
                if (Z2RetGapPos > TaskDisp.ZDefPos) Z2RetGapPos = TaskDisp.ZDefPos;

                #region Move First Gap
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                        {
                            //move to First Gap
                            double d1 = Math.Round(TaskGantry.GZPos(), 4);
                            double d2 = Math.Round(TaskGantry.GZ2Pos(), 4);
                            double d1T = Math.Round(Z1RetGapPos, 4);
                            double d2T = Math.Round(Z2RetGapPos, 4);
                            if ((b_HeadRun[0] && ((d1 < d1T - 0.001) || (d1 > d1T + 0.001))) || (b_HeadRun[1] && ((d2 < d2T - 0.001) || (d2 > d2T + 0.001))))
                            {
                                if (!TaskGantry.SetMotionParamGZZ2(Model.DnStartV, Model.DnSpeed, Model.DnAccel)) return false;
                                if (!MoveZAbs(b_HeadRun[0], b_HeadRun[1], d1T, d2T)) return false;

                                #region First Gap Wait
                                t = GDefine.GetTickCount() + Model.FirstGapWait;
                                while (GDefine.GetTickCount() < t) { }
                                { Thread.Sleep(1); }
                                #endregion
                            }
                            break;
                        }
                    case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }
                #endregion

                if (DispProg.Options_EnableProcessLog)
                {
                    string str = $"DotP\t";
                    str += $"DispGap={Model.DispGap:f3}\t";
                    str += $"C,R={RunTime.Head_CR[0].X},{RunTime.Head_CR[0].Y}\t";
                    str += $"X,Y,Z={GXY.X:f3},{GXY.Y:f3},{Z1 + Model.DispGap:f3}\t";
                    if (Head_Operation == TaskDisp.EHeadOperation.Sync)
                    {
                        str += $"C2,R2={RunTime.Head_CR[1].X},{RunTime.Head_CR[1].Y}\t";
                        str += $"X2,Y2,Z2={GX2Y2.X:f3},{GX2Y2.Y:f3},{Z2 + Model.DispGap:f3}\t";
                        double zdiff = TaskDisp.Head_ZSensor_RefPosZ[1] - TaskDisp.Head_ZSensor_RefPosZ[0];
                        str += $"X2A,Y2A,Z2A={GXY.X + X2_Ofst:f3},{GXY.Y + Y2_Ofst:f3},{Z2 + zdiff + Model.DispGap:f3}\t";
                    }

                    GLog.WriteProcessLog(str);
                }

                double[] RelDummyPos = new double[4] { 0, 0, 0, 0 };
                CControl2.TAxis[] Axis = new CControl2.TAxis[] { TaskGantry.GXAxis, TaskGantry.GYAxis, TaskGantry.GZAxis, TaskGantry.GZ2Axis };
                CommonControl.P1245.PathFree(Axis);
                double AC = Model.DnAccel;
                if (Model.DnAccel == 0) AC = TaskGantry.GXAxis.Para.Accel;
                CommonControl.P1245.SetAccel(Axis, AC);

                #region Set Paths
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                        {
                            #region REL Operation

                            double[] RelDispDist = new double[4] { 0, 0, 0, 0 };
                            if (b_HeadRun[0]) RelDispDist[2] = -Model.RetGap;
                            if (b_HeadRun[1]) RelDispDist[3] = -Model.RetGap;
                            CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, Model.DnSpeed, Model.DnStartV, RelDispDist, RelDummyPos);
                            if (Model.DnWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.DnWait, 0, null, null);

                            switch (Pump_Type)
                            {
                                case TaskDisp.EPumpType.SP:
                                    if (RunMode == ERunMode.Normal && Disp) TaskDisp.SP.SP_AddOnPaths(Axis);
                                    //if (Model.StartDelay > 0)
                                    //    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.StartDelay, 0, null, null);
                                    if (Model.DispTime > 0)
                                        CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.DispTime, 0, null, null);
                                    else
                                        CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, DispProg.SP.DispTime[0], 0, null, null);
                                    if (RunMode == ERunMode.Normal && Disp) TaskDisp.SP.SP_AddOffPaths(Axis);

                                    if (Model.PostWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.PostWait, 0, null, null);
                                    if (b_HeadRun[0] && RunMode == ERunMode.Normal) Stats.DispCount_Inc(0);// HeadAShotCount++;
                                    if (b_HeadRun[1] && RunMode == ERunMode.Normal) Stats.DispCount_Inc(1);//HeadBShotCount++;
                                    break;
                                case TaskDisp.EPumpType.TP:
                                    if (Model.StartDelay > 0)
                                    {
                                        if (RunMode == ERunMode.Normal && Disp) TaskDisp.TP.AddOnPaths(Axis);
                                    }
                                    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.StartDelay, 0, null, null);

                                    //CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.EndDelay, 0, null, null);
                                    if (Model.EndDelay == 0)
                                    {
                                        CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.PostWait, 0, null, null);
                                        TaskDisp.TP.AddOffPaths(Axis);
                                    }
                                    if (b_HeadRun[0] && RunMode == ERunMode.Normal) Stats.DispCount_Inc(0);// HeadAShotCount++;
                                    if (b_HeadRun[1] && RunMode == ERunMode.Normal) Stats.DispCount_Inc(1);// HeadBShotCount++;
                                    break;
                                default:
                                    //if (DotMode == EDotMode.Cont)
                                    //{
                                    //#region DotMode Continuous
                                    switch (RunMode)
                                    {
                                        case ERunMode.Normal:
                                        case ERunMode.Dry:
                                            {
                                                CControl2.TOutput[] Output = new CControl2.TOutput[] { };
                                                Outputs(b_HeadRun, ref Output);

                                                CommonControl.P1245.PathAddDO(Axis, Output, RunMode == ERunMode.Normal);
                                                if (Model.StartDelay > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.StartDelay, 0, null, null);
                                                if (Model.EndDelay > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.EndDelay, 0, null, null);
                                                CommonControl.P1245.PathAddDO(Axis, Output, false);
                                                if (b_HeadRun[0] && RunMode == ERunMode.Normal) Stats.DispCount_Inc(0);// HeadAShotCount++;
                                                if (b_HeadRun[1] && RunMode == ERunMode.Normal) Stats.DispCount_Inc(1);// HeadBShotCount++;

                                                if (Model.PostWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.PostWait, 0, null, null);
                                                break;
                                            }
                                        case ERunMode.Camera:
                                            {
                                                break;
                                            }
                                    }
                                    //#endregion
                                    //}

                                    //if (DotMode == EDotMode.ExtTimed)
                                    //{
                                    //    #region DotMode ExtTimed
                                    //    switch (RunMode)
                                    //    {
                                    //        case ERunMode.Normal:
                                    //        case ERunMode.Dry:
                                    //            {
                                    //                CControl2.TOutput[] Output = new CControl2.TOutput[] { };
                                    //                Outputs(b_HeadRun, ref Output);

                                    //                CommonControl.P1245.PathAddDO(Axis, Output, RunMode == ERunMode.Normal);
                                    //                if (Model.StartDelay > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.StartDelay, 0, null, null);
                                    //                if (Model.EndDelay > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.EndDelay, 0, null, null);
                                    //                CommonControl.P1245.PathAddDO(Axis, Output, false);
                                    //                if (b_HeadRun[0] && RunMode == ERunMode.Normal) DispProg.Stats.HeadAShotCount++;
                                    //                if (b_HeadRun[1] && RunMode == ERunMode.Normal) DispProg.Stats.HeadBShotCount++;

                                    //                if (Model.PostWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.PostWait, 0, null, null);
                                    //                break;
                                    //            }
                                    //        case ERunMode.Camera:
                                    //            {
                                    //                break;
                                    //            }
                                    //    }
                                    //    #endregion
                                    //}
                                    break;
                            }
                            double[] RelRetDist = new double[4] { 0, 0, 0, 0 };
                            if (b_HeadRun[0]) RelRetDist[2] = Model.RetGap;
                            if (b_HeadRun[1]) RelRetDist[3] = Model.RetGap;
                            if (Model.RetGap > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, Model.RetSpeed, Model.RetStartV, RelRetDist, RelDummyPos);
                            #region TP Mode
                            if (Model.EndDelay > 0)
                            {
                                switch (Pump_Type)
                                {
                                    case TaskDisp.EPumpType.TP:
                                        CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.EndDelay, 0, null, null);
                                        TaskDisp.TP.AddOffPaths(Axis);
                                        break;
                                }
                            }
                            #endregion
                            if (Model.RetWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.RetWait, 0, null, null);


                            double[] RelUpGaps = new double[4] { 0, 0, 0, 0 };
                            if (b_HeadRun[0]) RelUpGaps[2] = Model.UpGap;
                            if (b_HeadRun[1]) RelUpGaps[3] = Model.UpGap;
                            if (Model.UpGap > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, Model.UpSpeed, Model.UpStartV, RelUpGaps, RelDummyPos);
                            if (Model.UpWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.UpWait, 0, null, null);
                            break;
                            #endregion
                        }
                    case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }
                #endregion

                #region Wait Pump Para
                switch (RunMode)
                {
                    case ERunMode.Normal:
                        #region
                        if (Disp)
                        {
                            switch (Pump_Type)
                            {
                                case TaskDisp.EPumpType.PP:
                                case TaskDisp.EPumpType.PP2D:
                                case TaskDisp.EPumpType.PPD:
                                    if (!TaskDisp.Thread_SetDispVolume_Wait()) goto _Stop;
                                    if (Model.BSuckVol > 0) { if (!TaskDisp.Thread_SetBackSuckVolume_Wait()) goto _Stop; }
                                    if (Model.PumpSpeed > 0) { if (!TaskDisp.Thread_SetDispSpeed_Wait()) goto _Stop; }
                                    break;
                                default: 
                                    break;
                                //case TaskDisp.EPumpType.Vermes:
                                //    break;
                            }
                            if (!FPressCtrl.Thread.Set_PressUnitWait()) goto _Stop;
                        }
                        #endregion
                        break;
                    case ERunMode.Camera:
                    case ERunMode.Dry:
                        break;
                }
                #endregion

                #region Move Paths
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                        {
                            CommonControl.P1245.PathEnd(Axis);
                            CommonControl.P1245.PathMove(Axis);

                            while (true)
                            {
                                if (!CommonControl.P1245.AxisBusy(Axis)) break;
                            }

                            break;
                        }
                    case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }
                #endregion
            }
            catch (Exception Ex)
            {
                GDefine.Status = EStatus.ErrorInit;
                TaskDisp.TrigOff(true, true);
                EMsg = EMsg + (char)13 + Ex.Message.ToString();
                throw new Exception(EMsg);
            }
            _End:
            GDefine.Status = EStatus.Ready;
            return true;
            _Stop:
            GDefine.Status = EStatus.Stop;
            return false;
            _Error:
            GDefine.Status = EStatus.ErrorInit;
            return false;
        }
        public static bool DoDotMulti(TLine Line, ERunMode RunMode, double f_origin_x, double f_origin_y, double f_origin_z)
        {
            string EMsg = "DoDotMulti";

            try
            {
                GDefine.Status = EStatus.Busy;

                #region Select Head
                EHeadNo HeadNo = (EHeadNo)Line.ID;
                bool b_Head2IsValid = false;
                bool b_SyncHead2 = false;
                switch (TaskDisp.Head_Operation)
                {
                    case TaskDisp.EHeadOperation.Single:
                        HeadNo = EHeadNo.Head1;
                        break;
                    case TaskDisp.EHeadOperation.Sync:
                        {
                            int rt_UIndex2 = 0;
                            rt_Layouts[rt_LayoutID].UnitNoGetHead2UnitNo(RunTime.UIndex, ref rt_UIndex2, ref b_Head2IsValid);

                            if (!b_Head2IsValid) HeadNo = HeadNo & EHeadNo.Head1;
                            b_SyncHead2 = TaskDisp.Head_Operation == TaskDisp.EHeadOperation.Sync;
                        }
                        break;
                }

                #region Force Head Operation
                if (b_ForceHead1)
                {
                    if (HeadNo == EHeadNo.Head2)
                    {
                        Msg MsgBox = new Msg();
                        MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                        goto _Error;
                    }
                    HeadNo = EHeadNo.Head1;
                }
                if (b_ForceHead2)
                {
                    if (GDefine.HeadConfig != GDefine.EHeadConfig.Dual || DispProg.Head_Operation == TaskDisp.EHeadOperation.Single)
                    {
                        Msg MsgBox = new Msg();
                        MsgBox.Show(ErrCode.PROGRAM_HEAD_ERROR);
                        goto _Error;
                    }
                    HeadNo = EHeadNo.Head2;
                }
                #endregion

                bool b_Head1Run = ((HeadNo == EHeadNo.Head1) || (HeadNo == EHeadNo.Head12));
                bool b_Head2Run = ((HeadNo == EHeadNo.Head2) || (HeadNo == EHeadNo.Head12));
                if (b_SyncHead2)
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head2MapBin < EMapBin.BinNG);
                }
                else
                {
                    b_Head1Run = b_Head1Run && (rt_Head1MapBin < EMapBin.BinNG);
                    b_Head2Run = b_Head2Run && (rt_Head1MapBin < EMapBin.BinNG);
                }

                if (!b_Head1Run && !b_Head2Run) goto _End;
                #endregion

                TModelPara Model = new TModelPara(ModelList, Line.IPara[0]);
                bool Disp = (Line.IPara[2] > 0);

                #region Set Volume
                switch (RunMode)
                {
                    case ERunMode.Normal:
                        #region
                        double VolToDispA_ul = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj;
                        double VolToDispB_ul = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj;

                        if (rt_Head1VolumeOfst != 0)
                        {
                            VolToDispA_ul = VolToDispA_ul + rt_Head1VolumeOfst;
                        }
                        if (rt_Head2VolumeOfst != 0)
                        {
                            VolToDispB_ul = VolToDispB_ul + rt_Head2VolumeOfst;
                        }
                        if (Model.DispVol > 0)
                        {
                            VolToDispA_ul = Model.DispVol;
                            VolToDispB_ul = Model.DispVol;
                        }

                        if (Disp)
                        {
                            switch (Pump_Type)
                            {
                                case TaskDisp.EPumpType.PP:
                                case TaskDisp.EPumpType.PP2D:
                                case TaskDisp.EPumpType.PPD:
                                    //if (!TaskDisp.Thread_SetDispVolume_Run(b_Head1Run, b_Head2Run, VolToDispA_ul, VolToDispB_ul)) goto _Stop;
                                    if (VolToDispA_ul != progDispVol[0] || VolToDispB_ul != progDispVol[1])
                                    {
                                        if (!TaskDisp.SetDispVolume(b_Head1Run, b_Head2Run, VolToDispA_ul, VolToDispB_ul))
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.DISPCTRL1_COMM_ERR, "SetDispVolume ");
                                            goto _Stop;
                                        }
                                        if (b_Head1Run) progDispVol[0] = VolToDispA_ul;
                                        if (b_Head2Run) progDispVol[1] = VolToDispB_ul;
                                    }
                                    break;
                                case TaskDisp.EPumpType.Vermes:
                                    for (int i = 0; i < 2; i++)
                                    {
                                        if (TaskDisp.Vermes3200[i].IsOpen)
                                        {
                                            if (TaskDisp.Vermes3200[i].Param.NP != 1)
                                            {
                                                TaskDisp.Vermes3200[i].Param.NP = 1;
                                                TaskDisp.Vermes3200[i].Set();
                                            }
                                        }
                                    }
                                    break;
                                case TaskDisp.EPumpType.Vermes1560:
                                    for (int i = 0; i < 2; i++)
                                    {
                                        if (TaskDisp.Vermes1560[i].IsOpen)
                                        {
                                            if (TaskDisp.Vermes1560[i].NP[0] != 1)
                                            {
                                                TaskDisp.Vermes1560[i].NP[0] = 1;
                                                TaskDisp.Vermes1560[i].UpdateSetup();
                                            }
                                        }
                                    }
                                    break;
                            }
                        }
                        #endregion
                        break;
                    case ERunMode.Camera:
                    case ERunMode.Dry:
                        break;
                }
                #endregion

                #region GZ2 Up if invalid
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2 && !b_Head2IsValid)
                {
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            if (!TaskDisp.TaskMoveGZ2Up()) return false;
                            break;
                    }
                }
                #endregion

                double Z1 = 0;
                double Z2 = 0;

                CControl2.TAxis[] Axis = new CControl2.TAxis[] { TaskGantry.GXAxis, TaskGantry.GYAxis };
                CommonControl.P1245.PathFree(Axis);

                bool b_Blend = false;
                int Points = Line.IPara[5];
                Point2D FirstDotPt1 = new Point2D(0, 0);
                Point2D FirstDotPt2 = new Point2D(0, 0);
                for (int i = 0; i < Points; i++)
                {
                    #region assign and translate position
                    double dx = f_origin_x + rt_LayoutRelPos[RunTime.UIndex].X + Line.X[i];
                    double dy = f_origin_y + rt_LayoutRelPos[RunTime.UIndex].Y + Line.Y[i];
                    TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);

                    double dx2 = f_origin_x + rt_LayoutRelPos[RunTime.UIndex2].X + Line.X[i];
                    double dy2 = f_origin_y + rt_LayoutRelPos[RunTime.UIndex2].Y + Line.Y[i];
                    TranslatePos(dx2, dy2, rt_Head2RefData, ref dx2, ref dy2);

                    dx = dx + BiasKernel.X[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XZ_YTABLE)
                        dy = dy - BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                    else
                        dy = dy + BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];

                    double X1 = dx;
                    double Y1 = dy;
                    double X2 = dx2;
                    double Y2 = dy2;
                    #endregion
                    X1 = X1 + OriginDrawOfst.X;
                    Y1 = Y1 + OriginDrawOfst.Y;
                    X2 = X2 + OriginDrawOfst.X;
                    Y2 = Y2 + OriginDrawOfst.Y;

                    #region Assign Z positions
                    double dz = f_origin_z;
                    dz = dz + TaskDisp.Head_Ofst[0].Z;
                    double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z));
                    double dz2 = dz + ZDiff;

                    Z1 = dz;
                    Z2 = dz2;
                    #endregion
                    #region Update Z Offset
                    Z1 = Z1 + TaskDisp.Z1Offset;
                    Z2 = Z2 + TaskDisp.Z2Offset + TaskDisp.Head2_ZOffset;
                    #endregion

                    double X2_Ofst = X2 - X1;
                    double Y2_Ofst = Y2 - Y1;

                    TPos2 GXY = new TPos2(X1, Y1);
                    TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                    #region Move To Pos
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                if (!b_SyncHead2)
                                {
                                    if (HeadNo == EHeadNo.Head1)
                                    {
                                        GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                        GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;
                                    }
                                    if (HeadNo == EHeadNo.Head2)
                                    {
                                        GXY.X = GXY.X + TaskDisp.Head_Ofst[1].X;
                                        GXY.Y = GXY.Y + TaskDisp.Head_Ofst[1].Y;
                                    }
                                }
                                else
                                {
                                    GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                    GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;

                                    GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + X2_Ofst + TaskDisp.Head2_XOffset;
                                    GX2Y2.Y = GX2Y2.Y + Y2_Ofst + TaskDisp.Head2_YOffset;
                                }
                                break;
                            }
                        case ERunMode.Camera:
                        default:
                            {
                                break;
                            }
                    }
                    #endregion

                    double[] EndPts_Abs = new double[2] { GXY.X, GXY.Y };// { X1 - FirstPt.X, Y1 - FirstPt.Y };

                    if (i == 0)
                    {
                        FirstDotPt1 = new Point2D(X1, Y1);
                        FirstDotPt2 = new Point2D(X2, Y2);
                        #region move position
                        if (!TaskGantry.SetMotionParamGXY()) goto _Error;
                        if (!TaskGantry.MoveAbsGXY(GXY.X, GXY.Y, false)) goto _Error;
                        if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                        {
                            if (b_Head2Run)
                            {
                                if (!TaskGantry.SetMotionParamGX2Y2()) goto _Error;
                                if (!TaskGantry.MoveAbsGX2Y2(GX2Y2.X, GX2Y2.Y, false)) goto _Error;
                            }
                        }
                        if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                            TaskGantry.WaitGX2Y2();
                        TaskGantry.WaitGXY();
                        #endregion

                        #region If ZPlane Valid, Update Z Values
                        double LX1 = GXY.X - TaskDisp.Head_Ofst[0].X;
                        double LY1 = GXY.Y - TaskDisp.Head_Ofst[0].Y;
                        double LX2 = LX1 + (X2 - X1);
                        double LY2 = LY1 + (Y2 - Y1);
                        UpdateZHeight(b_SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
                        #endregion

                        #region move z to DispGap
                        switch (RunMode)
                        {
                            case ERunMode.Normal:
                            case ERunMode.Dry:
                                {

                                    double sv = Model.DnStartV;
                                    double dv = Model.DnSpeed;
                                    double ac = Model.DnAccel;
                                    if (!TaskGantry.SetMotionParamGZZ2(sv, dv, ac)) goto _Stop;
                                    if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1 + Model.DispGap, Z2 + Model.DispGap)) return false;


                                    break;
                                }
                            case ERunMode.Camera:
                            default:
                                {
                                    break;
                                }
                        }
                        #endregion

                        CommonControl.P1245.SetAccel(Axis, Model.LineAccel);

                        if (DispProg.Options_EnableProcessLog)
                        {
                            string str = $"DotMulti\t";
                            //str += $"Head={Line.ID}\t";
                            //str += $"UnitNo={RunTime.UIndex}\t";
                            str += $"DispGap={Model.DispGap:f3}\t";
                            str += $"C,R={RunTime.Head_CR[0].X},{RunTime.Head_CR[0].Y}\t";
                            str += $"X,Y,Z={GXY.X:f3},{GXY.Y:f3},{Z1 + Model.DispGap:f3}\t";
                            if (Head_Operation == TaskDisp.EHeadOperation.Sync)
                            {
                                str += $"C2,R2={RunTime.Head_CR[1].X},{RunTime.Head_CR[1].Y}\t";
                                str += $"X2,Y2,Z2={GX2Y2.X:f3},{GX2Y2.Y:f3},{Z2 + Model.DispGap:f3}\t";
                                double zdiff = TaskDisp.Head_ZSensor_RefPosZ[1] - TaskDisp.Head_ZSensor_RefPosZ[0];
                                str += $"X2A,Y2A,Z2A={GXY.X + X2_Ofst:f3},{GXY.Y + Y2_Ofst:f3},{Z2 + zdiff + Model.DispGap:f3}\t";
                            }

                            GLog.WriteProcessLog(str);
                        }
                    }

                    #region Add Paths
                    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Abs2DLine, b_Blend, Model.LineSpeed, Model.LineStartV, EndPts_Abs, new double[2] { 0, 0 });
                    if (Model.DnWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, b_Blend, Model.DnWait, 0, null, null);

                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                            {
                                if (Disp)
                                {
                                    //Vermes Trig Pulse 0.5~80ms(short) 100~200ms(long)
                                    int Dots = (int)Line.U[i];
                                    if (Dots == 0)
                                    {
                                        if (Model.StartDelay > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, b_Blend, Model.StartDelay, 0, null, null);
                                    }
                                    else
                                    {
                                        for (int k = 0; k < Dots; k++)
                                        {
                                            CControl2.TOutput[] Output = new CControl2.TOutput[] { };
                                            if (b_Head1Run && b_Head2Run)
                                            {
                                                Output = new CControl2.TOutput[] { TaskGantry._DispATrg, TaskGantry._DispBTrg };
                                                Stats.DispCount_Inc(0);
                                                Stats.DispCount_Inc(1);
                                            }
                                            else
                                                if (b_Head1Run)
                                            {
                                                Output = new CControl2.TOutput[] { TaskGantry._DispATrg };
                                                Stats.DispCount_Inc(0);
                                            }
                                            else
                                                    if (b_Head2Run)
                                            {
                                                Output = new CControl2.TOutput[] { TaskGantry._DispBTrg };
                                                Stats.DispCount_Inc(1);
                                            }

                                            switch (Pump_Type)
                                            {
                                                default://TaskDisp.EPumpType.Vermes:
                                                    CommonControl.P1245.PathAddDO(Axis, Output, Line.U[i] > 0);
                                                    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, b_Blend, 0.1, 0, null, null);
                                                    CommonControl.P1245.PathAddDO(Axis, Output, false);
                                                    double StartDelay = Math.Max(Model.StartDelay - 0.1, 0);
                                                    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, b_Blend, StartDelay, 0, null, null);

                                                    if (k < Dots - 1) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, b_Blend, Model.EndDelay, 0, null, null);
                                                    break;
                                                case TaskDisp.EPumpType.PJ:
                                                    if (Model.StartDelay > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, b_Blend, Model.StartDelay, 0, null, null);
                                                    Output = new CControl2.TOutput[] { TaskGantry._SvPortC1 };
                                                    for (int p = 0; p < DispProg.PJ.Pulse[0]; p++)
                                                    {
                                                        CommonControl.P1245.PathAddDO(Axis, Output, Line.U[i] > 0);
                                                        CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, b_Blend, (double)PJ.OpenTime[0], 0, null, null);
                                                        CommonControl.P1245.PathAddDO(Axis, Output, false);
                                                        CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, b_Blend, (double)PJ.CloseDelay[0], 0, null, null);
                                                    }
                                                    break;
                                            }
                                        }
                                    }
                                }
                                break;
                            }
                        case ERunMode.Dry:
                        case ERunMode.Camera:
                            {
                                if (Model.StartDelay > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, b_Blend, Model.StartDelay, 0, null, null);
                                break;
                            }
                    }

                    if (Model.PostWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, b_Blend, Model.PostWait, 0, null, null);

                    if (i == Points - 1)
                    {
                        CommonControl.P1245.PathEnd(Axis);
                    }
                    #endregion
                }
                CommonControl.P1245.PathMove(Axis);

                while (true)
                {
                    #region If ZPlane Valid, Update Z Values
                    double CurX = TaskGantry.GXPos();
                    double CurY = TaskGantry.GYPos();
                    double LX1 = CurX - TaskDisp.Head_Ofst[0].X;
                    double LY1 = CurY - TaskDisp.Head_Ofst[0].Y;
                    double LX2 = 0;
                    double LY2 = 0;
                    if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                    {
                        double OfstX = TaskGantry.GX2Pos() - TaskDisp.Head2_DefPos.X;
                        double OfstY = TaskGantry.GY2Pos() - TaskDisp.Head2_DefPos.Y;
                        LX2 = LX1 + (OfstX + TaskDisp.Head2_DefDistX);
                        LY2 = LY1 + OfstY;
                    }
                    UpdateZHeight(b_SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
                    #endregion

                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            {
                                if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1 + Model.DispGap, Z2 + Model.DispGap)) return false;
                                break;
                            }
                    }

                    if (!CommonControl.P1245.AxisBusy(Axis)) break;
                }
                #region

                #region Move ZRetGap, ZUpGap and ZPanelGap
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                        {
                            if (Model.RetGap != 0)
                            {
                                #region Move Ret
                                if (!TaskGantry.SetMotionParamGZZ2(Model.RetStartV, Model.RetSpeed, Model.RetAccel)) return false;

                                double Z1RetGap = Z1 + Model.RetGap;
                                if (Z1RetGap > TaskDisp.ZDefPos) Z1RetGap = TaskDisp.ZDefPos;
                                double Z2RetGap = Z2 + Model.RetGap;
                                if (Z2RetGap > TaskDisp.ZDefPos) Z2RetGap = TaskDisp.ZDefPos;


                                if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1RetGap, Z2RetGap)) return false;
                                #endregion
                                #region Ret Wait
                                if (Model.RetWait > 0)
                                {
                                    int t = GDefine.GetTickCount() + Model.RetWait;
                                    while (GDefine.GetTickCount() < t)
                                    {
                                        TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                    }
                                }
                                #endregion
                            }
                            if (Model.UpGap != 0)
                            {
                                #region Move Up
                                if (!TaskGantry.SetMotionParamGZZ2(Model.UpStartV, Model.UpSpeed, Model.UpAccel)) return false;

                                double Z1UpGap = Z1 + Model.UpGap;
                                if (Z1UpGap > TaskDisp.ZDefPos) Z1UpGap = TaskDisp.ZDefPos;
                                double Z2UpGap = Z2 + Model.UpGap;
                                if (Z2UpGap > TaskDisp.ZDefPos) Z2UpGap = TaskDisp.ZDefPos;

                                if (!MoveZAbs(b_Head1Run, b_Head2Run, Z1UpGap, Z2UpGap)) return false;
                                #endregion
                                #region Up Wait
                                int t = GDefine.GetTickCount() + Model.UpWait;
                                while (GDefine.GetTickCount() < t)
                                {
                                    TaskDisp.Thread_CheckIsFilling_Run(b_Head1Run, b_Head2Run);
                                }
                                #endregion
                            }
                            break;
                        }
                    case ERunMode.Camera:
                        {
                            break;
                        }
                }
                #endregion
                #endregion
            }
            catch (Exception Ex)
            {
                GDefine.Status = EStatus.ErrorInit;
                TaskDisp.TrigOff(true, true);//b_Head1Run, b_Head2Run);
                EMsg = EMsg + (char)13 + Ex.Message.ToString();
                throw new Exception(EMsg);
            }
            _End:
            GDefine.Status = EStatus.Ready;
            return true;
            _Stop:
            GDefine.Status = EStatus.Stop;
            return false;
            _Error:
            GDefine.Status = EStatus.ErrorInit;
            return false;
        }
        public static bool DotLine_Multi(TLine Line, ERunMode RunMode, double f_origin_x, double f_origin_y, double f_origin_z)
        {
            string EMsg = "DotLine_Multi";
            int t = 0;

            GDefine.Status = EStatus.Busy;

            EDotMode DotMode = (EDotMode)Line.IPara[1];

            double VermesInterval = 25;//ms

            try
            {
                bool b_Head2IsValid = false;
                bool b_SyncHead2 = false;
                bool[] b_HeadRun = new bool[2] { false, false };
                if (!SelectHead(Line, ref b_HeadRun, ref b_Head2IsValid, ref b_SyncHead2)) goto _End;

                TModelPara Model = new TModelPara(ModelList, Line.IPara[0]);
                bool Disp = (Line.IPara[2] > 0);

                #region Set Pump Para
                switch (RunMode)
                {
                    case ERunMode.Normal:
                        #region
                        double VolToDispA_ul = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj;
                        double VolToDispB_ul = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj;

                        if (rt_Head1VolumeOfst != 0)
                        {
                            VolToDispA_ul = VolToDispA_ul + rt_Head1VolumeOfst;
                        }
                        if (rt_Head2VolumeOfst != 0)
                        {
                            VolToDispB_ul = VolToDispB_ul + rt_Head2VolumeOfst;
                        }
                        if (Model.DispVol > 0)
                        {
                            VolToDispA_ul = Model.DispVol;
                            VolToDispB_ul = Model.DispVol;
                        }

                        if (Disp)
                        {
                            switch (Pump_Type)
                            {
                                case TaskDisp.EPumpType.PP:
                                case TaskDisp.EPumpType.PP2D:
                                case TaskDisp.EPumpType.PPD:
                                    //if (!TaskDisp.Thread_SetDispVolume_Run(b_HeadRun[0], b_HeadRun[1], VolToDispA_ul, VolToDispB_ul)) goto _Stop;
                                    if (VolToDispA_ul != progDispVol[0] || VolToDispB_ul != progDispVol[1])
                                    {
                                        if (!TaskDisp.SetDispVolume(b_HeadRun[0], b_HeadRun[1], VolToDispA_ul, VolToDispB_ul))
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.DISPCTRL1_COMM_ERR, "SetDispVolume ");
                                            goto _Stop;
                                        }
                                        if (b_HeadRun[0]) progDispVol[0] = VolToDispA_ul;
                                        if (b_HeadRun[1]) progDispVol[1] = VolToDispB_ul;
                                    }
                                    break;
                                case TaskDisp.EPumpType.Vermes:
                                    for (int i = 0; i < 2; i++)
                                    {
                                        if (TaskDisp.Vermes3200[i].IsOpen)
                                        {
                                            if (TaskDisp.Vermes3200[i].Param.NP != 1)
                                            {
                                                TaskDisp.Vermes3200[i].Param.NP = 1;
                                                TaskDisp.Vermes3200[i].Set();
                                            }
                                        }
                                    }
                                    VermesInterval = TaskDisp.Vermes3200[0].Param.RI + TaskDisp.Vermes3200[0].Param.OT + TaskDisp.Vermes3200[0].Param.FA + TaskDisp.Vermes3200[0].Param.DL;
                                    break;
                                case TaskDisp.EPumpType.Vermes1560:
                                    for (int i = 0; i < 2; i++)
                                    {
                                        if (TaskDisp.Vermes1560[i].IsOpen)
                                        {
                                            if (TaskDisp.Vermes1560[i].NP[0] != 1)
                                            {
                                                TaskDisp.Vermes1560[i].NP[0] = 1;
                                                TaskDisp.Vermes1560[i].UpdateSetup();
                                            }
                                        }
                                    }
                                    VermesInterval = TaskDisp.Vermes1560[0].OT[0] + TaskDisp.Vermes1560[0].CT[0];
                                    break;
                            }
                        }
                        #endregion
                        break;
                    case ERunMode.Camera:
                    case ERunMode.Dry:
                        break;
                }
                #endregion

                #region Move GZ2 Up if invalid
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2 && !b_Head2IsValid)
                {
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            if (!TaskDisp.TaskMoveGZ2Up()) return false;
                            break;
                    }
                }
                #endregion

                #region assign and translate position
                double dx = f_origin_x + rt_LayoutRelPos[RunTime.UIndex].X + Line.X[0];
                double dy = f_origin_y + rt_LayoutRelPos[RunTime.UIndex].Y + Line.Y[0];
                TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);

                double dx2 = f_origin_x + rt_LayoutRelPos[RunTime.UIndex2].X + Line.X[0];
                double dy2 = f_origin_y + rt_LayoutRelPos[RunTime.UIndex2].Y + Line.Y[0];
                TranslatePos(dx2, dy2, rt_Head2RefData, ref dx2, ref dy2);

                dx = dx + BiasKernel.X[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XZ_YTABLE)
                    dy = dy - BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                else
                    dy = dy + BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];

                double X1 = dx;
                double Y1 = dy;
                double X2 = dx2;
                double Y2 = dy2;
                #endregion

                double X2_Ofst = X2 - X1;
                double Y2_Ofst = Y2 - Y1;

                TPos2 GXY = new TPos2(X1, Y1);
                TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                #region Set XY Pos
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                        {
                            if (!b_SyncHead2)
                            {
                                if (b_HeadRun[0])//(HeadNo == EHeadNo.Head1)
                                {
                                    GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                    GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;
                                }
                                if (b_HeadRun[1])//(HeadNo == EHeadNo.Head2)
                                {
                                    GXY.X = GXY.X + TaskDisp.Head_Ofst[1].X;
                                    GXY.Y = GXY.Y + TaskDisp.Head_Ofst[1].Y;
                                }
                            }
                            else
                            {
                                GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;

                                GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + X2_Ofst + TaskDisp.Head2_XOffset;
                                GX2Y2.Y = GX2Y2.Y + Y2_Ofst + TaskDisp.Head2_YOffset;
                            }
                            break;
                        }
                    case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }
                #endregion

                #region Move XY Pos
                if (!TaskGantry.SetMotionParamGXY()) goto _Error;
                if (!TaskGantry.MoveAbsGXY(GXY.X, GXY.Y, false)) goto _Error;
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                {
                    if (b_HeadRun[1])
                    {
                        if (!TaskGantry.SetMotionParamGX2Y2()) goto _Error;
                        if (!TaskGantry.MoveAbsGX2Y2(GX2Y2.X, GX2Y2.Y, false)) goto _Error;
                    }
                }
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                    TaskGantry.WaitGX2Y2();
                TaskGantry.WaitGXY();
                #endregion

                double Z1 = 0;
                double Z2 = 0;

                #region Assign Z positions
                double dz = f_origin_z;
                dz = dz + TaskDisp.Head_Ofst[0].Z;
                double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z));
                double dz2 = dz + ZDiff;
                Z1 = dz;
                Z2 = dz2;
                #endregion
                #region Update Z Offset
                Z1 = Z1 + TaskDisp.Z1Offset;
                Z2 = Z2 + TaskDisp.Z2Offset + TaskDisp.Head2_ZOffset;
                #endregion

                #region If ZPlane Valid, Update Z Values
                double LX1 = GXY.X - TaskDisp.Head_Ofst[0].X;
                double LY1 = GXY.Y - TaskDisp.Head_Ofst[0].Y;
                double LX2 = LX1 + (X2 - X1);
                double LY2 = LY1 + (Y2 - Y1);
                UpdateZHeight(b_SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
                #endregion

                double Z1RetGapPos = Z1 + Model.DispGap + Model.RetGap;
                if (Z1RetGapPos > TaskDisp.ZDefPos) Z1RetGapPos = TaskDisp.ZDefPos;
                double Z2RetGapPos = Z2 + Model.DispGap + Model.RetGap;
                if (Z2RetGapPos > TaskDisp.ZDefPos) Z2RetGapPos = TaskDisp.ZDefPos;

                #region Move First Gap
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                        {
                            //move to First Gap
                            double d1 = Math.Round(TaskGantry.GZPos(), 4);
                            double d2 = Math.Round(TaskGantry.GZ2Pos(), 4);
                            double d1T = Math.Round(Z1RetGapPos, 4);
                            double d2T = Math.Round(Z2RetGapPos, 4);
                            if ((b_HeadRun[0] && ((d1 < d1T - 0.001) || (d1 > d1T + 0.001))) || (b_HeadRun[1] && ((d2 < d2T - 0.001) || (d2 > d2T + 0.001))))
                            {
                                if (!TaskGantry.SetMotionParamGZZ2(Model.DnStartV, Model.DnSpeed, Model.DnAccel)) return false;
                                if (!MoveZAbs(b_HeadRun[0], b_HeadRun[1], d1T, d2T)) return false;

                                #region First Gap Wait
                                t = GDefine.GetTickCount() + Model.FirstGapWait;
                                while (GDefine.GetTickCount() < t) { }
                                { Thread.Sleep(1); }
                                #endregion
                            }
                            break;
                        }
                    case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }
                #endregion

                #region move z to DispGap
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                        {

                            double sv = Model.DnStartV;
                            double dv = Model.DnSpeed;
                            double ac = Model.DnAccel;
                            if (!TaskGantry.SetMotionParamGZZ2(sv, dv, ac)) goto _Stop;
                            if (!MoveZAbs(b_HeadRun[0], b_HeadRun[1], Z1 + Model.DispGap, Z2 + Model.DispGap)) return false;


                            break;
                        }
                    case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }
                #endregion

                if (DispProg.Options_EnableProcessLog)
                {
                    string str = $"DotLineMulti\t";
                    //str += $"Head={Line.ID}\t";
                    //str += $"UnitNo={RunTime.UIndex}\t";
                    str += $"DispGap={Model.DispGap:f3}\t";
                    str += $"C,R={RunTime.Head_CR[0].X},{RunTime.Head_CR[0].Y}\t";
                    str += $"X,Y,Z={GXY.X:f3},{GXY.Y:f3},{Z1 + Model.DispGap:f3}\t";
                    if (Head_Operation == TaskDisp.EHeadOperation.Sync)
                    {
                        str += $"C2,R2={RunTime.Head_CR[1].X},{RunTime.Head_CR[1].Y}\t";
                        str += $"X2,Y2,Z2={GX2Y2.X:f3},{GX2Y2.Y:f3},{Z2 + Model.DispGap:f3}\t";
                        double zdiff = TaskDisp.Head_ZSensor_RefPosZ[1] - TaskDisp.Head_ZSensor_RefPosZ[0];
                        str += $"X2A,Y2A,Z2A={GXY.X + X2_Ofst:f3},{GXY.Y + Y2_Ofst:f3},{Z2 + zdiff + Model.DispGap:f3}\t";
                    }

                    GLog.WriteProcessLog(str);
                }

                int t_Log = GDefine.GetTickCount();

                double[] RelDummyPos = new double[4] { 0, 0, 0, 0 };
                CControl2.TAxis[] Axis = new CControl2.TAxis[] { TaskGantry.GXAxis, TaskGantry.GYAxis, TaskGantry.GZAxis, TaskGantry.GZ2Axis };
                CommonControl.P1245.PathFree(Axis);
                CommonControl.P1245.SetAccel(Axis, Model.DnAccel);

                #region Set Paths REL Operation

                if (RunMode == ERunMode.Normal || RunMode == ERunMode.Dry)
                {
                    double[] RelDispDist = new double[4] { 0, 0, 0, 0 };
                    if (b_HeadRun[0]) RelDispDist[2] = -Model.RetGap;
                    if (b_HeadRun[1]) RelDispDist[3] = -Model.RetGap;
                }
                if (Model.DnWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.DnWait, 0, null, null);

                int Points = Line.IPara[5];
                double LineSpeed = Model.LineSpeed;
                for (int j = 1; j < Points; j++)
                {
                    int Dots = (int)Line.U[j];
                    double Rel_X = Line.X[j] - Line.X[j - 1];
                    double Rel_Y = Line.Y[j] - Line.Y[j - 1];
                    double Dist = Math.Sqrt(Math.Pow(Rel_X, 2) + Math.Pow(Rel_Y, 2));

                    if (Dots > 0)
                    {
                        if (Pump_Type == TaskDisp.EPumpType.Vermes || Pump_Type == TaskDisp.EPumpType.Vermes1560)
                        {
                            double TravelTime = VermesInterval * Dots;
                            double MaxLineSpeed = Dist / (TravelTime / 1000);
                            if (Model.LineSpeedAct == 0) LineSpeed = MaxLineSpeed;
                        }
                    }
                    double HPitch_X = Rel_X / (Dots * 2);
                    double HPitch_Y = Rel_Y / (Dots * 2);
                    double[] Rel_Dist = new double[4] { HPitch_X, HPitch_Y, 0, 0 };

                    CommonControl.P1245.SetAccel(Axis, Model.LineAccel);
                    if (Dots == 0)
                    {
                        CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, LineSpeed, 0, new double[4] { Rel_X, Rel_Y, 0, 0 }, new double[4] { Rel_X, Rel_Y, 0, 0 });
                    }
                    else

                        for (int i = 0; i < Dots; i++)
                        {
                            CControl2.TOutput[] Output = null;
                            Outputs(b_HeadRun, ref Output);


                            double StartV = LineSpeed;// Model.LineStartV;
                            if (j == 1 && i == 0)
                                StartV = Math.Min(StartV, Model.LineStartV);

                            CommonControl.P1245.PathAddDO(Axis, Output, RunMode == ERunMode.Normal);
                            CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, LineSpeed, StartV, new double[4] { HPitch_X, HPitch_Y, 0, 0 }, new double[4] { HPitch_X, HPitch_Y, 0, 0 });


                            StartV = LineSpeed;
                            if (j == Points - 1 && i == Dots - 1)
                                StartV = Math.Min(StartV, Model.LineStartV);
                            CommonControl.P1245.PathAddDO(Axis, Output, false);
                            CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, LineSpeed, StartV, new double[4] { HPitch_X, HPitch_Y, 0, 0 }, new double[4] { HPitch_X, HPitch_Y, 0, 0 });
                            //}
                            //if (j == 1 || j == Points - 1)
                            //    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, LineSpeed, Model.LineStartV, new double[4] { HPitch_X, HPitch_Y, 0, 0 }, new double[4] { HPitch_X, HPitch_Y, 0, 0 });
                            //else


                            //if (j == 1 || j == Points - 1)
                            //    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, LineSpeed, Model.LineStartV, new double[4] { HPitch_X, HPitch_Y, 0, 0 }, new double[4] { HPitch_X, HPitch_Y, 0, 0 });
                            //else
                            //if (j == Points - 1 && i == Dots - 1)
                            //{
                            //    CommonControl.P1245.PathAddDO(Axis, Output, RunMode == ERunMode.Normal);
                            //    StartV = LineSpeed;
                            //    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, LineSpeed, StartV, new double[4] { HPitch_X, HPitch_Y, 0, 0 }, new double[4] { HPitch_X, HPitch_Y, 0, 0 });
                            //    CommonControl.P1245.PathAddDO(Axis, Output, false);
                            //    StartV = 0;
                            //    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, LineSpeed, StartV, new double[4] { HPitch_X, HPitch_Y, 0, 0 }, new double[4] { HPitch_X, HPitch_Y, 0, 0 });
                            //}
                        }
                }
                if (Model.PostWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.PostWait, 0, null, null);

                if (RunMode == ERunMode.Normal || RunMode == ERunMode.Dry)
                {
                    double[] RelRetDist = new double[4] { 0, 0, 0, 0 };
                    if (b_HeadRun[0]) RelRetDist[2] = Model.RetGap;
                    if (b_HeadRun[1]) RelRetDist[3] = Model.RetGap;
                    if (Model.RetGap > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, Model.RetSpeed, Model.RetStartV, RelRetDist, RelDummyPos);
                    if (Model.RetWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.RetWait, 0, null, null);

                    double[] RelUpGaps = new double[4] { 0, 0, 0, 0 };
                    if (b_HeadRun[0]) RelUpGaps[2] = Model.UpGap;
                    if (b_HeadRun[1]) RelUpGaps[3] = Model.UpGap;
                    if (Model.UpGap > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, Model.RetSpeed, Model.UpStartV, RelUpGaps, RelDummyPos);
                    if (Model.UpWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.UpWait, 0, null, null);

                }
                #endregion

                #region Wait Pump Para
                switch (RunMode)
                {
                    case ERunMode.Normal:
                        #region
                        if (Disp)
                        {
                            switch (Pump_Type)
                            {
                                case TaskDisp.EPumpType.PP:
                                case TaskDisp.EPumpType.PP2D:
                                case TaskDisp.EPumpType.PPD:
                                    if (!TaskDisp.Thread_SetDispVolume_Wait()) goto _Stop;
                                    break;
                                case TaskDisp.EPumpType.Vermes:
                                    break;
                            }
                        }
                        #endregion
                        break;
                    case ERunMode.Camera:
                    case ERunMode.Dry:
                        break;
                }
                #endregion

                int t2 = GDefine.GetTickCount() - t_Log;

                #region Move Paths
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                    case ERunMode.Camera:
                        {
                            //uint i1 = 0;
                            //uint i2 = 0;
                            //uint i3 = 0;
                            //CommonControl.P1245.PathInfo(Axis, ref i1, ref i2, ref i3);
                            CommonControl.P1245.PathEnd(Axis);
                            //CommonControl.P1245.PathInfo(Axis, ref i1, ref i2, ref i3);
                            CommonControl.P1245.PathMove(Axis);

                            while (true)
                            {
                                //CommonControl.P1245.PathInfo(Axis, ref i1, ref i2, ref i3);
                                if (!CommonControl.P1245.AxisBusy(Axis)) break;
                            }
                            //CommonControl.P1245.PathInfo(Axis, ref i1, ref i2, ref i3);

                            //CommonControl.P1245.PathMove(Axis);

                            break;
                        }
                    //case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }
                #endregion

                #region ZPanelGap
                //switch (RunMode)
                //{
                //    case ERunMode.Normal:
                //    case ERunMode.Dry:
                //        {
                //            if (Model.PanelGap != 0 && rt_Layouts[rt_LayoutID].LastInCluster(rt_UIndex))
                //            {
                //                #region Move Panel Gap
                //                if (!TaskGantry.SetMotionParamGZZ2()) goto _Stop;

                //                double Z1PanelGap = Z1 + Model.PanelGap;
                //                if (Z1PanelGap > TaskDisp.ZDefPos) Z1PanelGap = TaskDisp.ZDefPos;
                //                double Z2PanelGap = Z2 + Model.PanelGap;
                //                if (Z2PanelGap > TaskDisp.ZDefPos) Z2PanelGap = TaskDisp.ZDefPos;

                //                if (!MoveZAbs(b_HeadRun[0], b_HeadRun[1], Z1PanelGap, Z2PanelGap)) return false;
                //                #endregion
                //            }
                //            break;
                //        }
                //    case ERunMode.Camera:
                //        {
                //            break;
                //        }
                //}
                #endregion
            }
            catch (Exception Ex)
            {
                GDefine.Status = EStatus.ErrorInit;
                TaskDisp.TrigOff(true, true);
                EMsg = EMsg + (char)13 + Ex.Message.ToString();
                throw new Exception(EMsg);
            }
            _End:
            GDefine.Status = EStatus.Ready;
            return true;
            _Stop:
            GDefine.Status = EStatus.Stop;
            return false;
            _Error:
            GDefine.Status = EStatus.ErrorInit;
            return false;
        }
        public static bool DoLineMulti(TLine Line, ERunMode RunMode, double f_origin_x, double f_origin_y, double f_origin_z)
        {
            string EMsg = "Line_Multi";
            int t = 0;

            GDefine.Status = EStatus.Busy;

            EDotMode DotMode = (EDotMode)Line.IPara[1];

            double VermesInterval = 25;//ms

            try
            {
                bool b_Head2IsValid = false;
                bool b_SyncHead2 = false;
                bool[] b_HeadRun = new bool[2] { false, false };
                if (!SelectHead(Line, ref b_HeadRun, ref b_Head2IsValid, ref b_SyncHead2)) goto _End;

                TModelPara Model = new TModelPara(ModelList, Line.IPara[0]);
                bool Disp = (Line.IPara[2] > 0);

                #region Set Pump Para
                switch (RunMode)
                {
                    case ERunMode.Normal:
                        #region
                        double VolToDispA_ul = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj;
                        double VolToDispB_ul = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj;

                        if (rt_Head1VolumeOfst != 0)
                        {
                            VolToDispA_ul = VolToDispA_ul + rt_Head1VolumeOfst;
                        }
                        if (rt_Head2VolumeOfst != 0)
                        {
                            VolToDispB_ul = VolToDispB_ul + rt_Head2VolumeOfst;
                        }
                        if (Model.DispVol > 0)
                        {
                            VolToDispA_ul = Model.DispVol;
                            VolToDispB_ul = Model.DispVol;
                        }

                        if (Disp)
                        {
                            switch (Pump_Type)
                            {
                                case TaskDisp.EPumpType.PP:
                                case TaskDisp.EPumpType.PP2D:
                                case TaskDisp.EPumpType.PPD:
                                       if (VolToDispA_ul != progDispVol[0] || VolToDispB_ul != progDispVol[1])
                                        {
                                            if (!TaskDisp.SetDispVolume(b_HeadRun[0], b_HeadRun[1], VolToDispA_ul, VolToDispB_ul))
                                            {
                                                Msg MsgBox = new Msg();
                                                MsgBox.Show(ErrCode.DISPCTRL1_COMM_ERR, "SetDispVolume ");
                                                goto _Stop;
                                            }
                                            if (b_HeadRun[0]) progDispVol[0] = VolToDispA_ul;
                                            if (b_HeadRun[1]) progDispVol[1] = VolToDispB_ul;
                                        }                                    
                                    break;
                                case TaskDisp.EPumpType.Vermes:
                                    for (int i = 0; i < 2; i++)
                                    {
                                        if (TaskDisp.Vermes3200[i].IsOpen)
                                        {
                                            if (TaskDisp.Vermes3200[i].Param.NP != 1)
                                            {
                                                TaskDisp.Vermes3200[i].Param.NP = 1;
                                                TaskDisp.Vermes3200[i].Set();
                                            }
                                        }
                                    }
                                    VermesInterval = TaskDisp.Vermes3200[0].Param.RI + TaskDisp.Vermes3200[0].Param.OT + TaskDisp.Vermes3200[0].Param.FA + TaskDisp.Vermes3200[0].Param.DL;
                                    break;
                                case TaskDisp.EPumpType.Vermes1560:
                                    for (int i = 0; i < 2; i++)
                                    {
                                        if (TaskDisp.Vermes1560[i].IsOpen)
                                        {
                                            if (TaskDisp.Vermes1560[i].NP[0] != 1)
                                            {
                                                TaskDisp.Vermes1560[i].NP[0] = 1;
                                                TaskDisp.Vermes1560[i].UpdateSetup();
                                            }
                                        }
                                    }
                                    VermesInterval = TaskDisp.Vermes1560[0].OT[0] + TaskDisp.Vermes1560[0].CT[0];
                                    break;
                            }
                        }
                        #endregion
                        break;
                    case ERunMode.Camera:
                    case ERunMode.Dry:
                        break;
                }
                #endregion

                #region Move GZ2 Up if invalid
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2 && !b_Head2IsValid)
                {
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            if (!TaskDisp.TaskMoveGZ2Up()) return false;
                            break;
                    }
                }
                #endregion

                #region assign and translate position
                double dx = f_origin_x + rt_LayoutRelPos[RunTime.UIndex].X + Line.X[0];
                double dy = f_origin_y + rt_LayoutRelPos[RunTime.UIndex].Y + Line.Y[0];
                TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);

                double dx2 = f_origin_x + rt_LayoutRelPos[RunTime.UIndex2].X + Line.X[0];
                double dy2 = f_origin_y + rt_LayoutRelPos[RunTime.UIndex2].Y + Line.Y[0];
                TranslatePos(dx2, dy2, rt_Head2RefData, ref dx2, ref dy2);

                dx = dx + BiasKernel.X[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XZ_YTABLE)
                    dy = dy - BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];
                else
                    dy = dy + BiasKernel.Y[RunTime.Bias_Head_CR.X, RunTime.Bias_Head_CR.Y];

                double X1 = dx;
                double Y1 = dy;
                double X2 = dx2;
                double Y2 = dy2;
                #endregion

                double X2_Ofst = X2 - X1;
                double Y2_Ofst = Y2 - Y1;

                TPos2 GXY = new TPos2(X1, Y1);
                TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                #region Set XY Pos
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                        {
                            if (!b_SyncHead2)
                            {
                                if (b_HeadRun[0])//(HeadNo == EHeadNo.Head1)
                                {
                                    GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                    GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;
                                }
                                if (b_HeadRun[1])//(HeadNo == EHeadNo.Head2)
                                {
                                    GXY.X = GXY.X + TaskDisp.Head_Ofst[1].X;
                                    GXY.Y = GXY.Y + TaskDisp.Head_Ofst[1].Y;
                                }
                            }
                            else
                            {
                                GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;

                                GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + X2_Ofst + TaskDisp.Head2_XOffset;
                                GX2Y2.Y = GX2Y2.Y + Y2_Ofst + TaskDisp.Head2_YOffset;
                            }
                            break;
                        }
                    case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }
                #endregion

                #region Move XY Pos
                if (!TaskGantry.SetMotionParamGXY()) goto _Error;
                if (!TaskGantry.MoveAbsGXY(GXY.X, GXY.Y, false)) goto _Error;
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                {
                    if (b_HeadRun[1])
                    {
                        if (!TaskGantry.SetMotionParamGX2Y2()) goto _Error;
                        if (!TaskGantry.MoveAbsGX2Y2(GX2Y2.X, GX2Y2.Y, false)) goto _Error;
                    }
                }
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                    TaskGantry.WaitGX2Y2();
                TaskGantry.WaitGXY();
                #endregion

                double Z1 = 0;
                double Z2 = 0;

                #region Assign Z positions
                double dz = f_origin_z;
                dz = dz + TaskDisp.Head_Ofst[0].Z;
                double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z));
                double dz2 = dz + ZDiff;
                Z1 = dz;
                Z2 = dz2;
                #endregion
                #region Update Z Offset
                Z1 = Z1 + TaskDisp.Z1Offset;
                Z2 = Z2 + TaskDisp.Z2Offset + TaskDisp.Head2_ZOffset;
                #endregion

                #region If ZPlane Valid, Update Z Values
                double LX1 = GXY.X - TaskDisp.Head_Ofst[0].X;
                double LY1 = GXY.Y - TaskDisp.Head_Ofst[0].Y;
                double LX2 = LX1 + (X2 - X1);
                double LY2 = LY1 + (Y2 - Y1);
                UpdateZHeight(b_SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
                #endregion

                double Z1RetGapPos = Z1 + Model.DispGap + Model.RetGap;
                if (Z1RetGapPos > TaskDisp.ZDefPos) Z1RetGapPos = TaskDisp.ZDefPos;
                double Z2RetGapPos = Z2 + Model.DispGap + Model.RetGap;
                if (Z2RetGapPos > TaskDisp.ZDefPos) Z2RetGapPos = TaskDisp.ZDefPos;

                #region Move First Gap
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                        {
                            //move to First Gap
                            double d1 = Math.Round(TaskGantry.GZPos(), 4);
                            double d2 = Math.Round(TaskGantry.GZ2Pos(), 4);
                            double d1T = Math.Round(Z1RetGapPos, 4);
                            double d2T = Math.Round(Z2RetGapPos, 4);
                            if ((b_HeadRun[0] && ((d1 < d1T - 0.001) || (d1 > d1T + 0.001))) || (b_HeadRun[1] && ((d2 < d2T - 0.001) || (d2 > d2T + 0.001))))
                            {
                                if (!TaskGantry.SetMotionParamGZZ2(Model.DnStartV, Model.DnSpeed, Model.DnAccel)) return false;
                                if (!MoveZAbs(b_HeadRun[0], b_HeadRun[1], d1T, d2T)) return false;

                                #region First Gap Wait
                                t = GDefine.GetTickCount() + Model.FirstGapWait;
                                while (GDefine.GetTickCount() < t) { }
                                { Thread.Sleep(1); }
                                #endregion
                            }
                            break;
                        }
                    case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }
                #endregion

                #region move z to DispGap
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                        {

                            double sv = Model.DnStartV;
                            double dv = Model.DnSpeed;
                            double ac = Model.DnAccel;
                            if (!TaskGantry.SetMotionParamGZZ2(sv, dv, ac)) goto _Stop;
                            if (!MoveZAbs(b_HeadRun[0], b_HeadRun[1], Z1 + Model.DispGap, Z2 + Model.DispGap)) return false;


                            break;
                        }
                    case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }
                #endregion

                if (DispProg.Options_EnableProcessLog)
                {
                    string str = $"LineMulti\t";
                    //str += $"Head\t{Line.ID}\t";
                    //str += $"UnitNo={RunTime.UIndex}\t";
                    str += $"DispGap={Model.DispGap:f3}\t";
                    str += $"C,R={RunTime.Head_CR[0].X},{RunTime.Head_CR[0].Y}\t";
                    str += $"X,Y,Z={GXY.X:f3},{GXY.Y:f3},{Z1 + Model.DispGap:f3}\t";
                    if (Head_Operation == TaskDisp.EHeadOperation.Sync)
                    {
                        str += $"C2,R2={RunTime.Head_CR[1].X},{RunTime.Head_CR[1].Y}\t";
                        str += $"X2,Y2,Z2={GX2Y2.X:f3},{GX2Y2.Y:f3},{Z2 + Model.DispGap:f3}\t";
                        double zdiff = TaskDisp.Head_ZSensor_RefPosZ[1] - TaskDisp.Head_ZSensor_RefPosZ[0];
                        str += $"X2A,Y2A,Z2A={GXY.X + X2_Ofst:f3},{GXY.Y + Y2_Ofst:f3},{Z2 + zdiff + Model.DispGap:f3}\t";
                    }

                    GLog.WriteProcessLog(str);
                }

                int t_Log = GDefine.GetTickCount();

                CControl2.TOutput[] Output = null;
                Outputs(b_HeadRun, ref Output);

                double[] RelDummyPos = new double[4] { 0, 0, 0, 0 };
                CControl2.TAxis[] Axis = new CControl2.TAxis[] { TaskGantry.GXAxis, TaskGantry.GYAxis, TaskGantry.GZAxis, TaskGantry.GZ2Axis };
                CommonControl.P1245.PathFree(Axis);
                CommonControl.P1245.SetAccel(Axis, Model.DnAccel);

                #region Set Paths REL Operation
                if (RunMode == ERunMode.Normal || RunMode == ERunMode.Dry)
                {
                    double[] RelDispDist = new double[4] { 0, 0, 0, 0 };
                    if (b_HeadRun[0]) RelDispDist[2] = -Model.RetGap;
                    if (b_HeadRun[1]) RelDispDist[3] = -Model.RetGap;
                    //CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, Model.DnSpeed, Model.DnStartV, RelDispDist, RelDummyPos);
                }
                if (Model.DnWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.DnWait, 0, null, null);

                if (Model.StartDelay > 0)
                {
                    CommonControl.P1245.PathAddDO(Axis, Output, RunMode == ERunMode.Normal);
                    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.StartDelay, 0, null, null);
                }

                int Points = Line.IPara[5];
                for (int j = 1; j < Points; j++)
                {
                    int Dots = (int)Line.U[j];
                    double Rel_X = Line.X[j] - Line.X[j - 1];
                    double Rel_Y = Line.Y[j] - Line.Y[j - 1];
                    //if (TaskGantry.GXAxis.Para.InvertPulse) Rel_X = -Rel_X;
                    //if (TaskGantry.GYAxis.Para.InvertPulse) Rel_Y = -Rel_Y;
                    double Dist = Math.Sqrt(Math.Pow(Rel_X, 2) + Math.Pow(Rel_Y, 2));

                    double Rel_Z = 0;
                    double Rel_Z2 = 0;
                    TModelPara Model_Psnt = new TModelPara(ModelList, (int)Line.Z[j]);
                    TModelPara Model_Prev = new TModelPara(ModelList, (int)Line.Z[j - 1]);
                    if (RunMode == ERunMode.Normal || RunMode == ERunMode.Dry)
                    {
                        Rel_Z = Model_Psnt.DispGap - Model_Prev.DispGap;
                        Rel_Z2 = 0;
                        //if (TaskGantry.GZAxis.Para.InvertPulse) Rel_Z = -Rel_Z;
                    }
                    double LineSpeed = Model_Psnt.LineSpeed;

                    double[] Rel_Dist = new double[4] { Rel_X, Rel_Y, Rel_Z, Rel_Z2 };

                    CommonControl.P1245.SetAccel(Axis, Model.LineAccel);
                    double StartV = LineSpeed;
                    if (j == 1 || j == Points - 1)
                        StartV = Math.Min(StartV, Model.LineStartV);

                    if (Line.U[j] > 0)
                        CommonControl.P1245.PathAddDO(Axis, Output, RunMode == ERunMode.Normal);
                    else
                        CommonControl.P1245.PathAddDO(Axis, Output, false);

                    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, LineSpeed, StartV, Rel_Dist, Rel_Dist);
                }
                //if (Model.EndDelay > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.PostWait, 0, null, null);

                if (Model.PostWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.PostWait, 0, null, null);

                if (RunMode == ERunMode.Normal || RunMode == ERunMode.Dry)
                {
                    double[] RelRetDist = new double[4] { 0, 0, 0, 0 };
                    if (b_HeadRun[0]) RelRetDist[2] = Model.RetGap;
                    if (b_HeadRun[1]) RelRetDist[3] = Model.RetGap;
                    CommonControl.P1245.SetAccel(Axis, Model.RetAccel);
                    if (Model.RetGap > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, Model.RetSpeed, Model.RetStartV, RelRetDist, RelDummyPos);
                    if (Model.RetWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.RetWait, 0, null, null);

                    double[] RelUpGaps = new double[4] { 0, 0, 0, 0 };
                    if (b_HeadRun[0]) RelUpGaps[2] = Model.UpGap;
                    if (b_HeadRun[1]) RelUpGaps[3] = Model.UpGap;
                    CommonControl.P1245.SetAccel(Axis, Model.UpAccel);
                    if (Model.UpGap > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, Model.RetSpeed, Model.UpStartV, RelUpGaps, RelDummyPos);
                    if (Model.UpWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.UpWait, 0, null, null);

                }
                #endregion

                #region Wait Pump Para
                switch (RunMode)
                {
                    case ERunMode.Normal:
                        #region
                        if (Disp)
                        {
                            switch (Pump_Type)
                            {
                                case TaskDisp.EPumpType.PP:
                                case TaskDisp.EPumpType.PP2D:
                                case TaskDisp.EPumpType.PPD:
                                    if (!TaskDisp.Thread_SetDispVolume_Wait()) goto _Stop;
                                    break;
                            }
                        }
                        #endregion
                        break;
                    case ERunMode.Camera:
                    case ERunMode.Dry:
                        break;
                }
                #endregion

                int t2 = GDefine.GetTickCount() - t_Log;

                #region Move Paths
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                    case ERunMode.Camera:
                        {
                            //uint i1 = 0;
                            //uint i2 = 0;
                            //uint i3 = 0;
                            //CommonControl.P1245.PathInfo(Axis, ref i1, ref i2, ref i3);
                            CommonControl.P1245.PathEnd(Axis);
                            //CommonControl.P1245.PathInfo(Axis, ref i1, ref i2, ref i3);
                            CommonControl.P1245.PathMove(Axis);

                            while (true)
                            {
                                //CommonControl.P1245.PathInfo(Axis, ref i1, ref i2, ref i3);
                                if (!CommonControl.P1245.AxisBusy(Axis)) break;
                            }
                            //CommonControl.P1245.PathInfo(Axis, ref i1, ref i2, ref i3);

                            //CommonControl.P1245.PathMove(Axis);

                            break;
                        }
                    //case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }
                #endregion

                #region ZPanelGap
                //switch (RunMode)
                //{
                //    case ERunMode.Normal:
                //    case ERunMode.Dry:
                //        {
                //            if (Model.PanelGap != 0 && rt_Layouts[rt_LayoutID].LastInCluster(rt_UIndex))
                //            {
                //                #region Move Panel Gap
                //                if (!TaskGantry.SetMotionParamGZZ2()) goto _Stop;

                //                double Z1PanelGap = Z1 + Model.PanelGap;
                //                if (Z1PanelGap > TaskDisp.ZDefPos) Z1PanelGap = TaskDisp.ZDefPos;
                //                double Z2PanelGap = Z2 + Model.PanelGap;
                //                if (Z2PanelGap > TaskDisp.ZDefPos) Z2PanelGap = TaskDisp.ZDefPos;

                //                if (!MoveZAbs(b_HeadRun[0], b_HeadRun[1], Z1PanelGap, Z2PanelGap)) return false;
                //                #endregion
                //            }
                //            break;
                //        }
                //    case ERunMode.Camera:
                //        {
                //            break;
                //        }
                //}
                #endregion
            }
            catch (Exception Ex)
            {
                GDefine.Status = EStatus.ErrorInit;
                TaskDisp.TrigOff(true, true);
                EMsg = EMsg + (char)13 + Ex.Message.ToString();
                throw new Exception(EMsg);
            }
            _End:
            GDefine.Status = EStatus.Ready;
            return true;
            _Stop:
            GDefine.Status = EStatus.Stop;
            return false;
            _Error:
            GDefine.Status = EStatus.ErrorInit;
            return false;
        }

        public enum EFillPatType { None = 0, Spiral, SpiralStar, SpiralCurve, Snake, ZigZag, Star, SpiralStar2, SpiralCurve2, SpiralStar3, SpiralCurve3 };
        internal class TFillPat
        {
            TLine _Line = new TLine();
            TPos2 _Size = new TPos2(0, 0);
            int _Section = 2;
            TPos2 _Pitch = new TPos2(0, 0);
            public TFillPat(TLine Line)
            {
                Type = (EFillPatType)Line.IPara[1];

                Start.X = Line.X[0];
                Start.Y = Line.Y[0];
                _Size.X = Line.X[1];
                _Size.Y = Line.Y[1];
                _Section = Line.IPara[4];
                RatioX = Math.Max(0.01, Line.X[5]);
                RatioY = Math.Max(0.01, Line.Y[5]);
                Angle = Line.DPara[5];
                Comp = Line.IPara[3] > 0;
            }
            public EFillPatType Type = EFillPatType.None;
            public TPos2 Start = new TPos2(0, 0);
            public TPos2 Center
            {
                get
                {
                    TPos2 XY = new TPos2(
                        this.Start.X + (this.Size.X / 2),
                        this.Start.Y + (this.Size.Y / 2));

                    return XY;
                }
                set
                {
                    TPos2 XY = new TPos2(Center);
                    TPos2 Ofst = new TPos2(value.X - XY.X, value.Y - XY.Y);
                    this.Start.X += Ofst.X;
                    this.Start.Y += Ofst.Y;
                }
            }
            public TPos2 Size
            {
                get
                {
                    return this._Size;
                }
                set
                {
                    _Size = value;
                    Section = this.Section;
                }
            }

            public int Section
            {
                get
                {
                    return _Section;
                }
                set
                {
                    this._Section = Math.Max(2, value);
                }
            }
            public double RatioX = 1;
            public double RatioY = 1;
            public double Angle = 0;
            public bool Comp = false;//transistion edge correction
            public TPos2 Pitch
            {
                get
                {
                    _Pitch.X = Size.X / (_Section);
                    _Pitch.Y = Size.Y / (_Section);
                    return _Pitch;
                }
            }

            public void Update(ref TLine Line)
            {
                Line.IPara[1] = (int)Type;
                Line.DPara[5] = Angle;//degree

                Line.X[0] = Start.X;
                Line.Y[0] = Start.Y;
                Line.X[1] = _Size.X;
                Line.Y[1] = _Size.Y;
                Line.IPara[4] = _Section;
                //Line.DPara[4] = RatioX;
                Line.X[5] = RatioX;
                Line.Y[5] = RatioY;
            }

            public TPos2 StartPos
            {
                get
                {
                    switch (Type)
                    {
                        case EFillPatType.None:
                            throw new Exception("Invalid Fill Pattern.");
                        default:
                            throw new Exception("Unsupported Fill Pattern.");
                        case EFillPatType.Spiral:
                        case EFillPatType.SpiralStar:
                        case EFillPatType.SpiralCurve:
                        case EFillPatType.Snake:
                        case EFillPatType.ZigZag:
                        case EFillPatType.SpiralStar2:
                        case EFillPatType.SpiralCurve2:
                        case EFillPatType.SpiralStar3:
                        case EFillPatType.SpiralCurve3:
                            {
                                TPos2 StartPt = new TPos2(Start.X, Start.Y);

                                if (Angle != 0)
                                {
                                    NSW.Net.Polar polar = new Polar(new Point2D(Center.X, Center.Y), new Point2D(Start.X, Start.Y));
                                    double rad_Angle = Angle * (Math.PI / 180);
                                    polar.A = polar.A + rad_Angle;
                                    StartPt = new TPos2(polar.Point2D.X + Center.X, polar.Point2D.Y + Center.Y);
                                }

                                return StartPt;
                            }
                        case EFillPatType.Star:
                            return new TPos2(Start.X + Size.X / 2, Start.Y + Size.Y / 2);
                    }
                }
            }
            public List<TPos2> RelPos//relative coordinate
            {
                get
                {
                    List<TPos2> _Lines = new List<TPos2>();
                    TPos2 XY = new TPos2(0, 0);

                    switch (Type)
                    {
                        case EFillPatType.None:
                            throw new Exception("Invalid Fill Pattern.");
                        default:
                            throw new Exception("Unsupported Fill Pattern.");
                        case EFillPatType.Spiral:
                            #region
                            {
                                for (int i = 0; i < _Section; i++)
                                {
                                    if (i == 0)
                                    {
                                        _Lines.Add(new TPos2(Size.X, 0));
                                        _Lines.Add(new TPos2(0, Size.Y));
                                        _Lines.Add(new TPos2(-Size.X, 0));
                                        continue;
                                    }

                                    double LenX = Size.X * ((double)(_Section - i) / _Section);
                                    double LenY = Size.Y * ((double)(_Section - i) / _Section);

                                    if (i % 2 == 1)
                                    {
                                        _Lines.Add(new TPos2(0, -LenY));
                                        _Lines.Add(new TPos2(LenX, 0));
                                    }
                                    else
                                    {
                                        _Lines.Add(new TPos2(0, LenY));
                                        _Lines.Add(new TPos2(-LenX, 0));
                                    }
                                }
                            }
                            #endregion
                            break;
                        case EFillPatType.SpiralStar:
                        case EFillPatType.SpiralCurve:
                            #region
                            {
                                for (int i = 0; i < _Section; i++)
                                {
                                    double HSizeX = Size.X / 2;
                                    double HSizeY = Size.Y / 2;
                                    double HSizeOfstX = Size.Y * RatioY;
                                    double HSizeOfstY = Size.X * RatioX;

                                    if (i == 0)
                                    {
                                        _Lines.Add(new TPos2(HSizeX, HSizeOfstY));
                                        _Lines.Add(new TPos2(HSizeX, -HSizeOfstY));

                                        _Lines.Add(new TPos2(-HSizeOfstX, HSizeY));
                                        _Lines.Add(new TPos2(HSizeOfstX, HSizeY));

                                        _Lines.Add(new TPos2(-HSizeX, -HSizeOfstY));
                                        _Lines.Add(new TPos2(-HSizeX, HSizeOfstY));
                                        continue;
                                    }

                                    double LenX = Size.X * ((double)(_Section - i) / _Section);
                                    double LenY = Size.Y * ((double)(_Section - i) / _Section);
                                    double LenXA = 0;//additional length to compensate section transition
                                    LenXA = Size.X * ((double)1 / (_Section * 2));
                                    double LenYA = 0;
                                    LenYA = Size.Y * ((double)1 / (_Section * 2));
                                    double HLenX = LenX / 2;
                                    double HLenY = LenY / 2;
                                    double HLenXOfst = LenY * RatioY;
                                    double HLenYOfst = LenX * RatioX;

                                    if (i % 2 == 1)
                                    {
                                        _Lines.Add(new TPos2(HLenXOfst, -HLenY));
                                        _Lines.Add(new TPos2(-HLenXOfst, -HLenY - LenYA));
                                        _Lines.Add(new TPos2(HLenX + (LenXA / 2), HLenYOfst + LenYA));
                                        _Lines.Add(new TPos2(HLenX - (LenXA / 2), -HLenYOfst));
                                    }
                                    else
                                    {
                                        _Lines.Add(new TPos2(-HLenXOfst, HLenY));
                                        _Lines.Add(new TPos2(HLenXOfst, HLenY));
                                        _Lines.Add(new TPos2(-HLenX, -HLenYOfst));
                                        _Lines.Add(new TPos2(-HLenX, HLenYOfst));
                                    }
                                }
                            }
                            #endregion
                            break;
                        case EFillPatType.Snake:
                            #region
                            {
                                for (int i = 0; i < _Section; i++)
                                {
                                    if (i == 0)
                                    {
                                        _Lines.Add(new TPos2(Size.X, 0));
                                    }

                                    if (i % 2 == 1)
                                    {
                                        _Lines.Add(new TPos2(0, Pitch.Y));
                                        _Lines.Add(new TPos2(Size.X, 0));
                                    }
                                    else
                                    {
                                        _Lines.Add(new TPos2(0, Pitch.Y));
                                        _Lines.Add(new TPos2(-Size.X, 0));
                                    }
                                }
                            }
                            #endregion
                            break;
                        case EFillPatType.ZigZag:
                            #region
                            {
                                for (int i = 0; i < _Section; i++)
                                {
                                    if (i == 0)
                                    {
                                        _Lines.Add(new TPos2(Size.X, 0));
                                    }
                                    _Lines.Add(new TPos2(-Size.X, Pitch.Y));
                                    _Lines.Add(new TPos2(Size.X, 0));
                                }
                            }
                            #endregion
                            break;
                        case EFillPatType.Star:
                            #region
                            {
                                double HSizeX = Size.X / 2;
                                double HSizeY = Size.Y / 2;
                                double HSize2X = HSizeX * RatioX;
                                double HSize2Y = HSizeY * RatioX;
                                for (int i = 0; i < 8; i++)
                                {
                                    switch (i)
                                    {
                                        #region Main Lines
                                        case 0:
                                            _Lines.Add(new TPos2(0, HSizeY));
                                            _Lines.Add(new TPos2(0, -HSizeY));
                                            break;
                                        case 1:
                                            _Lines.Add(new TPos2(HSizeX, 0));
                                            _Lines.Add(new TPos2(-HSizeX, 0));
                                            break;
                                        case 2:
                                            _Lines.Add(new TPos2(0, -HSizeY));
                                            _Lines.Add(new TPos2(0, HSizeY));
                                            break;
                                        case 3:
                                            _Lines.Add(new TPos2(-HSizeX, 0));
                                            _Lines.Add(new TPos2(HSizeX, 0));
                                            break;
                                        #endregion
                                        case 4:
                                            if (HSize2X != 0 && HSize2Y != 0)
                                            {
                                                _Lines.Add(new TPos2(-HSize2X, -HSize2Y));
                                                _Lines.Add(new TPos2(HSize2X, HSize2Y));
                                            }
                                            break;
                                        case 5:
                                            if (HSize2X != 0 && HSize2Y != 0)
                                            {
                                                _Lines.Add(new TPos2(HSize2X, -HSize2Y));
                                                _Lines.Add(new TPos2(-HSize2X, HSize2Y));
                                            }
                                            break;
                                        case 6:
                                            if (HSize2X != 0 && HSize2Y != 0)
                                            {
                                                _Lines.Add(new TPos2(HSize2X, HSize2Y));
                                                _Lines.Add(new TPos2(-HSize2X, -HSize2Y));
                                            }
                                            break;
                                        case 7:
                                            if (HSize2X != 0 && HSize2Y != 0)
                                            {
                                                _Lines.Add(new TPos2(-HSize2X, HSize2Y));
                                                _Lines.Add(new TPos2(HSize2X, -HSize2Y));
                                            }
                                            break;
                                    }
                                }
                            }
                            #endregion
                            break;
                        case EFillPatType.SpiralStar2:
                        case EFillPatType.SpiralCurve2:
                            #region
                            {
                                int _Set = (int)Math.Ceiling((double)_Section / 2);
                                for (int i = 0; i < _Set; i++)
                                {
                                    double LenX = Size.X * ((double)(_Section - i * 2) / _Section);
                                    double LenY = Size.Y * ((double)(_Section - i * 2) / _Section);
                                    double HLenX = LenX / 2;
                                    double HLenY = LenY / 2;
                                    double HLenXOfst = LenY * RatioY;
                                    double HLenYOfst = LenX * RatioX;

                                    if (i > 0)
                                    {
                                        double ShiftX = Size.X / _Section;
                                        double ShiftY = Size.Y / _Section;
                                        _Lines.Add(new TPos2(ShiftX, ShiftY));
                                    }

                                    _Lines.Add(new TPos2(HLenX, HLenYOfst));
                                    _Lines.Add(new TPos2(HLenX, -HLenYOfst));

                                    _Lines.Add(new TPos2(-HLenXOfst, HLenY));
                                    _Lines.Add(new TPos2(HLenXOfst, HLenY));

                                    _Lines.Add(new TPos2(-HLenX, -HLenYOfst));
                                    _Lines.Add(new TPos2(-HLenX, HLenYOfst));

                                    _Lines.Add(new TPos2(HLenXOfst, -HLenY));
                                    _Lines.Add(new TPos2(-HLenXOfst, -HLenY));
                                }
                            }
                            #endregion
                            break;
                        case EFillPatType.SpiralStar3:
                        case EFillPatType.SpiralCurve3:
                            #region
                            {
                                for (int i = 0; i < _Section; i++)
                                {
                                    double HSizeX = Size.X / 2;
                                    double HSizeY = Size.Y / 2;
                                    double HSizeOfstX = Size.Y * RatioY;
                                    double HSizeOfstY = Size.X * RatioX;
                                    double PitchX = Size.X / _Section;
                                    double PitchY = Size.X / _Section;

                                    if (i == 0)
                                    {
                                        _Lines.Add(new TPos2(HSizeX - PitchX / 2, HSizeOfstY));
                                        _Lines.Add(new TPos2(HSizeX + PitchX / 2, -HSizeOfstY));

                                        _Lines.Add(new TPos2(-HSizeOfstX, HSizeY));
                                        _Lines.Add(new TPos2(HSizeOfstX, HSizeY));

                                        _Lines.Add(new TPos2(-HSizeX, -HSizeOfstY));
                                        _Lines.Add(new TPos2(-HSizeX, HSizeOfstY));
                                        continue;
                                    }

                                    double LenX = Size.X * ((double)(_Section - i) / _Section);
                                    double LenY = Size.Y * ((double)(_Section - i) / _Section);
                                    //double LenXA = 0;//additional length to compensate section transition
                                    //LenXA = Size.X * ((double)1 / (_Section * 2));
                                    //double LenYA = 0;
                                    //LenYA = Size.Y * ((double)1 / (_Section * 2));
                                    double HLenX = LenX / 2;
                                    double HLenY = LenY / 2;
                                    double HLenXOfst = LenY * RatioY;
                                    double HLenYOfst = LenX * RatioX;

                                    //transition approximate compensatation 
                                    double ALenX = 0;
                                    double ALenY = 0;
                                    if (Comp)
                                    {
                                        ALenX = PitchX * 0.25;
                                        ALenY = PitchY * 0.25;
                                    }

                                    if (i % 2 == 1)
                                    {
                                        _Lines.Add(new TPos2(HLenXOfst, -HLenY));
                                        _Lines.Add(new TPos2(-HLenXOfst + ALenX, -HLenY - ALenY));
                                        _Lines.Add(new TPos2(HLenX - ALenX, HLenYOfst + ALenY));
                                        _Lines.Add(new TPos2(HLenX, -HLenYOfst));
                                    }
                                    else
                                    {
                                        _Lines.Add(new TPos2(-HLenXOfst, HLenY));
                                        _Lines.Add(new TPos2(HLenXOfst, HLenY));
                                        _Lines.Add(new TPos2(-HLenX, -HLenYOfst));
                                        _Lines.Add(new TPos2(-HLenX, HLenYOfst));
                                    }
                                }
                            }
                            #endregion
                            break;
                    }
                    if (Angle != 0)
                    #region
                    {
                        List<TPos2> AbsPos = new List<TPos2>();
                        TPos2 XY2 = new TPos2(Start.X - Center.X, Start.Y - Center.Y);
                        AbsPos.Add(new TPos2(XY2));
                        for (int i = 0; i < _Lines.Count; i++)
                        {
                            XY2.X += _Lines[i].X;
                            XY2.Y += _Lines[i].Y;
                            AbsPos.Add(new TPos2(XY2));
                        }

                        List<TPos2> RAbsPos = new List<TPos2>();
                        for (int i = 0; i < AbsPos.Count; i++)
                        {
                            NSW.Net.Polar polar = new Polar(new Point2D(AbsPos[i].X, AbsPos[i].Y));
                            double rad_Angle = Angle * (Math.PI / 180);
                            polar.A = polar.A + rad_Angle;
                            TPos2 new_pt = new TPos2(polar.Point2D.X, polar.Point2D.Y);
                            RAbsPos.Add(new_pt);
                        }
                        for (int i = 1; i < AbsPos.Count; i++)
                        {
                            _Lines[i - 1].X = RAbsPos[i].X - RAbsPos[i - 1].X;
                            _Lines[i - 1].Y = RAbsPos[i].Y - RAbsPos[i - 1].Y;
                        }
                    }
                    #endregion
                    return _Lines;
                }
            }
            public List<TPos2> AbsPos
            {
                get
                {
                    List<TPos2> _RelPos = new List<TPos2>();
                    List<TPos2> _Lines = new List<TPos2>();
                    TPos2 XY = new TPos2(Start.X, Start.Y);
                    if (Angle != 0)
                    {
                        NSW.Net.Polar polar = new Polar(new Point2D(Center.X, Center.Y), new Point2D(Start.X, Start.Y));
                        double rad_Angle = Angle * (Math.PI / 180);
                        polar.A = polar.A + rad_Angle;
                        XY = new TPos2(polar.Point2D.X + Center.X, polar.Point2D.Y + Center.Y);
                    }
                    _Lines.Add(new TPos2(XY));

                    switch (Type)
                    {
                        case EFillPatType.None:
                            throw new Exception("Invalid Fill Pat.");
                        default:
                            throw new Exception("Unsupported Fill Pat.");
                        case EFillPatType.Spiral:
                        case EFillPatType.SpiralStar:
                        case EFillPatType.SpiralCurve:
                        case EFillPatType.Snake:
                        case EFillPatType.ZigZag:
                        case EFillPatType.SpiralStar2:
                        case EFillPatType.SpiralCurve2:
                        case EFillPatType.SpiralStar3:
                        case EFillPatType.SpiralCurve3:
                            #region
                            {
                                _RelPos = RelPos;
                                for (int i = 0; i < _RelPos.Count; i++)
                                {
                                    XY.X += _RelPos[i].X;
                                    XY.Y += _RelPos[i].Y;//invert dir display
                                    _Lines.Add(new TPos2(XY));
                                }
                                break;
                            }
                        #endregion
                        case EFillPatType.Star:
                            #region
                            {
                                XY = new TPos2(Center);
                                _Lines[0] = new TPos2(XY);

                                _RelPos = RelPos;
                                for (int i = 0; i < _RelPos.Count; i++)
                                {
                                    XY.X += _RelPos[i].X;
                                    XY.Y += _RelPos[i].Y;
                                    _Lines.Add(new TPos2(XY));
                                }
                            }
                            #endregion
                            break;
                    }
                    return _Lines;
                }
            }
        }
        public static bool DoFillPat(TLine Line, ERunMode RunMode, double f_origin_x, double f_origin_y, double f_origin_z)
        {
            string EMsg = "DoFill_Pat";
            int t = 0;

            GDefine.Status = EStatus.Busy;

            try
            {
                bool b_Head2IsValid = false;
                bool b_SyncHead2 = false;
                bool[] b_HeadRun = new bool[2] { false, false };
                if (!SelectHead(Line, ref b_HeadRun, ref b_Head2IsValid, ref b_SyncHead2)) goto _End;

                TModelPara Model = new TModelPara(ModelList, Line.IPara[0]);
                bool Disp = (Line.IPara[2] > 0);

                TFillPat FillPat = new TFillPat(Line);
                List<TPos2> RelPos = FillPat.RelPos;

                #region Set Pump Para
                switch (RunMode)
                {
                    case ERunMode.Normal:
                        #region
                        double VolToDispA_ul = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj;
                        double VolToDispB_ul = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj;

                        if (rt_Head1VolumeOfst != 0)
                        {
                            VolToDispA_ul = VolToDispA_ul + rt_Head1VolumeOfst;
                        }
                        if (rt_Head2VolumeOfst != 0)
                        {
                            VolToDispB_ul = VolToDispB_ul + rt_Head2VolumeOfst;
                        }
                        if (Model.DispVol > 0)
                        {
                            VolToDispA_ul = Model.DispVol;
                            VolToDispB_ul = Model.DispVol;
                        }

                        if (Disp)
                        {
                            switch (Pump_Type)
                            {
                                case TaskDisp.EPumpType.PP:
                                case TaskDisp.EPumpType.PP2D:
                                case TaskDisp.EPumpType.PPD:
                                    //if (!TaskDisp.Thread_SetDispVolume_Run(b_HeadRun[0], b_HeadRun[1], VolToDispA_ul, VolToDispB_ul)) goto _Stop;
                                    if (VolToDispA_ul != progDispVol[0] || VolToDispB_ul != progDispVol[1])
                                    {
                                        if (!TaskDisp.SetDispVolume(b_HeadRun[0], b_HeadRun[1], VolToDispA_ul, VolToDispB_ul))
                                        {
                                            Msg MsgBox = new Msg();
                                            MsgBox.Show(ErrCode.DISPCTRL1_COMM_ERR, "SetDispVolume ");
                                            goto _Stop;
                                        }
                                        if (b_HeadRun[0]) progDispVol[0] = VolToDispA_ul;
                                        if (b_HeadRun[1]) progDispVol[1] = VolToDispB_ul;
                                    }
                                    break;
                                case TaskDisp.EPumpType.Vermes:
                                    for (int i = 0; i < 2; i++)
                                    {
                                        if (TaskDisp.Vermes3200[i].IsOpen)
                                        {
                                            if (TaskDisp.Vermes3200[i].Param.NP != 0)
                                            {
                                                TaskDisp.Vermes3200[i].Param.NP = 0;
                                                TaskDisp.Vermes3200[i].Set();
                                            }
                                        }
                                    }
                                    break;
                                case TaskDisp.EPumpType.Vermes1560:
                                    for (int i = 0; i < 2; i++)
                                    {
                                        if (TaskDisp.Vermes1560[i].IsOpen)
                                        {
                                            if (TaskDisp.Vermes1560[i].NP[0] != 0)
                                            {
                                                TaskDisp.Vermes1560[i].NP[0] = 0;
                                                TaskDisp.Vermes1560[i].UpdateSetup();
                                            }
                                        }
                                    }
                                    break;
                            }
                        }
                        #endregion
                        break;
                    case ERunMode.Camera:
                    case ERunMode.Dry:
                        break;
                }
                #endregion

                #region Move GZ2 Up if invalid
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2 && !b_Head2IsValid)
                {
                    switch (RunMode)
                    {
                        case ERunMode.Normal:
                        case ERunMode.Dry:
                            if (!TaskDisp.TaskMoveGZ2Up()) return false;
                            break;
                    }
                }
                #endregion

                #region assign and translate position
                double dx = f_origin_x + rt_LayoutRelPos[RunTime.UIndex].X + FillPat.StartPos.X;
                double dy = f_origin_y + rt_LayoutRelPos[RunTime.UIndex].Y + FillPat.StartPos.Y;
                TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);

                double dx2 = f_origin_x + rt_LayoutRelPos[RunTime.UIndex2].X + FillPat.StartPos.X;
                double dy2 = f_origin_y + rt_LayoutRelPos[RunTime.UIndex2].Y + FillPat.StartPos.Y;
                TranslatePos(dx2, dy2, rt_Head2RefData, ref dx2, ref dy2);

                double X1 = dx;
                double Y1 = dy;
                double X2 = dx2;
                double Y2 = dy2;
                #endregion

                double X2_Ofst = X2 - X1;
                double Y2_Ofst = Y2 - Y1;

                TPos2 GXY = new TPos2(X1, Y1);
                TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                #region Set XY Pos
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                        {
                            if (!b_SyncHead2)
                            {
                                if (b_HeadRun[0])//(HeadNo == EHeadNo.Head1)
                                {
                                    GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                    GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;
                                }
                                if (b_HeadRun[1])//(HeadNo == EHeadNo.Head2)
                                {
                                    GXY.X = GXY.X + TaskDisp.Head_Ofst[1].X;
                                    GXY.Y = GXY.Y + TaskDisp.Head_Ofst[1].Y;
                                }
                            }
                            else
                            {
                                GXY.X = GXY.X + TaskDisp.Head_Ofst[0].X;
                                GXY.Y = GXY.Y + TaskDisp.Head_Ofst[0].Y;

                                GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + X2_Ofst + TaskDisp.Head2_XOffset;
                                GX2Y2.Y = GX2Y2.Y + Y2_Ofst + TaskDisp.Head2_YOffset; ;
                            }
                            break;
                        }
                    case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }
                #endregion

                #region Move XY Pos
                if (!TaskGantry.SetMotionParamGXY()) goto _Error;
                if (!TaskGantry.MoveAbsGXY(GXY.X, GXY.Y, false)) goto _Error;
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                {
                    if (b_HeadRun[1])
                    {
                        if (!TaskGantry.SetMotionParamGX2Y2()) goto _Error;
                        if (!TaskGantry.MoveAbsGX2Y2(GX2Y2.X, GX2Y2.Y, false)) goto _Error;
                    }
                }
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XY_ZX2Y2_Z2)
                    TaskGantry.WaitGX2Y2();
                TaskGantry.WaitGXY();
                #endregion

                double Z1 = 0;
                double Z2 = 0;

                #region Assign Z positions
                double dz = f_origin_z;
                dz = dz + TaskDisp.Head_Ofst[0].Z;
                double ZDiff = (TaskDisp.Head_ZSensor_RefPosZ[1] + TaskDisp.Head_Ofst[1].Z - (TaskDisp.Head_ZSensor_RefPosZ[0] + TaskDisp.Head_Ofst[0].Z));
                double dz2 = dz + ZDiff;
                Z1 = dz;
                Z2 = dz2;
                #endregion
                #region Update Z Offset
                Z1 = Z1 + TaskDisp.Z1Offset;
                Z2 = Z2 + TaskDisp.Z2Offset + TaskDisp.Head2_ZOffset;
                #endregion

                #region If ZPlane Valid, Update Z Values
                double LX1 = GXY.X - TaskDisp.Head_Ofst[0].X;
                double LY1 = GXY.Y - TaskDisp.Head_Ofst[0].Y;
                double LX2 = LX1 + (X2 - X1);
                double LY2 = LY1 + (Y2 - Y1);
                UpdateZHeight(b_SyncHead2, LX1, LY1, LX2, LY2, ref Z1, ref Z2);
                #endregion

                double Z1RetGapPos = Z1 + Model.DispGap + Model.RetGap;
                if (Z1RetGapPos > TaskDisp.ZDefPos) Z1RetGapPos = TaskDisp.ZDefPos;
                double Z2RetGapPos = Z2 + Model.DispGap + Model.RetGap;
                if (Z2RetGapPos > TaskDisp.ZDefPos) Z2RetGapPos = TaskDisp.ZDefPos;

                #region Move First Gap
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                        {
                            //move to First Gap
                            double d1 = Math.Round(TaskGantry.GZPos(), 4);
                            double d2 = Math.Round(TaskGantry.GZ2Pos(), 4);
                            double d1T = Math.Round(Z1RetGapPos, 4);
                            double d2T = Math.Round(Z2RetGapPos, 4);
                            if ((b_HeadRun[0] && ((d1 < d1T - 0.001) || (d1 > d1T + 0.001))) || (b_HeadRun[1] && ((d2 < d2T - 0.001) || (d2 > d2T + 0.001))))
                            {
                                if (!TaskGantry.SetMotionParamGZZ2(Model.DnStartV, Model.DnSpeed, Model.DnAccel)) return false;
                                if (!MoveZAbs(b_HeadRun[0], b_HeadRun[1], d1T, d2T)) return false;

                                #region First Gap Wait
                                t = GDefine.GetTickCount() + Model.FirstGapWait;
                                while (GDefine.GetTickCount() < t) { }
                                { Thread.Sleep(1); }
                                #endregion
                            }
                            break;
                        }
                    case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }
                #endregion

                #region move z to DispGap
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                        {

                            double sv = Model.DnStartV;
                            double dv = Model.DnSpeed;
                            double ac = Model.DnAccel;
                            if (!TaskGantry.SetMotionParamGZZ2(sv, dv, ac)) goto _Stop;
                            if (!MoveZAbs(b_HeadRun[0], b_HeadRun[1], Z1 + Model.DispGap, Z2 + Model.DispGap)) return false;


                            break;
                        }
                    case ERunMode.Camera:
                    default:
                        {
                            break;
                        }
                }
                #endregion

                int t_Log = GDefine.GetTickCount();

                double[] RelDummyPos = new double[4] { 0, 0, 0, 0 };
                CControl2.TAxis[] Axis = new CControl2.TAxis[] { TaskGantry.GXAxis, TaskGantry.GYAxis, TaskGantry.GZAxis, TaskGantry.GZ2Axis };
                CommonControl.P1245.PathFree(Axis);
                CommonControl.P1245.SetAccel(Axis, Model.DnAccel);

                #region Set Paths REL Operation
                CControl2.TOutput[] Output = null;
                Outputs(b_HeadRun, ref Output);
                CControl2.TOutput[] VacOutput = null;
                Vac_Outputs(b_HeadRun, ref VacOutput);

                if (RunMode == ERunMode.Normal || RunMode == ERunMode.Dry)
                {
                    double[] RelDispDist = new double[4] { 0, 0, 0, 0 };
                    if (b_HeadRun[0]) RelDispDist[2] = -Model.RetGap;
                    if (b_HeadRun[1]) RelDispDist[3] = -Model.RetGap;
                }
                if (Model.DnWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.DnWait, 0, null, null);

                switch (Pump_Type)
                {
                    case TaskDisp.EPumpType.TP:
                    case TaskDisp.EPumpType.TPRV:
                        CommonControl.P1245.PathAddDO(Axis, VacOutput, false);
                        break;
                    case TaskDisp.EPumpType.SP:
                        if (RunMode == ERunMode.Normal && Disp) TaskDisp.SP.SP_AddOnPaths(Axis);
                        break;
                    default:
                        CommonControl.P1245.PathAddDO(Axis, Output, RunMode == ERunMode.Normal && Disp);
                        break;
                }

                if (Model.StartDelay > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.StartDelay, 0, null, null);

                int Points = Line.IPara[5];
                double LineSpeed = Model.LineSpeed;
                for (int j = 0; j < RelPos.Count; j++)
                {
                    //int Dots = (int)Line.U[j];
                    double Rel_X = RelPos[j].X;
                    double Rel_Y = RelPos[j].Y;
                    double Rel_X_X2 = Rel_X;
                    double Rel_X_Y2 = Rel_Y;
                    if (j < RelPos.Count - 1)
                    {
                        Rel_X_X2 += RelPos[j + 1].X;
                        Rel_X_Y2 += RelPos[j + 1].Y;
                    }

                    //if (Pump_Type == TaskDisp.EPumpType.Vermes && Dots > 0)
                    //{
                    //    double Dist = Math.Sqrt(Math.Pow(Rel_X, 2) + Math.Pow(Rel_Y, 2));
                    //    double TravelTime = VermesInterval * Dots;
                    //    double MaxLineSpeed = Dist / (TravelTime / 1000);
                    //    if (Model.LineSpeedAct == 0) LineSpeed = MaxLineSpeed;

                    //    if (LineSpeed > MaxLineSpeed)
                    //    {
                    //        //Msg MsgBox = new Msg();
                    //        //MsgBox.Show("Line Speed Exceed Jetter Max " + MaxLineSpeed.ToString("f3") + " mm/s.");
                    //        //goto _Stop;
                    //    }
                    //}

                    switch (FillPat.Type)
                    {
                        default:
                            CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, LineSpeed, 0, new double[4] { Rel_X, Rel_Y, 0, 0 }, new double[4] { Rel_X, Rel_Y, 0, 0 });
                            break;
                        case EFillPatType.SpiralCurve:
                        case EFillPatType.SpiralCurve3:
                            {
                                if (j % 2 == 1) continue;
                                TCirc Circ = new TCirc(new TPos2(0, 0), new TPos2(Rel_X, Rel_Y), new TPos2(Rel_X_X2, Rel_X_Y2));
                                CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DHelixCW, false, LineSpeed, 0, new double[4] { Circ.End.X, Circ.End.Y, 0, 0 }, new double[4] { Circ.Center.X, Circ.Center.Y, 0, 0 });
                                break;
                            }
                        case EFillPatType.SpiralCurve2:
                            {
                                if (j % 9 >= 8)
                                {
                                    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, LineSpeed, 0, new double[4] { Rel_X, Rel_Y, 0, 0 }, new double[4] { Rel_X, Rel_Y, 0, 0 });
                                }
                                else
                                {
                                    int Loop = j / 9;
                                    if (Loop % 2 == 0)
                                    {
                                        if (j % 2 == 1) continue;
                                    }
                                    else
                                        if (j % 2 == 0) continue;

                                    TCirc Circ = new TCirc(new TPos2(0, 0), new TPos2(Rel_X, Rel_Y), new TPos2(Rel_X_X2, Rel_X_Y2));
                                    CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DHelixCW, false, LineSpeed, 0, new double[4] { Circ.End.X, Circ.End.Y, 0, 0 }, new double[4] { Circ.Center.X, Circ.Center.Y, 0, 0 });
                                }
                                break;
                            }
                    }
                }

                if (Model.EndDelay > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.EndDelay, 0, null, null);

                switch (Pump_Type)
                {
                    case TaskDisp.EPumpType.TP:
                    case TaskDisp.EPumpType.TPRV:
                        CommonControl.P1245.PathAddDO(Axis, VacOutput, true);
                        break;
                    case TaskDisp.EPumpType.SP:
                        TaskDisp.SP.SP_AddOffPaths(Axis);
                        break;
                    default:
                        CommonControl.P1245.PathAddDO(Axis, Output, false);
                        break;
                }

                    if (Model.PostWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.PostWait, 0, null, null);

                if (RunMode == ERunMode.Normal || RunMode == ERunMode.Dry)
                {
                    double[] RelRetDist = new double[4] { 0, 0, 0, 0 };
                    if (b_HeadRun[0]) RelRetDist[2] = Model.RetGap;
                    if (b_HeadRun[1]) RelRetDist[3] = Model.RetGap;
                    if (Model.RetGap > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, Model.RetSpeed, Model.RetStartV, RelRetDist, RelDummyPos);
                    if (Model.RetWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.RetWait, 0, null, null);

                    double[] RelUpGaps = new double[4] { 0, 0, 0, 0 };
                    if (b_HeadRun[0]) RelUpGaps[2] = Model.UpGap;
                    if (b_HeadRun[1]) RelUpGaps[3] = Model.UpGap;
                    if (Model.UpGap > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.Rel4DDirect, false, Model.RetSpeed, Model.UpStartV, RelUpGaps, RelDummyPos);
                    if (Model.UpWait > 0) CommonControl.P1245.PathAddCmd(Axis, CControl2.EPath_MoveCmd.GPDELAY, false, Model.UpWait, 0, null, null);

                }
                #endregion

                #region Wait Pump Para
                switch (RunMode)
                {
                    case ERunMode.Normal:
                        #region
                        if (Disp)
                        {
                            switch (Pump_Type)
                            {
                                case TaskDisp.EPumpType.PP:
                                case TaskDisp.EPumpType.PP2D:
                                case TaskDisp.EPumpType.PPD:
                                    if (!TaskDisp.Thread_SetDispVolume_Wait()) goto _Stop;
                                    break;
                                case TaskDisp.EPumpType.Vermes:
                                    break;
                            }
                        }
                        #endregion
                        break;
                    case ERunMode.Camera:
                    case ERunMode.Dry:
                        break;
                }
                #endregion

                int t2 = GDefine.GetTickCount() - t_Log;

                #region Move Paths
                switch (RunMode)
                {
                    case ERunMode.Normal:
                    case ERunMode.Dry:
                    case ERunMode.Camera:
                        {
                            CommonControl.P1245.PathEnd(Axis);
                            CommonControl.P1245.PathMove(Axis);

                            while (true)
                            {
                                if (!CommonControl.P1245.AxisBusy(Axis)) break;
                            }
                            break;
                        }
                    default:
                        {
                            break;
                        }
                }
                #endregion

                #region ZPanelGap
                //switch (RunMode)
                //{
                //    case ERunMode.Normal:
                //    case ERunMode.Dry:
                //        {
                //            if (Model.PanelGap != 0 && rt_Layouts[rt_LayoutID].LastInCluster(rt_UIndex))
                //            {
                //                #region Move Panel Gap
                //                if (!TaskGantry.SetMotionParamGZZ2()) goto _Stop;

                //                double Z1PanelGap = Z1 + Model.PanelGap;
                //                if (Z1PanelGap > TaskDisp.ZDefPos) Z1PanelGap = TaskDisp.ZDefPos;
                //                double Z2PanelGap = Z2 + Model.PanelGap;
                //                if (Z2PanelGap > TaskDisp.ZDefPos) Z2PanelGap = TaskDisp.ZDefPos;

                //                if (!MoveZAbs(b_HeadRun[0], b_HeadRun[1], Z1PanelGap, Z2PanelGap)) return false;
                //                #endregion
                //            }
                //            break;
                //        }
                //    case ERunMode.Camera:
                //        {
                //            break;
                //        }
                //}
                #endregion
            }
            catch (Exception Ex)
            {
                GDefine.Status = EStatus.ErrorInit;
                TaskDisp.TrigOff(true, true);
                EMsg = EMsg + (char)13 + Ex.Message.ToString();
                throw new Exception(EMsg);
            }
            _End:
            GDefine.Status = EStatus.Ready;
            return true;
            _Stop:
            GDefine.Status = EStatus.Stop;
            return false;
            _Error:
            GDefine.Status = EStatus.ErrorInit;
            return false;
        }


        public static bool SaveHData()
        {
            if (rt_MeasL_HData.Count == 0) return true;

            if (!Directory.Exists(GDefine.DataPath))
                Directory.CreateDirectory(GDefine.DataPath);

            string Filename = GDefine.DataPath + "\\" + DateTime.Now.ToString("yyyyMMdd_HHmm") + ".txt";
            try
            {
                FileStream F = new FileStream(Filename, FileMode.Append, FileAccess.Write, FileShare.Write);
                StreamWriter W = new StreamWriter(F);

                W.WriteLine("MEASL_WH DATA");
                W.WriteLine("********************");

                int i = 1;
                foreach (double d in rt_MeasL_HData)
                {
                    W.WriteLine(i.ToString() + (char)9 + d.ToString("F3"));
                    i++;
                }
                W.WriteLine("********************");
                NSW.Net.Stats Stats = new NSW.Net.Stats();
                W.WriteLine("StDev" + (char)9 + Stats.StDev(rt_MeasL_HData).ToString("F3"));
                W.WriteLine("Min" + (char)9 + rt_MeasL_HData.Min().ToString("F3"));
                W.WriteLine("Max" + (char)9 + rt_MeasL_HData.Max().ToString("F3"));
                W.WriteLine("Max-Min" + (char)9 + (rt_MeasL_HData.Max() - rt_MeasL_HData.Min()).ToString("F3"));
                W.WriteLine("Ave" + (char)9 + rt_MeasL_HData.Average().ToString("F3"));
                W.Close();
            }
            catch
            {
            }
            return true;
        }

        public static bool SetDotsVol()
        {
            //count dots
            int iDotCount = 0;
            //for (int i = DispProg.LastLine; i < DispProg.Script[0].CmdList.Line.Count(); i++)
            for (int i = DispProg.LastLine; i < DispProg.Script[0].CmdList.Count; i++)
            {
                TLine Line = Script[0].CmdList.Line[i];
                if (Line.Cmd == ECmd.DOT)
                {
                    iDotCount++;
                }
            }

            if (iDotCount == 0) return true;

            switch (DispProg.Pump_Type)
            {
                case TaskDisp.EPumpType.PP:
                case TaskDisp.EPumpType.PP2D:
                case TaskDisp.EPumpType.PPD:
                    {
                        if (TaskWeight.CurrentCal[0] <= 0 || TaskWeight.CurrentCal[1] <= 0)
                        {
                            throw new Exception("Weight Not Calibrated.");
                        }

                        try
                        {
                            double dTotalVolA = DispProg.Disp_Weight[0] / TaskWeight.CurrentCal[0];
                            double dVolA = dTotalVolA / iDotCount;
                            DispProg.PP_HeadA_DispBaseVol = dVolA + DispProg.PP_HeadA_BackSuckVol;

                            double dTotalVolB = DispProg.Disp_Weight[1] / TaskWeight.CurrentCal[1];
                            double dVolB = dTotalVolB / iDotCount;
                            DispProg.PP_HeadB_DispBaseVol = dVolB + DispProg.PP_HeadB_BackSuckVol;
                        }
                        catch (Exception ex)
                        {
                            throw;
                        }
                        break;
                    }
            }
            return true;
        }

        private static bool CalcPatternTotalDistTime(ref double Dist_mm, ref double Time_s)
        {
            double d_TotalDist_mm = 0;
            double d_TDelayTime_ms = 0;

            double LastX = 0;
            double LastY = 0;
            for (int i = DispProg.LastLine; i < DispProg.Script[0].CmdList.Count - 1; i++)
            {
                TLine Line = Script[0].CmdList.Line[i];
                TLine Line_Prev = Script[0].CmdList.Line[i - 1];
                TLine Line_Next = Script[0].CmdList.Line[i + 1];

                switch (Line.Cmd)
                {
                    case ECmd.MOVE:
                        LastX = Line.X[0];
                        LastY = Line.Y[0];
                        break;
                    case ECmd.LINE:
                        {
                            if (Line.IPara[2] > 0)
                            {
                                double distX = Line.X[0] - LastX;
                                double distY = Line.Y[0] - LastY;
                                d_TotalDist_mm = d_TotalDist_mm + Math.Sqrt(Math.Pow(distX, 2) + Math.Pow(distY, 2));
                            }
                            LastX = Line.X[0];
                            LastY = Line.Y[0];
                            break;
                        }
                    case ECmd.CIRC:
                        if (Line.IPara[2] > 0)
                        {
                            double cx = 0;
                            double cy = 0;
                            double rad = 0;
                            if (!GDefine.Arc3PGetInfo(LastX, LastY, Line.X[0], Line.Y[0], Line.X[1], Line.Y[1], ref cx, ref cy, ref rad)) return false;
                            d_TotalDist_mm = d_TotalDist_mm + (2 * Math.PI * rad);
                        }
                        break;
                    case ECmd.ARC:
                        if (Line.IPara[2] > 0)
                        {
                            double cx = 0;
                            double cy = 0;
                            double rad = 0;
                            double ps = 0;
                            double pe = 0;
                            double sa = 0;
                            double dir = 0;
                            if (!GDefine.Arc3PGetInfo(LastX, LastY, Line.X[0], Line.Y[0], Line.X[1], Line.Y[1], ref cx, ref cy, ref rad, ref ps, ref pe, ref sa, ref dir)) return false;
                            d_TotalDist_mm = d_TotalDist_mm + (Math.PI * rad);
                        }
                        LastX = Line.X[1];
                        LastY = Line.Y[1];
                        break;
                }
                if (Line.Cmd == ECmd.LINE || Line.Cmd == ECmd.ARC || Line.Cmd == ECmd.CIRC)
                {
                    //first of pattern
                    if (Line_Prev.Cmd == ECmd.MOVE)
                        if (Line.IPara[2] > 0)
                            d_TDelayTime_ms = d_TDelayTime_ms + ModelList.Model[Line.IPara[0]].Para[(int)TModelList.EModel.StartDelay];

                    //last for pattern
                    if (!(Line_Next.Cmd == ECmd.LINE || Line_Next.Cmd == ECmd.CIRC || Line_Next.Cmd == ECmd.ARC))
                        if (Line.IPara[2] > 0)
                            d_TDelayTime_ms = d_TDelayTime_ms + ModelList.Model[Line.IPara[0]].Para[(int)TModelList.EModel.EndDelay];
                }
            }

            Dist_mm = d_TotalDist_mm;
            Time_s = d_TDelayTime_ms / 1000;
            return true;
        }
        public static bool SetPatternSpeed()
        {
            if (RunMode == ERunMode.Camera) return true;

            //count
            int i_DotCount = 0;//count Dots
            int i_DrawCount = 0;//count Line, Arc and Circ

            for (int i = DispProg.LastLine; i < DispProg.Script[0].CmdList.Count; i++)
            //for (int i = 0; i < DispProg.LastLine; i++)
            {
                TLine Line = Script[0].CmdList.Line[i];
                if (Line.Cmd == ECmd.DOT) i_DotCount++;
                if (Line.Cmd == ECmd.LINE || Line.Cmd == ECmd.ARC || Line.Cmd == ECmd.CIRC) i_DrawCount++;
            }

            if (i_DotCount > 0 && i_DrawCount > 0)
            {
                throw new Exception("Dots and Pattern exist. Remove Dot from program.");
            }

            if (i_DrawCount == 0) return true;//nothing to adjust.

            switch (DispProg.Pump_Type)
            {
                case TaskDisp.EPumpType.PP:
                case TaskDisp.EPumpType.PP2D:
                case TaskDisp.EPumpType.PPD:
                    int a = TaskDisp.HPC_15[0].Param.Disp_AC[0, 0];
                    TaskDisp.HPC_15[0].Param.Disp_DC[0, 0] = a;
                    TaskDisp.HPC_15[0].UploadToCtrl();
                    break;
                default:
                    throw new Exception("Pump Type not supported.");
            }

            double d_DispTime_s = 0;
            TaskDisp.PP_CalcDispTime(ref d_DispTime_s);

            double d_MoveDist = 0;
            double d_DelayTime_s = 0;
            if (!CalcPatternTotalDistTime(ref d_MoveDist, ref d_DelayTime_s)) throw new Exception("CalcPatternTotalDistTime Error");

            //DelayTime is more than DispTime, no speed adjust
            if (d_DelayTime_s - d_DispTime_s > 0) return true;

            double d_MoveTime = d_DispTime_s - d_DelayTime_s;
            double d_LineSpeed = d_MoveDist / d_MoveTime;

            const double MIN_SPEED = 1;
            const double MAX_SPEED = 50;

            if (d_LineSpeed < MIN_SPEED) throw new Exception("Line Speed is below minimum of 2mm/s");
            if (d_LineSpeed > MAX_SPEED) throw new Exception("Line Speed is above maximum of 50mm/s");

            ModelList.Model[0].Para[(int)TModelList.EModel.LineSpeed] = d_LineSpeed;

            return true;
        }

        public static bool VolumeMap(TLine Line)
        {
            int PtCount = Line.IPara[2];
            EVMMethod Method = (EVMMethod)Line.IPara[0];
            for (int i = 0; i < 256; i++)
            {
                rt_VolumeMap.RefType = (EVMCntrType)Line.IPara[1];
                rt_VolumeMap.AdjType = (EVMAdjType)Line.IPara[3];
            }

            switch (Method)
            {
                case EVMMethod.Rate:
                    for (int i = 0; i < TVolumeMap.MAX_MAP; i++)
                    {
                        int M = i / Line.Index[0];
                        rt_VolumeMap.Value[i] = Line.X[0] * M;
                    }
                    break;
                case EVMMethod.Trend:
                    int Index = 0;
                    //fill initial values
                    for (int i = 0; i < Line.Index[0] - 1; i++)
                    {
                        rt_VolumeMap.Value[i] = 0;
                        Index++;
                    }
                    for (int i = 0; i < 100; i++)
                    {
                        //fill final values
                        if (i == PtCount - 1)
                        {
                            for (int j = Index; j < TVolumeMap.MAX_MAP; j++)
                            {
                                rt_VolumeMap.Value[j] = Line.X[i];
                            }
                            break;
                        }
                        else//fill intermediate values
                        {
                            for (int j = Index; j < Line.Index[i + 1] - 1; j++)
                            {
                                rt_VolumeMap.Value[j] = Line.X[i];
                                Index++;
                            }
                        }
                    }
                    break;
            }
            return true;
        }

        public static void GetVolumeMapOffset(ref double OfstA, ref double OfstB)
        {
            double HeadVolumeMap = 0;

            if (rt_VolumeMap.RefType == EVMCntrType.Frame)
            {
                int i_Frame = Stats.BoardCount;
                i_Frame = Math.Min(i_Frame, TVolumeMap.MAX_MAP - 1);
                HeadVolumeMap = rt_VolumeMap.Value[i_Frame];
            }
            if (rt_VolumeMap.RefType == EVMCntrType.Time)
            {
                int t_Elapse = (GDefine.GetTickCount() - Stats.StartTime) / 60000;
                t_Elapse = Math.Min(t_Elapse, TVolumeMap.MAX_MAP - 1);
                HeadVolumeMap = rt_VolumeMap.Value[t_Elapse];
            }

            if (rt_VolumeMap.AdjType == EVMAdjType.Pcnt)
            {
                double VolToDispA_ul = DispProg.PP_HeadA_DispBaseVol + DispProg.PP_HeadA_DispVol_Adj;
                double VolToDispB_ul = DispProg.PP_HeadB_DispBaseVol + DispProg.PP_HeadB_DispVol_Adj;
                OfstA = VolToDispA_ul * (HeadVolumeMap / 100);
                OfstB = VolToDispB_ul * (HeadVolumeMap / 100);
            }
            if (rt_VolumeMap.AdjType == EVMAdjType.Value)
            {
                OfstA = HeadVolumeMap;
                OfstB = HeadVolumeMap;
            }
        }
        public static void ClearVolumeOffset()
        {
            rt_Head1VolumeOfst = 0;
            rt_Head2VolumeOfst = 0;

            if (TaskDisp.VolumeOfst_Protocol == TaskDisp.EVolumeOfstProtocol.Lextar_FrontTestCloseLoop)
            {
                PP_HeadA_DispVol_Adj = 0;
                PP_HeadB_DispVol_Adj = 0;
            }
        }

        public static int DoVolumeOfst_FileCount()
        {
            switch (TaskDisp.VolumeOfst_Protocol)
            {
                default:
                    return -1;
                case TaskDisp.EVolumeOfstProtocol.AOT_HeightCloseLoop:
                    NDispWin.AOT_HeightCloseLoop.Path = TaskDisp.VolumeOfst_DataPath;
                    return NDispWin.AOT_HeightCloseLoop.Count();
                case TaskDisp.EVolumeOfstProtocol.AOT_FrontTestCloseLoop:
                    NDispWin.AOT_FrontTestCloseLoop.EquipmentID = TaskDisp.VolumeOfst_EqID;
                    NDispWin.AOT_FrontTestCloseLoop.LocalPath = TaskDisp.VolumeOfst_LocalPath;
                    NDispWin.AOT_FrontTestCloseLoop.DataFilePath = TaskDisp.VolumeOfst_DataPath;
                    NDispWin.AOT_FrontTestCloseLoop.CompFilePath = TaskDisp.VolumeOfst_DataPath2;
                    return NDispWin.AOT_FrontTestCloseLoop.Count();
                case TaskDisp.EVolumeOfstProtocol.Lextar_FrontTestCloseLoop:
                    NDispWin.Lextar_FrontTestCloseLoop.EquipmentID = TaskDisp.VolumeOfst_EqID;
                    NDispWin.Lextar_FrontTestCloseLoop.LocalPath = TaskDisp.VolumeOfst_LocalPath;
                    NDispWin.Lextar_FrontTestCloseLoop.DataFilePath = TaskDisp.VolumeOfst_DataPath;
                    NDispWin.Lextar_FrontTestCloseLoop.DataFilePath2 = TaskDisp.VolumeOfst_DataPath2;
                    return NDispWin.Lextar_FrontTestCloseLoop.Count();
            }
        }
        public static bool DoVolumeOfst(ref double Ofst1, ref double Ofst2, bool Prompt)
        {
            switch (TaskDisp.VolumeOfst_Protocol)
            {
                case TaskDisp.EVolumeOfstProtocol.AOT_HeightCloseLoop:
                    #region
                    {
                        string Path = TaskDisp.VolumeOfst_DataPath;
                        if (Path.Length == 0 || !System.IO.Directory.Exists(Path))
                        {
                            Msg MsgBox = new Msg();
                            EMsgRes MsgRes = MsgBox.Show(ErrCode.VOLUME_OFST_PATH_NOT_FOUND, EMcState.Error, EMsgBtn.smbOK_Stop, false);
                            if (MsgRes == EMsgRes.smrOK)
                            {
                                return true;
                            }
                            if (MsgRes == EMsgRes.smrStop)
                            {
                                return false;
                            }
                        }

                        NDispWin.AOT_HeightCloseLoop.Path = Path;
                        string FileTag = "";
                        string Eq_ID = "";
                        NDispWin.AOT_HeightCloseLoop.DecodeFile(ref FileTag, ref Eq_ID, ref Ofst1, ref Ofst2);

                        if (Ofst1 != 0)
                        {
                            rt_Head1VolumeOfst = rt_Head1VolumeOfst + Ofst1;
                            Ofst1 = 0;
                        }
                        if (Ofst2 != 0)
                        {
                            rt_Head2VolumeOfst = rt_Head2VolumeOfst + Ofst2;
                            Ofst2 = 0;
                        }

                        NDispWin.AOT_HeightCloseLoop.DeleteFiles();
                        break;
                    }
                #endregion
                case TaskDisp.EVolumeOfstProtocol.AOT_FrontTestCloseLoop:
                    #region
                    {
                        if (!System.IO.Directory.Exists(TaskDisp.VolumeOfst_LocalPath) ||
                            !System.IO.Directory.Exists(TaskDisp.VolumeOfst_DataPath) ||
                            !System.IO.Directory.Exists(TaskDisp.VolumeOfst_DataPath2)
                            )
                        {
                            Msg MsgBox = new Msg();
                            EMsgRes MsgRes = MsgBox.Show(ErrCode.VOLUME_OFST_PATH_NOT_FOUND, EMcState.Notice, EMsgBtn.smbOK_Stop, false);
                            if (MsgRes == EMsgRes.smrOK)
                            {
                                return true;
                            }
                            if (MsgRes == EMsgRes.smrStop)
                            {
                                return false;
                            }
                        }
                        NDispWin.AOT_FrontTestCloseLoop.EquipmentID = TaskDisp.VolumeOfst_EqID;
                        NDispWin.AOT_FrontTestCloseLoop.LocalPath = TaskDisp.VolumeOfst_LocalPath;
                        NDispWin.AOT_FrontTestCloseLoop.DataFilePath = TaskDisp.VolumeOfst_DataPath;
                        NDispWin.AOT_FrontTestCloseLoop.CompFilePath = TaskDisp.VolumeOfst_DataPath2;

                        NDispWin.AOT_FrontTestCloseLoop.DecodeDataFile(ref Ofst1, ref Ofst2);

                        if (Ofst1 != 0)
                        {
                            rt_Head1VolumeOfst = rt_Head1VolumeOfst + Ofst1;
                            Ofst1 = 0;
                        }
                        if (Ofst2 != 0)
                        {
                            rt_Head2VolumeOfst = rt_Head2VolumeOfst + Ofst2;
                            Ofst2 = 0;
                        }
                        break;
                    }
                #endregion
                case TaskDisp.EVolumeOfstProtocol.Lextar_FrontTestCloseLoop:
                    #region
                    {
                        if (!System.IO.Directory.Exists(TaskDisp.VolumeOfst_LocalPath) ||
                            !System.IO.Directory.Exists(TaskDisp.VolumeOfst_DataPath)
                            )
                        {
                            Msg MsgBox = new Msg();
                            EMsgRes MsgRes = MsgBox.Show(ErrCode.VOLUME_OFST_PATH_NOT_FOUND, EMcState.Notice, EMsgBtn.smbOK_Stop, false);
                            if (MsgRes == EMsgRes.smrOK)
                            {
                                return true;
                            }
                            if (MsgRes == EMsgRes.smrStop)
                            {
                                return false;
                            }
                        }
                        NDispWin.Lextar_FrontTestCloseLoop.EquipmentID = TaskDisp.VolumeOfst_EqID;
                        NDispWin.Lextar_FrontTestCloseLoop.LocalPath = TaskDisp.VolumeOfst_LocalPath;
                        NDispWin.Lextar_FrontTestCloseLoop.DataFilePath = TaskDisp.VolumeOfst_DataPath;
                        NDispWin.Lextar_FrontTestCloseLoop.DataFilePath2 = TaskDisp.VolumeOfst_DataPath2;

                        bool OK = NDispWin.Lextar_FrontTestCloseLoop.DecodeDataFile(ref Ofst1, ref Ofst2, Prompt);

                        if (Ofst1 != 0)
                        {
                            rt_Head1VolumeOfst = rt_Head1VolumeOfst + Ofst1;
                        }
                        if (Ofst2 != 0)
                        {
                            rt_Head2VolumeOfst = rt_Head2VolumeOfst + Ofst2;
                        }

                        return OK;
                        //break;
                    }
                    #endregion
            }
            return true;
        }
        public static bool DoVolumeOfst(ref double Ofst1, ref double Ofst2)
        {
            return DoVolumeOfst(ref Ofst1, ref Ofst2, true);
        }

        public static void DoVolumeOfst_Purge()
        {
            try
            {
                switch (TaskDisp.VolumeOfst_Protocol)
                {
                    case TaskDisp.EVolumeOfstProtocol.AOT_HeightCloseLoop:
                        NDispWin.AOT_HeightCloseLoop.Path = TaskDisp.VolumeOfst_DataPath;
                        NDispWin.AOT_HeightCloseLoop.PurgeFiles();
                        break;
                    case TaskDisp.EVolumeOfstProtocol.AOT_FrontTestCloseLoop:
                        {
                            NDispWin.AOT_FrontTestCloseLoop.EquipmentID = TaskDisp.VolumeOfst_EqID;
                            NDispWin.AOT_FrontTestCloseLoop.LocalPath = TaskDisp.VolumeOfst_LocalPath;
                            NDispWin.AOT_FrontTestCloseLoop.DataFilePath = TaskDisp.VolumeOfst_DataPath;
                            NDispWin.AOT_FrontTestCloseLoop.CompFilePath = TaskDisp.VolumeOfst_DataPath2;

                            int Count = 0;
                            NDispWin.AOT_FrontTestCloseLoop.PurgeDataFiles(ref Count);
                            break;
                        }
                    case TaskDisp.EVolumeOfstProtocol.Lextar_FrontTestCloseLoop:
                        {
                            NDispWin.Lextar_FrontTestCloseLoop.EquipmentID = TaskDisp.VolumeOfst_EqID;
                            NDispWin.Lextar_FrontTestCloseLoop.LocalPath = TaskDisp.VolumeOfst_LocalPath;
                            NDispWin.Lextar_FrontTestCloseLoop.DataFilePath = TaskDisp.VolumeOfst_DataPath;
                            NDispWin.Lextar_FrontTestCloseLoop.DataFilePath2 = TaskDisp.VolumeOfst_DataPath2;

                            int Count = 0;
                            NDispWin.Lextar_FrontTestCloseLoop.PurgeDataFiles(ref Count);
                            break;
                        }
                }
            }
            catch
            {
            }
        }
        public static void DoVolumeOfst_ShowInfo()
        {
            try
            {
                switch (TaskDisp.VolumeOfst_Protocol)
                {
                    case TaskDisp.EVolumeOfstProtocol.AOT_HeightCloseLoop:
                        break;
                    case TaskDisp.EVolumeOfstProtocol.AOT_FrontTestCloseLoop:
                        NDispWin.AOT_FrontTestCloseLoop.ShowInfo();
                        break;
                    case TaskDisp.EVolumeOfstProtocol.Lextar_FrontTestCloseLoop:
                        NDispWin.Lextar_FrontTestCloseLoop.ShowInfo();
                        break;
                }
            }
            catch
            {
            }
        }

        private static void GetNextPos(int indexC, int indexR, int LoopDir, ref int IndexX, ref int IndexY)
        {
            switch (LoopDir)
            {
                #region
                case 1://YF ZPath
                    if (IndexY >= indexR - 1)
                    {
                        IndexX++;
                        IndexY = 0;
                    }
                    else
                    {
                        IndexY++;
                    }
                    break;
                case 2://XF UPath
                    if (IndexY % 2 == 0)
                    {
                        if (IndexX >= indexC - 1)
                        {
                            IndexY++;
                        }
                        else
                        {
                            IndexX++;
                        }
                    }
                    else
                    {
                        if (IndexX <= 0)
                        {
                            IndexY++;
                        }
                        else
                        {
                            IndexX--;
                        }
                    }
                    break;
                case 3://YF UPath
                    if (IndexX % 2 == 0)
                    {
                        if (IndexY >= indexR - 1)
                        {
                            IndexX++;
                        }
                        else
                        {
                            IndexY++;
                        }
                    }
                    else
                    {
                        if (IndexY <= 0)
                        {
                            IndexX++;
                        }
                        else
                        {
                            IndexY--;
                        }
                    }
                    break;
                case 0:
                default://XF ZPath
                    if (IndexX >= indexC - 1)
                    {
                        IndexY++;
                        IndexX = 0;
                    }
                    else
                    {
                        IndexX++;
                    }
                    break;
                    #endregion
            }
        }
        public static bool DoBdCapture(TLine Line, int ImageID, double StartX, double StartY, double EndX, double EndY)
        {
            string EMsg = "DoBdCapture";
            GDefine.Status = EStatus.Busy;

            Emgu.CV.Image<Emgu.CV.Structure.Gray, byte>[,] SImg = new Emgu.CV.Image<Emgu.CV.Structure.Gray, byte>[100, 100];
            Emgu.CV.Image<Emgu.CV.Structure.Gray, byte>[] ImgLine = new Emgu.CV.Image<Emgu.CV.Structure.Gray, byte>[100];
            Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> FImg = null;

            int CamID = Line.IPara[1];
            try
            {
                if (TaskVision.BoardImage[ImageID] != null)
                {
                    TaskVision.PrevBoardImage[ImageID] = TaskVision.BoardImage[ImageID].Clone();
                    TaskVision.PrevBoardImage_ID[ImageID]++;
                }

                int rotateAngle = 0;
                switch (Line.IPara[8]) 
                {
                    case 1: rotateAngle = 90; break;
                    case 2: rotateAngle = -90; break;
                }

                double indexDistX = TaskVision.ImgWN[CamID] * TaskVision.DistPerPixelX[CamID];
                double indexDistY = TaskVision.ImgHN[CamID] * TaskVision.DistPerPixelY[CamID];
                if (rotateAngle == 90 || rotateAngle == -90)
                {
                    double temp = indexDistX;
                    indexDistX = indexDistY;
                    indexDistY = temp;
                }

                double distX = Math.Abs(EndX - StartX);
                double distY = Math.Abs(EndY - StartY);
                distX = Math.Round(distX, 3);
                distY = Math.Round(distY, 3);
                int indexC = (int)Math.Ceiling((decimal)((distX + indexDistX) / indexDistX));
                indexC = Math.Max(indexC, 1);
                int indexR = (int)Math.Ceiling((decimal)((distY + indexDistY) / indexDistY));
                indexR = Math.Max(indexR, 1);

                int indexTotal = Math.Abs(indexC * indexR);

                if (EndX - StartX < 0) indexDistX = -indexDistX;
                if (EndY - StartY < 0) indexDistY = -indexDistY;

                int pixX = TaskVision.ImgWN[Line.IPara[CamID]] * indexC;
                int pixY = TaskVision.ImgHN[Line.IPara[CamID]] * indexR;
                //float ImgScale = Math.Min((float)2000 / pixX, (float)2000 / pixY);
                int maxSize = Line.IPara[5] == 0 ? 32768 : Line.IPara[5];
                float imgScale = Math.Min((float)maxSize / pixX, (float)maxSize / pixY);
                imgScale = Math.Min(imgScale, 1);

                if (!TaskDisp.TaskMoveGZFocus(Line.IPara[21])) return false;
                TaskVision.LightingOn(TaskVision.BdCaptureLightRGB);

                #region Set Camera Properties
                if (Line.DPara[5] == 0) Line.DPara[5] = (double)(Line.IPara[5] / 1000);//1.0.42.5 reverse compatibility
                double Exposure = Line.DPara[5];
                double Gain = Line.DPara[6];

                switch (GDefine.CameraType[0])
                {
                    case GDefine.ECameraType.PtGrey:
                        TaskVision.PGCamera[CamID].SetProperty(PtGrey.TCamera.EProperty.Shutter, Exposure);
                        TaskVision.PGCamera[CamID].SetProperty(PtGrey.TCamera.EProperty.Gain, Gain);
                        break;
                    case GDefine.ECameraType.Spinnaker2:
                        TaskVision.flirCamera2[CamID].Exposure = Line.DPara[5] * 1000;
                        TaskVision.flirCamera2[CamID].Gain = Line.DPara[6];
                        break;
                    case GDefine.ECameraType.MVCGenTL:
                        TaskVision.genTLCamera[CamID].Exposure = Line.DPara[5] * 1000;
                        TaskVision.genTLCamera[CamID].Gain = Line.DPara[6];
                        break;
                }

                #endregion

                TPos2 GXY = new TPos2(StartX, StartY);

                if (!TaskGantry.MoveGX2Y2DefPos(true)) goto _Stop;
                if (!TaskGantry.SetMotionParamGXY()) goto _Stop;

                if (!TaskGantry.SetMotionParamGXY()) goto _Stop;
                if (!TaskGantry.MoveAbsGXY(GXY.X, GXY.Y)) goto _Stop;

                int indexX = 0;
                int indexY = 0;
                for (int i = 0; i < indexTotal; i++)
                {
                    #region Capture Index Array
                    double X = StartX + (indexX * indexDistX);
                    double Y = StartY + (indexY * indexDistY);

                    if (!TaskGantry.MoveAbsGXY(X, Y)) goto _Stop; ;

                    int SettleTime = Line.IPara[4];
                    int t1 = GDefine.GetTickCount() + SettleTime;
                    while (GDefine.GetTickCount() <= t1) { Thread.Sleep(1); }

                    //TaskVision.GrabN(CamID, ref SImg[IndexX, IndexY]);

                    switch (GDefine.CameraType[CamID])
                    {
                        case GDefine.ECameraType.Basler:
                        case GDefine.ECameraType.Spinnaker:
                            TaskVision.GrabN(CamID, ref SImg[indexX, indexY]);
                            break;
                        case GDefine.ECameraType.PtGrey:
                            TaskVision.PtGrey_CamStop();
                            TaskVision.PtGrey_CamArm(CamID);
                            TaskVision.PtGrey_CamTrig(CamID);
                            TaskVision.PtGrey_CamImage(CamID, ref SImg[indexX, indexY]);
                            TaskVision.PtGrey_CamLive(CamID);
                            break;
                        case GDefine.ECameraType.Spinnaker2:
                            TaskVision.flirCamera2[CamID].Grab();
                            SImg[indexX, indexY] = TaskVision.flirCamera2[CamID].m_ImageEmgu.m_Image.Clone();
                            break;
                        case GDefine.ECameraType.MVCGenTL:
                            TaskVision.genTLCamera[CamID].GrabOneImage();
                            SImg[indexX, indexY] = TaskVision.genTLCamera[CamID].mImage.Clone();
                            if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[CamID].StartGrab();
                            break;
                    }

                    SImg[indexX, indexY] = SImg[indexX, indexY].Resize(imgScale, Emgu.CV.CvEnum.Inter.Linear);

                    //SImg[indexX, indexY].Save(@"c:\TestMergeS" + indexX.ToString() + "_" + indexY.ToString() + ".bmp");


                    int angle = 0;
                    switch (Line.IPara[8])
                    {
                        default:
                        case 0: angle = 0; break;
                        case 1: angle = 90; break;
                        case 2: angle = -90; break;
                    }
                    SImg[indexX, indexY] = SImg[indexX, indexY].Rotate(angle, new Emgu.CV.Structure.Gray(0), false);

                    GetNextPos(indexC, indexR, Line.IPara[2], ref indexX, ref indexY);
                    #endregion
                }

                #region Merge Image
                for (int y = 0; y < indexR; y++)
                {
                    for (int x = 0; x < indexC; x++)
                    {
                        if (x == 0)
                            ImgLine[y] = SImg[x, y].Copy();
                        else
                        {
                            if (indexDistX < 0)
                                ImgLine[y] = SImg[x, y].ConcateHorizontal(ImgLine[y]);
                            else
                                ImgLine[y] = ImgLine[y].ConcateHorizontal(SImg[x, y]);
                        }
                    }
                    if (y == 0)
                        FImg = ImgLine[y];
                    else
                    {
                        if (GDefine.GantryConfig == GDefine.EGantryConfig.XZ_YTABLE)
                        {
                            if (indexDistY < 0)
                                FImg = ImgLine[y].ConcateVertical(FImg);
                            else
                                FImg = FImg.ConcateVertical(ImgLine[y]);
                        }
                        else
                            if (indexDistY < 0)
                            FImg = FImg.ConcateVertical(ImgLine[y]);
                        else
                            FImg = ImgLine[y].ConcateVertical(FImg);
                    }
                    Thread.Sleep(1);
                }
                #endregion

                TaskVision.BoardImage[ImageID] = FImg.Clone();
                TaskVision.BoardImage_ID[ImageID]++;
            }
            catch (Exception Ex)
            {
                GDefine.Status = EStatus.ErrorInit;
                EMsg = EMsg + (char)13 + Ex.Message.ToString();
                Msg MsgBox = new Msg();
                MsgBox.Show(ErrCode.UNKNOWN_EX_ERR, EMsg);
                return false;
            }
            finally
            {
                for (int i = 0; i < 100; i++)
                {
                    if (ImgLine[i] != null)
                        ImgLine[i].Dispose();
                    for (int j = 0; j < 100; j++)
                        if (SImg[i, j] != null)
                            SImg[i, j].Dispose();
                }
                if (FImg != null)
                    FImg.Dispose();

                switch (GDefine.CameraType[0])
                {
                    case GDefine.ECameraType.MVCGenTL:
                        TaskVision.genTLCamera[CamID].StopGrab();
                        TaskVision.genTLCamera[CamID].Exposure = TaskVision.ExposureTime[CamID] * 1000;
                        TaskVision.genTLCamera[CamID].Gain = TaskVision.Gain[CamID];
                        if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[CamID].StartGrab();
                        break;
                }
            }
            GDefine.Status = EStatus.Ready;
            return true;
        _Stop:
            GDefine.Status = EStatus.Stop;
            return false;
        }

        public static bool DoLineCapture(TLine Line, double StartX, double StartY, double EndX, double EndY)
        {
            string EMsg = "DoLineCapture";
            GDefine.Status = EStatus.Busy;

            int CamNo = Line.IPara[1];
            double ADist = 10;


        //Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> Img_Strip = null;
        List<Emgu.CV.Image<Emgu.CV.Structure.Gray, byte>> imgVertSlices = new List<Emgu.CV.Image<Emgu.CV.Structure.Gray, byte>>();//vertical image slices
        Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> imgVertMerged = null;//merged vertical slices
            Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> imgMerged = null;//final image

            try
            {
                switch (GDefine.CameraType[0])
                {
                    case GDefine.ECameraType.PtGrey:
                        TaskVision.PtGrey_CamStop();
                        break;
                    case GDefine.ECameraType.Spinnaker2:
                        TaskVision.flirCamera2[0].GrabStop();
                        TaskVision.flirCamera2[CamNo].GrabStop();
                        break;
                    case GDefine.ECameraType.MVCGenTL:
                        TaskVision.genTLCamera[0].StopGrab();
                        TaskVision.genTLCamera[CamNo].StopGrab();
                        break;
                    default:
                        throw new Exception("Camera not supported.");
                }

                if (!TaskDisp.TaskMoveGZFocus(Line.IPara[21])) goto _Error;

                int ImageID = Line.ID;


                double LineW_Pix = (Line.IPara[10] + 1) * 2;

                bool ScanRight = (EndX > StartX);
                double d_LineW = (double)(LineW_Pix * TaskVision.DistPerPixelX[CamNo]);


                #region Calc Index Count in Y-direction
                int rotateAngle = 0;
                switch (Line.IPara[8])
                {
                    case 1: rotateAngle = 90; break;
                    case 2: rotateAngle = -90; break;
                }
                double indexDistX = TaskVision.ImgWN[CamNo] * TaskVision.DistPerPixelX[CamNo];
                double indexDistY = TaskVision.ImgHN[CamNo] * TaskVision.DistPerPixelY[CamNo];
                if (rotateAngle == 90 || rotateAngle == -90)
                {
                    indexDistY = indexDistX;
                }
                double distY = Math.Abs(EndY - StartY);
                distY = Math.Round(distY, 3);
                int rowCount = (int)Math.Ceiling((decimal)((distY + indexDistY) / indexDistY));
                if (EndY - StartY < 0) indexDistY = -indexDistY;
                #endregion

                if (!TaskDisp.TaskMoveGZZ2Up()) return false;
                if (!TaskGantry.MoveGX2Y2DefPos(true)) goto _Error;
                if (!TaskGantry.SetMotionParamGXY()) goto _Error;

                double A1Dist = 10 + d_LineW;
                if (ScanRight) A1Dist = -A1Dist;
                double ScanStartX = StartX + A1Dist;
                if (!TaskGantry.MoveAbsGXY(ScanStartX, StartY, true)) goto _Error;

                int SettleTime = Line.IPara[4];
                int t = GDefine.GetTickCount() + SettleTime;
                while (GDefine.GetTickCount() <= t) { Thread.Sleep(1); }

                double StartV = Line.DPara[10]; if (StartV == 0) StartV = TaskGantry.GXAxis.Para.StartV;
                double DriveV = Line.DPara[11]; if (DriveV == 0) DriveV = TaskGantry.GXAxis.Para.FastV;
                double Accel = Line.DPara[12]; if (Accel == 0) Accel = TaskGantry.GXAxis.Para.Accel;
                double ScanSpeed = Line.DPara[13];
                if (ScanSpeed == 0)
                {
                    ScanSpeed = (double)((Line.IPara[10] + 1) * 2 * 4);
                }

                uint MaxW = 0; uint MaxH = 0;
                //uint L = 0; uint T = 0; uint W = 0; uint H = 0;
                #region Set Camera
                switch (GDefine.CameraType[0])
                {
                    case GDefine.ECameraType.PtGrey:
                        {
                            //TaskVision.PGCamera[CamNo].SetProperty(GrabberNET.PtGrey.TCamera.EProperty.Shutter, Line.DPara[5]);
                            //TaskVision.PGCamera[CamNo].SetProperty(GrabberNET.PtGrey.TCamera.EProperty.Gain, Line.DPara[6]);
                            //TaskVision.PGCamera[CamNo].GetImageSettings(ref MaxH, ref MaxW, ref L, ref T, ref W, ref H);
                            break;
                        }
                    case GDefine.ECameraType.Spinnaker2:
                        {
                            TaskVision.flirCamera2[CamNo].Exposure = Line.DPara[5] * 1000;
                            TaskVision.flirCamera2[CamNo].Gain = Line.DPara[6];
                            MaxH = (uint)TaskVision.flirCamera2[CamNo].m_iCamHeight;
                            MaxW = (uint)TaskVision.flirCamera2[CamNo].m_iCamWidth;
                            break;
                        }
                    case GDefine.ECameraType.MVCGenTL:
                        {
                            TaskVision.genTLCamera[CamNo].Exposure = Line.DPara[5] * 1000;
                            TaskVision.genTLCamera[CamNo].Gain = Line.DPara[6];
                            MaxH = (uint)TaskVision.genTLCamera[CamNo].ImageHeightMax;
                            MaxW = (uint)TaskVision.genTLCamera[CamNo].ImageWidthMax;
                            break;
                        }
                }

                int Rotation = Line.IPara[8];//0, 90, -90
                switch (Rotation)
                {
                    case 0:
                        {
                            int Left = (int)(MaxW / 2 - LineW_Pix / 2);
                            if (Left % 2 == 1) Left--;
                            int Top = 0;
                            switch (GDefine.CameraType[0])
                            {
                                case GDefine.ECameraType.PtGrey:
                                    TaskVision.PGCamera[CamNo].SetImageSettings((uint)Left, (uint)Top, (uint)LineW_Pix, (uint)MaxH);
                                    break;
                                case GDefine.ECameraType.Spinnaker2:
                                    TaskVision.flirCamera2[CamNo].ImageWidth = (int)LineW_Pix;
                                    TaskVision.flirCamera2[CamNo].ImageHeight = (int)MaxH;
                                    TaskVision.flirCamera2[CamNo].OffsetX = (int)Left;
                                    TaskVision.flirCamera2[CamNo].OffsetY = (int)Top;
                                    break;
                                case GDefine.ECameraType.MVCGenTL:
                                    TaskVision.genTLCamera[CamNo].ImageWidth = (uint)LineW_Pix;
                                    TaskVision.genTLCamera[CamNo].ImageHeight = (uint)MaxH;
                                    TaskVision.genTLCamera[CamNo].OffsetX = (uint)Left;
                                    TaskVision.genTLCamera[CamNo].OffsetY = (uint)Top;
                                    break;
                            }
                            break;
                        }
                    case 1:
                    case 2:
                        {
                            int Left = 0;
                            int Top = (int)(MaxH / 2 - LineW_Pix / 2);
                            if (Top % 2 == 1) Top--;
                            switch (GDefine.CameraType[0])
                            {
                                case GDefine.ECameraType.PtGrey:
                                    TaskVision.PGCamera[CamNo].SetImageSettings((uint)Left, (uint)Top, (uint)MaxW, (uint)LineW_Pix);
                                    break;
                                case GDefine.ECameraType.Spinnaker2:
                                    TaskVision.flirCamera2[CamNo].ImageWidth = (int)MaxW;
                                    TaskVision.flirCamera2[CamNo].ImageHeight = (int)LineW_Pix;
                                    TaskVision.flirCamera2[CamNo].OffsetX = (int)Left;
                                    TaskVision.flirCamera2[CamNo].OffsetY = (int)Top;
                                    break;
                                case GDefine.ECameraType.MVCGenTL:
                                    TaskVision.genTLCamera[CamNo].ImageWidth = (uint)MaxW;
                                    TaskVision.genTLCamera[CamNo].ImageHeight = (uint)LineW_Pix;
                                    TaskVision.genTLCamera[CamNo].OffsetX = (uint)Left;
                                    TaskVision.genTLCamera[CamNo].OffsetY = (uint)Top;
                                    break;
                            }
                            break;
                        }
                }
                #endregion

                #region Set Compare Config
                CommonControl.P1245.CfgCmpEnable(TaskGantry.GXAxis, true);
                CommonControl.P1245.CfgCmpLogic(TaskGantry.GXAxis, false);
                CommonControl.P1245.CfgCmpSource(TaskGantry.GXAxis, CControl2.ECmpSource.Actual);
                CommonControl.P1245.CfgCmpPulseMode(TaskGantry.GXAxis, CControl2.ECmpPulseMode.Pulse);
                CommonControl.P1245.CfgCmpSetPulseWidth(TaskGantry.GXAxis, 5000);
                CommonControl.P1245.CfgCmpMethod(TaskGantry.GXAxis, CControl2.ECmpMethod.EqualOrLess);
                #endregion

                int Retried = 0;
                _Retry:
                imgMerged = null;


                ScanRight = (EndX > StartX);

                ADist = 10 + d_LineW;
                if (ScanRight) ADist = -ADist;
                ScanStartX = StartX + ADist;

                double DDist = -10 + d_LineW;
                if (ScanRight) DDist = -DDist;
                double ScanEndX = EndX + DDist;

                int indexR = 0;
            _ScanNextRow:
                imgVertMerged = null;
                imgVertSlices.Clear();

                double posY = StartY + (indexR * indexDistY);

                #region Move and Capture Slices
                if (!TaskGantry.SetMotionParamGXY(StartV, DriveV, Accel)) goto _Error;
                if (!TaskGantry.MoveAbsGXY(ScanStartX, posY, true)) goto _Error;

                if (ScanRight)
                    CommonControl.P1245.CfgCmpMethod(TaskGantry.GXAxis, CControl2.ECmpMethod.EqualOrMore);
                else
                    CommonControl.P1245.CfgCmpMethod(TaskGantry.GXAxis, CControl2.ECmpMethod.EqualOrLess);

                switch (GDefine.CameraType[0])
                {
                    case GDefine.ECameraType.PtGrey:
                        TaskVision.PtGrey_CamArm(CamNo);
                        break;
                    case GDefine.ECameraType.Spinnaker2:
                        TaskVision.flirCamera2[CamNo].TriggerSourceHw = true;
                        TaskVision.flirCamera2[CamNo].TriggerMode = true;
                        break;
                    case GDefine.ECameraType.MVCGenTL:
                        TaskVision.genTLCamera[CamNo].TriggerSourceHw = true;
                        TaskVision.genTLCamera[CamNo].TriggerMode = true;
                        TaskVision.genTLCamera[CamNo].StartGrab2();
                        break;
                }

                if (!TaskGantry.SetMotionParamEx(TaskGantry.GXAxis, StartV, ScanSpeed, Accel)) goto _Error;
                if (!TaskGantry.MoveAbsGXY(ScanEndX, posY, false)) goto _Error;


                double ScanLength = Math.Abs(StartX - EndX);
                int lines = (int)Math.Ceiling(ScanLength / (d_LineW));

                double XPos = StartX;

                for (int i = 0; i < lines; i++)
                {
                    if (ScanRight)
                        CommonControl.P1245.CmpSetData(TaskGantry.GXAxis, XPos + ((double)i * d_LineW));
                    else
                        CommonControl.P1245.CmpSetData(TaskGantry.GXAxis, XPos + ((double)i * -d_LineW));

                    switch (GDefine.CameraType[0])
                    {
                        case GDefine.ECameraType.PtGrey:
                            {
                                int t_RetreiveTimeOut = GDefine.GetTickCount();
                                TaskVision.PGCamera[CamNo].RetreiveBuffer();
                                int t3 = GDefine.GetTickCount() - t_RetreiveTimeOut;
                                if (t3 >= 3000)
                                {
                                    if (Retried < 1)
                                    {
                                        Retried++;
                                        Log.AddToLog("DoBdCapture retried " + Retried.ToString());
                                        goto _Retry;
                                    }
                                    else
                                    {
                                        Msg MsgBox = new Msg();
                                        EMsgRes Resp = MsgBox.Show(ErrCode.CAMERA_GRAB_TIMEOUT, EMcState.Error, EMsgBtn.smbRetry_Stop, true);

                                        switch (Resp)
                                        {
                                            case EMsgRes.smrRetry:
                                                {
                                                    TaskVision.PtGrey_CamStop();
                                                    Retried = 0;
                                                    goto _Retry;
                                                }
                                            case EMsgRes.smrStop:
                                                goto _Stop;
                                        }
                                    }
                                }

                                //Img_Strip = new Emgu.CV.Image<Emgu.CV.Structure.Gray, byte>(TaskVision.PGCamera[CamNo].Image());
                                //Img_Strips.Add(Img_Strip);
                                imgVertSlices.Add(TaskVision.PGCamera[CamNo].Image().ToImage<Gray, byte>());//(new Emgu.CV.Image<Emgu.CV.Structure.Gray, byte>(TaskVision.PGCamera[CamNo].Image()));
                                break;
                            }
                        case GDefine.ECameraType.Spinnaker2:
                            {
                                int t_TimeOut = GDefine.GetTickCount() + 500;
                                TaskVision.flirCamera2[CamNo].GrabOne(1000);

                                if (GDefine.GetTickCount() >= t_TimeOut)
                                {
                                    if (Retried < 2)
                                    {
                                        Retried++;
                                        Log.AddToLog("DoBdCapture Retried " + Retried.ToString() + " Section " + i.ToString() + " of " + lines.ToString());
                                        if (!TaskGantry.DecelStop(TaskGantry.GXAxis)) goto _Error;
                                        if (!TaskGantry.WaitGXY()) goto _Error;
                                        goto _Retry;
                                    }
                                    else
                                    {
                                        Msg MsgBox = new Msg();
                                        EMsgRes Resp = MsgBox.Show(ErrCode.CAMERA_GRAB_TIMEOUT, EMcState.Error, EMsgBtn.smbRetry_Stop, true);

                                        switch (Resp)
                                        {
                                            case EMsgRes.smrRetry:
                                                {
                                                    Retried = 0;
                                                    goto _Retry;
                                                }
                                            case EMsgRes.smrStop:
                                                if (!TaskGantry.DecelStop(TaskGantry.GXAxis)) goto _Error;
                                                if (!TaskGantry.WaitGXY()) goto _Error;
                                                goto _Stop;
                                        }
                                    }
                                }
                                //Img_Strip = TaskVision.flirCamera2[CamNo].m_ImageEmgu.m_Image.Clone();
                                //Img_Strips.Add(Img_Strip);
                                imgVertSlices.Add(TaskVision.flirCamera2[CamNo].m_ImageEmgu.m_Image.Clone());
                                break;
                            }
                        case GDefine.ECameraType.MVCGenTL:
                            {
                                int t_TimeOut = GDefine.GetTickCount() + 500;
                                //TaskVision.genTLCamera[CamNo].GrabOneImage();
                                TaskVision.genTLCamera[CamNo].ReceiveProcess();

                                if (GDefine.GetTickCount() >= t_TimeOut)
                                {
                                    if (Retried < 2)
                                    {
                                        Retried++;
                                        Log.AddToLog("DoBdCapture Retried " + Retried.ToString() + " Section " + i.ToString() + " of " + lines.ToString());
                                        if (!TaskGantry.DecelStop(TaskGantry.GXAxis)) goto _Error;
                                        if (!TaskGantry.WaitGXY()) goto _Error;
                                        goto _Retry;
                                    }
                                    else
                                    {
                                        Msg MsgBox = new Msg();
                                        EMsgRes Resp = MsgBox.Show(ErrCode.CAMERA_GRAB_TIMEOUT, EMcState.Error, EMsgBtn.smbRetry_Stop, true);

                                        switch (Resp)
                                        {
                                            case EMsgRes.smrRetry:
                                                {
                                                    Retried = 0;
                                                    goto _Retry;
                                                }
                                            case EMsgRes.smrStop:
                                                if (!TaskGantry.DecelStop(TaskGantry.GXAxis)) goto _Error;
                                                if (!TaskGantry.WaitGXY()) goto _Error;
                                                goto _Stop;
                                        }
                                    }
                                }
                                //Img_Strip = TaskVision.flirCamera2[CamNo].m_ImageEmgu.m_Image.Clone();
                                //Img_Strips.Add(Img_Strip);
                                imgVertSlices.Add(TaskVision.genTLCamera[CamNo].mImage.Clone());
                                Thread.Sleep(0);
                                break;
                            }
                    }
                }
                #endregion

                #region Rotate Slices and Merge Slices
                for (int i = imgVertSlices.Count - 1; i >= 0; i--)
                {
                    switch (Rotation)
                    {
                        case 1://90
                            imgVertSlices[i] = imgVertSlices[i].Rotate(90, new Emgu.CV.Structure.Gray(0), false); break;
                        case 2://90
                            imgVertSlices[i] = imgVertSlices[i].Rotate(-90, new Emgu.CV.Structure.Gray(0), false); break;
                    }

                    if (imgVertMerged == null) imgVertMerged = imgVertSlices[i].Clone();
                    else
                    {
                        if (ScanRight)
                            imgVertMerged = imgVertSlices[i].ConcateHorizontal(imgVertMerged);
                        else
                            imgVertMerged = imgVertMerged.ConcateHorizontal(imgVertSlices[i]);
                    }
                }
                #endregion

                if (imgMerged == null) imgMerged = imgVertMerged.Clone();
                else
                {
                    if (indexDistY < 0)
                    imgMerged = imgMerged.ConcateVertical(imgVertMerged);
                    else
                        imgMerged = imgVertMerged.ConcateVertical(imgMerged);
                }

                if (!TaskGantry.WaitGXY()) goto _Error;

                indexR++;
                if (indexR < rowCount)
                {
                    goto _ScanNextRow;
                }

                if (TaskVision.BoardImage[ImageID] != null)
                {
                    TaskVision.PrevBoardImage[ImageID] = TaskVision.BoardImage[ImageID].Clone();
                    TaskVision.PrevBoardImage_ID[ImageID]++;
                }
                TaskVision.BoardImage[ImageID] = imgMerged.Clone();
                TaskVision.BoardImage_ID[ImageID]++;


                //Img_Merge.Save(GDefine.AppPath + @"\Test\LineScan.bmp");

                GDefine.Status = EStatus.Ready;
                return true;

                _Stop:
                GDefine.Status = EStatus.Stop;
                return false;

                _Error:
                GDefine.Status = EStatus.ErrorInit;
                return false;
            }
            catch (Exception Ex)
            {
                GDefine.Status = EStatus.ErrorInit;
                EMsg = EMsg + (char)13 + Ex.Message.ToString();
                throw new Exception(EMsg);
            }
            finally
            {
                //if (Img_Strip != null) Img_Strip.Dispose();
                foreach (Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> img in imgVertSlices)
                {
                    if (img != null) img.Dispose();
                }
                if (imgVertMerged != null) imgVertMerged.Dispose();

                #region Set Camera
                uint MaxW = 0; uint MaxH = 0;
                uint L = 0; uint T = 0; uint W = 0; uint H = 0;
                switch (GDefine.CameraType[0])
                {
                    case GDefine.ECameraType.PtGrey:
                        {
                            TaskVision.PtGrey_CamStop();
                            TaskVision.PGCamera[CamNo].GetImageSettings(ref MaxH, ref MaxW, ref L, ref T, ref W, ref H);
                            TaskVision.PGCamera[CamNo].SetImageSettings(0, 0, (uint)MaxW, (uint)MaxH);
                            TaskVision.CameraRun = true;
                            TaskVision.PtGrey_CamLive(CamNo);
                            break;
                        }
                    case GDefine.ECameraType.Spinnaker2:
                        {
                            TaskVision.flirCamera2[CamNo].GrabStop();
                            TaskVision.flirCamera2[CamNo].OffsetX = 0;
                            TaskVision.flirCamera2[CamNo].OffsetY = 0;
                            TaskVision.flirCamera2[CamNo].ImageWidth = TaskVision.flirCamera2[CamNo].m_iCamWidthMax;
                            TaskVision.flirCamera2[CamNo].ImageHeight = TaskVision.flirCamera2[CamNo].m_iCamHeightMax;
                            TaskVision.flirCamera2[CamNo].Snap();
                            break;
                        }
                    case GDefine.ECameraType.MVCGenTL:
                        {
                            TaskVision.genTLCamera[CamNo].StopGrab();
                            TaskVision.genTLCamera[CamNo].TriggerMode = false;
                            TaskVision.genTLCamera[CamNo].OffsetX = 0;
                            TaskVision.genTLCamera[CamNo].OffsetY = 0;
                            TaskVision.genTLCamera[CamNo].ImageWidth = TaskVision.genTLCamera[CamNo].ImageWidthMax;
                            TaskVision.genTLCamera[CamNo].ImageHeight = TaskVision.genTLCamera[CamNo].ImageHeightMax;
                            TaskVision.genTLCamera[CamNo].Exposure = TaskVision.ExposureTime[CamNo] * 1000;
                            TaskVision.genTLCamera[CamNo].Gain = TaskVision.Gain[CamNo];
                            break;
                        }
                }
                #endregion
            }
        }

        public static bool Read_ID(TLine Line, double X, double Y)
        {
            string EMsg = "Read_ID";
            GDefine.Status = EStatus.Busy;

            string ID = "";

            try
            {
                if (!TaskDisp.TaskMoveGZZ2Up()) goto _Error;
                if (!TaskGantry.MoveGX2Y2DefPos(true)) goto _Error;
                if (!TaskGantry.SetMotionParamGXY()) goto _Error;
                if (!TaskGantry.MoveAbsGXY(X, Y, true)) goto _Error;

                if (!TaskDisp.TaskMoveGZFocus(Line.IPara[21])) goto _Error;

                int SettleTime = Line.IPara[4];
                int t = GDefine.GetTickCount() + SettleTime;
                while (GDefine.GetTickCount() <= t) { Thread.Sleep(1); }

            _Retry:
                //read ID here
                bool enableReader = Line.IPara[0] > 0;
                TaskDisp.IDReader_Enabled = enableReader;

                if (TaskDisp.IDReader_Enabled)
                {
                    TaskDisp.IDReader_Read(false, ref ID);
                    rt_Read_IDs[Line.ID, RunTime.UIndex] = ID;
                    Log.Board.WriteByMonthDay("READ_ID: " + ID);
                    Event.READ_ID.Set("ID", ID);

                    if (ID == "")
                    {
                        IO.SetState(EMcState.Error);
                        frm_DispCore_DispProg_ReadID_ManualEntry frm = new frm_DispCore_DispProg_ReadID_ManualEntry();
                        DialogResult dr = frm.ShowDialog();

                        switch (dr)
                        {
                            case DialogResult.OK:
                                if (frm.ID.Length == 0)
                                {
                                    goto _Retry;
                                }
                                rt_Read_IDs[Line.ID, RunTime.UIndex] = frm.ID;

                                Log.Board.WriteByMonthDay("READ_ID Manual Entry: " + frm.ID);
                                Event.MANUAL_ID_ENTRY.Set("ID", frm.ID);
                                IO.SetState(EMcState.Idle);
                                break;
                            case DialogResult.Retry:
                                IO.SetState(EMcState.Idle);
                                goto _Retry;
                            case DialogResult.Cancel:
                                IO.SetState(EMcState.Idle);
                                goto _Stop;
                            case DialogResult.Ignore://skip unit
                                if (TaskDisp.Preference == TaskDisp.EPreference.Lumileds)
                                {
                                    Map.CurrMap[rt_LayoutID].Bin[RunTime.UIndex] = EMapBin.Bypass;
                                }
                                IO.SetState(EMcState.Idle);
                                break;
                        }
                    }

                    if (TaskDisp.Preference == TaskDisp.EPreference.Lumileds)
                    {
                        if (rt_Read_IDs[Line.ID, RunTime.UIndex] != "")
                        {
                            string s = DateTime.Now.ToString("o") + (char)9 + rt_Read_IDs[Line.ID, RunTime.UIndex] + "\r\n";
                            TaskDisp.Lmds_WriteLotFile(s);
                        }
                    }

                    if (TaskDisp.Preference == TaskDisp.EPreference.TD_4FCOB)
                    {
                        if (!RLMS.CheckHeartBeat())
                        {
                            Msg MsgBox = new Msg();
                            EMsgRes Resp = MsgBox.Show("Lot Program Not Running.@Stop - Stop Operation.", EMcState.Error, EMsgBtn.smbStop, true);
                            goto _Stop;
                        }
                        if (!RLMS.LotStarted())
                        {
                            Msg MsgBox = new Msg();
                            EMsgRes Resp = MsgBox.Show("Lot Not Started.@Stop - Stop Operation.", EMcState.Error, EMsgBtn.smbStop, true);
                            goto _Stop;
                        }
                        if (!RLMS.CheckBoardID(rt_Read_IDs[Line.ID, RunTime.UIndex]))
                        {
                            Msg MsgBox = new Msg();
                            EMsgRes Resp = MsgBox.Show("Check BoardID Fail.@Stop - Stop Operation.", EMcState.Error, EMsgBtn.smbStop, true);
                            goto _Stop;
                        }
                    }
                }
            }
            catch (Exception Ex)
            {
                GDefine.Status = EStatus.ErrorInit;
                EMsg = EMsg + (char)13 + Ex.Message.ToString();
                throw new Exception(EMsg);
            }
            finally
            {
            }

            GDefine.Status = EStatus.Ready;
            return true;
            _Stop:
            GDefine.Status = EStatus.Stop;
            return false;
            _Error:
            GDefine.Status = EStatus.ErrorInit;
            return false;
        }

        public static bool Exec_ExtVision(TLine Line, double f_origin_x, double f_origin_y, double f_origin_z)
        {
            string EMsg = "Exec_ExtVision";
            GDefine.Status = EStatus.Busy;

            try
            {
                TaskVision.LightingOff();

                if (!TaskDisp.TaskMoveGZFocus(Line.IPara[21])) return false;
                if (!TaskGantry.MoveGX2Y2DefPos(true)) return false;

                #region assign and translate position
                double dx = f_origin_x + rt_LayoutRelPos[RunTime.UIndex].X + Line.X[0];
                double dy = f_origin_y + rt_LayoutRelPos[RunTime.UIndex].Y + Line.Y[0];
                TranslatePos(dx, dy, rt_Head1RefData, ref dx, ref dy);

                double X = dx;
                double Y = dy;
                #endregion

                if (!TaskGantry.SetMotionParamGXY()) goto _Stop;
                if (!TaskGantry.MoveAbsGXY(X, Y, true)) goto _Stop;

                #region Settle Time
                int SettleTime = Line.IPara[4];
                int t = GDefine.GetTickCount() + SettleTime;
                while (GDefine.GetTickCount() <= t) { Thread.Sleep(1); }
                #endregion

                _Retry:
                if (!ExtVision.Connected) throw new Exception("Ext Vision is not connected.");

                bool OK = false;
                if (!ExtVision.Send_Trig1(ref OK)) goto _Stop;
                Event.OP_EXT_VISION_OK.Set();

                if (!OK)
                {
                    Event.OP_EXT_VISION_NG.Set();
                    Msg MsgBox = new Msg();
                    EMsgRes Resp = MsgBox.Show("Ext Vision Inspect NG.@OK - Accept current inspection.@Stop - Stop Operation.", EMcState.Error, EMsgBtn.smbOK_Retry_Stop, true);
                    switch (Resp)
                    {
                        case EMsgRes.smrRetry:
                            goto _Retry;
                        case EMsgRes.smrStop:
                            goto _Stop;
                    }
                }
            }
            catch (Exception Ex)
            {
                GDefine.Status = EStatus.ErrorInit;
                EMsg = EMsg + (char)13 + Ex.ToString();
                throw new Exception(EMsg);
            }
            GDefine.Status = EStatus.Ready;
            return true;
            _Stop:
            GDefine.Status = EStatus.Stop;
            return false;
        }

        internal class TInputMap
        {
            public static bool Execute(string LotNo, string FrameNo, ref TMap Map, bool enabled = true, string manualLotNo = "", string materialNr = "")
            {
                //string EMsg = "InputMap";
                GDefine.Status = EStatus.Busy;

                if (enabled)
                    Event.INPUT_MAP.Set("ID", FrameNo);
                else
                    Event.INPUT_MAP.Set("Disabled", "");

                //if (!TaskDisp.InputMap_Enabled) return true;
                if (!enabled) return true;

                try
                {
                    if (FrameNo == "")
                    {
                        Msg MsgBox = new Msg();
                        EMsgRes Res = MsgBox.Show("INPUT_MAP Invalid ID.@OK - Continue without ID.@STOP - Stop Process.", EMcState.Error, EMsgBtn.smbOK_Stop, false);
                        switch (Res)
                        {
                            case EMsgRes.smrOK:
                                return true;
                            default:
                                return false;
                        }
                    }

                    switch (TaskDisp.InputMap_Protocol)
                    {
                        case TaskDisp.EInputMapProtocol.None:
                            {
                                if (TaskDisp.Preference == TaskDisp.EPreference.Unisem) break;

                                throw new Exception("Input Map Protocol not defined.");
                            }
                        case TaskDisp.EInputMapProtocol.Lumileds_EMap:
                            {
                                int[,] SS_Map = new int[1024, 1024];
                                if (!Task_InputMap.Lumileds_SS_EMap.DecodeMap(LotNo, FrameNo, ref SS_Map, rt_Singulated)) goto _Stop;

                                #region convert to cr map
                                int[,] SS_Map_CR = new int[1024, 1024];
                                int Col = rt_Layouts[0].TColCount;
                                int Row = rt_Layouts[0].TRowCount;
                                for (int c = 0; c < Col; c++)
                                {
                                    for (int r = 0; r < Row; r++)
                                    {
                                        int uc = c;
                                        if (rt_Layouts[0].MapOrigin == TLayout.EMapOrigin.Left) uc = Col - 1 - c;

                                        int ur = r;

                                        SS_Map_CR[uc, ur] = SS_Map[c, r];
                                    }
                                }
                                #endregion

                                if (rt_Singulated)
                                {
                                    //if (SS_Map_CR[0, 0] >= 1)
                                    if (SS_Map[0, 0] >= 1)
                                    {
                                            Map.Bin[0] = EMapBin.MapOK;
                                    }
                                    else
                                    {
                                        Map.Bin[0] = EMapBin.InMapNG;
                                    }
                                }
                                else
                                {
                                    #region update to rt_Map
                                    for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                    {
                                        if (Map.Bin[i] == EMapBin.PreMapNG) continue;
                                        if (Map.Bin[i] == EMapBin.Bypass) continue;

                                        int iCol = 0;
                                        int iRow = 0;
                                        rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref iCol, ref iRow);

                                        if (SS_Map_CR[iCol, iRow] >= 1)
                                        {
                                            Map.Bin[i] = EMapBin.MapOK;
                                        }
                                        else
                                        {
                                            Map.Bin[i] = EMapBin.InMapNG;
                                        }
                                    }
                                }

                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                {
                                    if (Map.Bin[i] == EMapBin.InMapNG)
                                    {
                                        if (DispProg.Pump_Type == TaskDisp.EPumpType.PP2D)
                                        {
                                            int i2 = 0;
                                            if (rt_Layouts[rt_LayoutID].UnitNoIsNeedle2(i))
                                                rt_Layouts[rt_LayoutID].UnitNoGetNeedle1UnitNo(i, ref i2);
                                            else
                                                rt_Layouts[rt_LayoutID].UnitNoGetNeedle2UnitNo(i, ref i2);

                                            Map.Bin[i2] = Map.Bin[i];
                                        }
                                    }
                                }
                                #endregion
                                break;
                            }
                        case TaskDisp.EInputMapProtocol.TD_COB:
                            {
                                int[] TD_Map_IsDimPass = new int[1024];
                                int[] TD_Map_IsDispensed = new int[1024];

                                int iDataCount = Task_InputMap.TD_COB.MapDB_Query(FrameNo, ref TD_Map_IsDimPass, ref TD_Map_IsDispensed);
                                if (iDataCount > 0)
                                {
                                    Task_InputMap.TD_COB.MapDB_QueryIsOK = true;
                                    Event.INPUT_MAP_QUERY.Set("Data", iDataCount.ToString());
                                }
                                else
                                {
                                    Task_InputMap.TD_COB.MapDB_QueryIsOK = false;
                                    Event.INPUT_MAP_QUERY.Set("Data", "No data.");


                                    Msg MsgBox = new Msg();
                                    EMsgRes Res = MsgBox.Show("INPUT_MAP Query Fail." +
                                        "@OK - Continue without ID." +
                                        "@STOP - Stop Process.", EMcState.Notice, EMsgBtn.smbOK_Stop, false);
                                    switch (Res)
                                    {
                                        case EMsgRes.smrOK:
                                            return true;
                                        default:
                                            return false;
                                    }

                                }

                                if (iDataCount > 0)
                                {
                                    #region update to rt_Map
                                    for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                    {
                                        if (Map.Bin[i] == EMapBin.PreMapNG) continue;
                                        if (Map.Bin[i] == EMapBin.Bypass) continue;


                                        if (TD_Map_IsDispensed[i] == 1)
                                        {
                                            Map.Bin[i] = EMapBin.InMapNG;
                                        }
                                        else
                                        if (TD_Map_IsDimPass[i] == 1)
                                        {
                                            Map.Bin[i] = EMapBin.MapOK;
                                        }
                                        else
                                            Map.Bin[i] = EMapBin.InMapNG;
                                    }
                                    #endregion
                                }
                                break;
                            }
                        case TaskDisp.EInputMapProtocol.OSRAM_eMos:
                            {
                                string LotNumber = manualLotNo.Length > 0 ? manualLotNo : LotInfo2.LotNumber;
                                string Operator = LotInfo2.sOperatorID;
                                string MaterialNr = materialNr.Length > 0 ? materialNr : LotInfo2.Osram.ElevenSeries;

                                string MapID = MaterialNr + "-" + FrameNo;
                                Task_InputMap.OsramEMos.SendMapRequest(MapID, LotNumber, Operator, MaterialNr);
                                int[,] map = null;
                                Size mapSize = new Size(1, 1);
                                Task_InputMap.OsramEMos.DecodeMap(MapID, ref map, ref mapSize);

                                int[,] map2 = new int[mapSize.Width, mapSize.Height];
                                int Col = rt_Layouts[0].TColCount;
                                int Row = rt_Layouts[0].TRowCount;
                                for (int c = 0; c < Col; c++)
                                {
                                    for (int r = 0; r < Row; r++)
                                    {
                                        int uc = c;
                                        if (rt_Layouts[0].MapOrigin == TLayout.EMapOrigin.Left) uc = Col - 1 - c;

                                        int ur = r;

                                        map2[uc, ur] = map[c, r];
                                    }
                                }

                                if (mapSize.Width != rt_Layouts[rt_LayoutID].TColCount || mapSize.Height != rt_Layouts[rt_LayoutID].TRowCount)
                                {
                                    Msg MsgBox = new Msg();
                                    EMsgRes Res = MsgBox.Show("Incorrect MapSize. Column and row not match.");
                                    return false;
                                }

                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                {
                                    if (Map.Bin[i] == EMapBin.PreMapNG) continue;
                                    if (Map.Bin[i] == EMapBin.Bypass) continue;

                                    int iCol = 0;
                                    int iRow = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref iCol, ref iRow);

                                    if (map2[iCol, iRow] >= 1)
                                    {
                                        Map.Bin[i] = EMapBin.MapOK;
                                    }
                                    else
                                    {
                                        Map.Bin[i] = EMapBin.InMapNG;
                                    }
                                }
                                break;
                            }
                    }

                    if (TaskDisp.Preference == TaskDisp.EPreference.Unisem && TaskDisp.SECSGEMProtocol == TaskDisp.ESECSGEMProtocol.SECSGEMConnect2 && (GDefine.sgc2.EnableDnloadStripMapE142 || GDefine.sgc2.EnableUploadStripMapE142))
                    {
                        //special condition for Unisem process half frame
                        if (TaskConv.Pre.rt_StType == TaskConv.EPreStType.Disp1 && TaskConv.Pre.Status >= TaskConv.EProcessStatus.Heating)
                        {
                            _retryHalf:
                            GDefine.sgc2.SendDownload(FrameNo);
                            int t = GDefine.GetTickCount();
                            while (true)
                            {
                                if (GDefine.sgc2.MapState == SECSGEMConnect2.EMapState.Loaded)
                                {
                                    #region update to rt_Map
                                    if (GDefine.sgc2.EnableDnloadStripMapE142)
                                    {
                                        for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                        {
                                            int iCol = 0;
                                            int iRow = 0;
                                            rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref iCol, ref iRow);

                                            int iColM = (rt_Layouts[rt_LayoutID].TColCount * 2) - 1 - iCol;

                                            try
                                            {
                                                Map.Bin[i] = (EMapBin)GDefine.sgc2.map[iColM, iRow];
                                            }
                                            catch
                                            {
                                                Map.Bin[i] = EMapBin.None;
                                            }
                                        }
                                    }
                                    #endregion
                                    break;
                                }
                                if (GDefine.sgc2.MapState == SECSGEMConnect2.EMapState.DecodeError)
                                {
                                    Msg MsgBox = new Msg();
                                    EMsgRes Res = MsgBox.Show("Download Map Decode Error." +
                                        "@OK - Continue without ID." +
                                        "@STOP - Stop Process.", EMcState.Error, EMsgBtn.smbOK_Stop, false);
                                    switch (Res)
                                    {
                                        case EMsgRes.smrOK:
                                            return true;
                                        default:
                                            return false;
                                    }
                                }
                                if (GDefine.GetTickCount() - t > GDefine.sgc2.TimeOut)
                                {
                                    Msg MsgBox = new Msg();
                                    EMsgRes Res = MsgBox.Show("Download Map TimeOut." +
                                        "@OK - Continue without ID." +
                                        "@STOP - Stop Process.", EMcState.Error, EMsgBtn.smbOK_Retry_Stop, false);
                                    switch (Res)
                                    {
                                        case EMsgRes.smrOK:
                                            return true;
                                        case EMsgRes.smrRetry:
                                            goto _retryHalf;
                                        default:
                                            return false;
                                    }
                                }
                                Thread.Sleep(1);
                            }
                        }
                        else
                        if (TaskConv.Pro.rt_StType == TaskConv.EProStType.Disp2 && TaskConv.Pro.Status >= TaskConv.EProcessStatus.Heating)
                        {
                            if (GDefine.sgc2.MapState == SECSGEMConnect2.EMapState.Loaded)
                            {
                                #region update to rt_Map
                                if (GDefine.sgc2.EnableDnloadStripMapE142)
                                {
                                    for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                    {
                                        int iCol = 0;
                                        int iRow = 0;
                                        rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref iCol, ref iRow);

                                        int iColM = rt_Layouts[rt_LayoutID].TColCount - 1 - iCol;

                                        try
                                        {
                                            Map.Bin[i] = (EMapBin)GDefine.sgc2.map[iColM, iRow];
                                        }
                                        catch
                                        {
                                            Map.Bin[i] = EMapBin.None;
                                        }
                                    }
                                }
                                #endregion
                            }
                        }
                        else
                        {
                            _retry:
                            GDefine.sgc2.SendDownload(FrameNo);
                            int t = GDefine.GetTickCount();
                            while (true)
                            {
                                if (GDefine.sgc2.MapState == SECSGEMConnect2.EMapState.Loaded)
                                {
                                    #region update to rt_Map
                                    if (GDefine.sgc2.EnableDnloadStripMapE142)
                                    {
                                        for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                        {
                                            int iCol = 0;
                                            int iRow = 0;
                                            rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref iCol, ref iRow);

                                            int iColM = rt_Layouts[rt_LayoutID].TColCount - 1 - iCol;

                                            try
                                            {
                                                Map.Bin[i] = (EMapBin)GDefine.sgc2.map[iColM, iRow];
                                            }
                                            catch
                                            {
                                                Map.Bin[i] = EMapBin.None;
                                            }
                                        }
                                    }
                                    #endregion
                                    break;
                                }
                                if (GDefine.sgc2.MapState == SECSGEMConnect2.EMapState.DecodeError)
                                {
                                    Msg MsgBox = new Msg();
                                    EMsgRes Res = MsgBox.Show("Download Map Decode Error." +
                                        "@OK - Continue without Map." +
                                        "@STOP - Stop Process.", EMcState.Error, EMsgBtn.smbOK_Stop, false);
                                    switch (Res)
                                    {
                                        case EMsgRes.smrOK:
                                            return true;
                                        default:
                                            return false;
                                    }
                                }
                                if (GDefine.GetTickCount() - t > GDefine.sgc2.TimeOut)
                                {
                                    Msg MsgBox = new Msg();
                                    EMsgRes Res = MsgBox.Show("Download Map TimeOut." +
                                        "@OK - Continue without Map." +
                                        "@STOP - Stop Process.", EMcState.Error, EMsgBtn.smbOK_Retry_Stop, false);
                                    switch (Res)
                                    {
                                        case EMsgRes.smrOK:
                                            return true;
                                        case EMsgRes.smrRetry:
                                            goto _retry;
                                        default:
                                            return false;
                                    }
                                }
                                Thread.Sleep(1);
                            }
                        }
                    }
                }
                catch (Exception Ex)
                {
                    GDefine.Status = EStatus.Stop;
                    //EMsg = EMsg + (char)13 + Ex.Message.ToString();

                    Msg MsgBox = new Msg();
                    MsgBox.Show(MethodBase.GetCurrentMethod().Name.ToString() + '\r' + Ex.Message.ToString());
                    return false;
                }
                finally
                {
                }

                GDefine.Status = EStatus.Ready;
                return true;
            _Stop:
                GDefine.Status = EStatus.Stop;
                return false;
            }
            public static bool Upload(string FrameNo, ref TMap Map)
            {
                //string EMsg = "UploadMap";
                GDefine.Status = EStatus.Busy;

                try
                {
                    if (TaskDisp.Preference == TaskDisp.EPreference.Unisem && TaskDisp.SECSGEMProtocol == TaskDisp.ESECSGEMProtocol.SECSGEMConnect2 && GDefine.sgc2.EnableUploadStripMapE142)
                    {
                        if (FrameNo == "")
                        {
                            Msg MsgBox = new Msg();
                            EMsgRes Res = MsgBox.Show("Upload Map Invalid ID.@STOP - Stop Process.", EMcState.Error, EMsgBtn.smbStop, false);
                                    goto _Stop;
                        }

                        //special condition for Unisem process 1st half frame
                        if (TaskConv.Pre.rt_StType == TaskConv.EPreStType.Disp1 && TaskConv.Pre.Status >= TaskConv.EProcessStatus.Heating)
                        {
                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                            {
                                int iCol = 0;
                                int iRow = 0;
                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref iCol, ref iRow);
                                int iColM = (rt_Layouts[rt_LayoutID].TColCount*2) - 1 - iCol;

                                try
                                {
                                    GDefine.sgc2.map[iColM, iRow] = (int)Map.Bin[i];
                                }
                                catch
                                {

                                }
                            }
                        }
                        else//special condition for Unisem process 2nd half frame
                        if (TaskConv.Pro.rt_StType == TaskConv.EProStType.Disp2 && TaskConv.Pro.Status >= TaskConv.EProcessStatus.Heating)
                        {
                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                            {
                                int iCol = 0;
                                int iRow = 0;
                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref iCol, ref iRow);
                                int iColM = rt_Layouts[rt_LayoutID].TColCount - 1 - iCol;

                                try
                                {
                                    GDefine.sgc2.map[iColM, iRow] = (int)Map.Bin[i];
                                }
                                catch
                                {

                                }
                            }

                            #region update to SECSGEMConnect2
                            GDefine.sgc2.UploadXMLString("");

                            int t = GDefine.GetTickCount();
                            while (true)
                            {
                                if (GDefine.sgc2.MapState == SECSGEMConnect2.EMapState.Uploaded)
                                {
                                    string file = GDefine.StripMapDir.FullName + FrameNo + ".txt";
                                    if (File.Exists(file)) File.Delete(file);
                                    break;
                                }
                                if (GDefine.sgc2.MapState == SECSGEMConnect2.EMapState.UploadFail)
                                {
                                    Msg MsgBox = new Msg();
                                    EMsgRes Res = MsgBox.Show("Upload Map Fail." +
                                        "@OK - Continue to unload frame? Map data will be lost." +
                                        "@STOP - Stop Process.", EMcState.Error, EMsgBtn.smbOK_Stop, false);
                                    switch (Res)
                                    {
                                        case EMsgRes.smrOK:
                                            break;
                                        default:
                                            goto _Stop;
                                    }
                                }
                                if (GDefine.GetTickCount() - t > GDefine.sgc2.TimeOut)
                                {
                                    Msg MsgBox = new Msg();
                                    EMsgRes Res = MsgBox.Show("Upload Map TimeOut." +
                                        "@OK - Continue to unload frame? Map data will be lost." +
                                        "@STOP - Stop Process.", EMcState.Error, EMsgBtn.smbOK_Stop, false);
                                    switch (Res)
                                    {
                                        case EMsgRes.smrOK:
                                            break;
                                        default:
                                            goto _Stop;
                                    }
                                }
                                Thread.Sleep(1);
                            }
                            #endregion
                        }
                        else//full frame process
                        {
                            #region update to SECSGEMConnect2
                            for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                            {
                                int iCol = 0;
                                int iRow = 0;
                                rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref iCol, ref iRow);
                                int iColM = rt_Layouts[rt_LayoutID].TColCount - 1 - iCol;

                                try
                                {
                                    GDefine.sgc2.map[iColM, iRow] = (int)Map.Bin[i];
                                }
                                catch
                                {

                                }
                            }
                            GDefine.sgc2.UploadXMLString("");

                            int t = GDefine.GetTickCount();
                            while (true)
                            {
                                if (GDefine.sgc2.MapState == SECSGEMConnect2.EMapState.Uploaded)
                                {
                                    string file = GDefine.StripMapDir.FullName + FrameNo + ".txt";
                                    if (File.Exists(file)) File.Delete(file);
                                    break;
                                }
                                if (GDefine.sgc2.MapState == SECSGEMConnect2.EMapState.UploadFail)
                                {
                                    Msg MsgBox = new Msg();
                                    EMsgRes Res = MsgBox.Show("Upload Map Fail." +
                                        "@STOP - Stop Process.", EMcState.Error, EMsgBtn.smbStop, false);
                                    goto _Stop;
                                }
                                if (GDefine.GetTickCount() - t > GDefine.sgc2.TimeOut)
                                {
                                    Msg MsgBox = new Msg();
                                    EMsgRes Res = MsgBox.Show("Upload Map TimeOut." +
                                        "@STOP - Stop Process.", EMcState.Error, EMsgBtn.smbStop, false);
                                    goto _Stop;
                                }
                                Thread.Sleep(1);
                            }
                            #endregion
                        }
                    }
                }
                catch (Exception Ex)
                {
                    GDefine.Status = EStatus.Stop;
                    Msg MsgBox = new Msg();
                    MsgBox.Show(MethodBase.GetCurrentMethod().Name.ToString() + '\r' + Ex.Message.ToString());
                    return false;
                }
                finally
                {
                }

                GDefine.Status = EStatus.Ready;
                return true;
            _Stop:
                GDefine.Status = EStatus.Stop;
                return false;
            }
        }
        internal class TOutputMap
        {
            public static bool Execute(string LotNo, string FrameNo, ref TMap Map, bool enabled = true)
            {
                string EMsg = "OutputMap";
                if (!enabled) return true;

                GDefine.Status = EStatus.Busy;
                try
                {
                    switch (TaskDisp.InputMap_Protocol)
                    {
                        default:
                        case TaskDisp.EInputMapProtocol.None:
                            break;
                        case TaskDisp.EInputMapProtocol.OSRAM_eMos:
                            {
                                string LotNumber = LotInfo2.LotNumber;
                                string Operator = LotInfo2.sOperatorID;
                                string MaterialNr = LotInfo2.Osram.ElevenSeries;

                                int[,] map2 = new int[rt_Layouts[0].TColCount, rt_Layouts[0].TRowCount];
                                for (int i = 0; i < rt_Layouts[rt_LayoutID].TUCount; i++)
                                {
                                    int iCol = 0;
                                    int iRow = 0;
                                    rt_Layouts[rt_LayoutID].UnitNoGetRC(i, ref iCol, ref iRow);
                                    try
                                    {
                                        map2[iCol, iRow] = Map.Bin[i] == EMapBin.Complete ? 1 : 0;
                                    }
                                    catch {}
                                }

                                int[,] map3 = new int[rt_Layouts[0].TColCount, rt_Layouts[0].TRowCount];
                                for (int c = 0; c < rt_Layouts[0].TColCount; c++)
                                    for (int r = 0; r < rt_Layouts[0].TRowCount; r++)
                                    {
                                        int uc = c;
                                        if (rt_Layouts[0].MapOrigin == TLayout.EMapOrigin.Left) uc = rt_Layouts[0].TColCount - 1 - c;
                                        map3[c, r] = map2[uc, r];
                                    }


                                Task_InputMap.OsramEMos.WriteETVFile(MaterialNr + "-" + FrameNo, map3, new Size(rt_Layouts[0].TColCount, rt_Layouts[0].TRowCount));
                                break;
                            }
                    }
                }
                catch (Exception Ex)
                {
                    GDefine.Status = EStatus.Stop;
                    EMsg = EMsg + (char)13 + Ex.Message.ToString();

                    Msg MsgBox = new Msg();
                    MsgBox.Show(EMsg);
                    return false;
                }
                finally
                {
                }

                GDefine.Status = EStatus.Ready;
                return true;
            }
        }
        private static bool DoRef(TLine Line, double X, double Y, int RefID, int RefNo, out double ox, out double oy, out double s, ref Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> FoundImage)
        {
            string EMsg = "DoVision";
            GDefine.Status = EStatus.Busy;

            TaskVision.LightingOn(TaskVision.LightRGB[RefID]);

            ox = 0;
            oy = 0;
            s = 0;

            //**** Do 2 vision in 2 FOV
            try
            {
                #region Z Up
                if (!TaskDisp.TaskMoveGZFocus(Line.IPara[21])) return false;
                #endregion

                if (!TaskGantry.MoveGX2Y2DefPos(true)) return false;

                #region Move to XY
                double StartV = Line.DPara[10];
                if (StartV == 0) StartV = TaskGantry.GXAxis.Para.StartV;
                double DriveV = Line.DPara[11];
                if (DriveV == 0) DriveV = TaskGantry.GXAxis.Para.FastV;
                double Accel = Line.DPara[12];
                if (Accel == 0) Accel = TaskGantry.GXAxis.Para.Accel;
                if (!TaskGantry.SetMotionParamGXY(StartV, DriveV, Accel)) goto _Stop;
                if (!TaskGantry.MoveAbsGXY(X, Y, true)) goto _Stop;
                #endregion

                int i_Retry = 0;
                ox = 0;
                oy = 0;
                _Retry:

                #region Settle Time
                int SettleTime = Line.IPara[4];
                int t = GDefine.GetTickCount() + SettleTime;
                while (GDefine.GetTickCount() <= t) { Thread.Sleep(1); }
                #endregion

                int Threshold = (int)Line.DPara[5];

                double ox1 = 0;
                double oy1 = 0;
                if (!TaskVision.MatchReference(Line.IPara[1], RefID, RefNo, Threshold, out ox1, out oy1, out s, ref FoundImage)) goto _Stop;

                double v_ox1 = ox1 * TaskVision.DistPerPixelX[Line.IPara[1]];
                double v_oy1 = oy1 * TaskVision.DistPerPixelY[Line.IPara[1]];
                ox = ox + ox1;
                oy = oy + oy1;

                if (Line.DPara[6] > 0)
                {
                    if ((Math.Abs(v_ox1) > Line.DPara[6]) || (Math.Abs(v_oy1) > Line.DPara[6]))
                    {
                        i_Retry++;

                        if (i_Retry < 3)
                        {
                            double nX = TaskGantry.GXPos();
                            double nY = TaskGantry.GYPos();
                            nX = nX + v_ox1;
                            nY = nY + v_oy1;
                            if (!TaskGantry.MoveAbsGXY(nX, nY, true)) goto _Stop;
                            goto _Retry;
                        }
                    }
                }

                if (DispProg.Options_EnableProcessLog)
                {
                    string str = $"DoRef\t";
                    str += $"ID\t{Line.ID}\t";
                    //str += $"UnitNo={RunTime.UIndex}\t";
                    str += $"C,R={RunTime.Head_CR[0].X},{RunTime.Head_CR[0].Y}\t";
                    str += $"X,Y={X:f3},{Y:f3}\t";
                    str += $"OX,OY,S={ox * TaskVision.DistPerPixelX[Line.IPara[1]]:f3},{oy * TaskVision.DistPerPixelY[Line.IPara[1]]:f3},{s:f3}\t";

                    GLog.WriteProcessLog(str);
                }
            }
            catch (Exception Ex)
            {
                GDefine.Status = EStatus.ErrorInit;
                EMsg = EMsg + (char)13 + Ex.ToString();
                throw new Exception(EMsg);
            }
            GDefine.Status = EStatus.Ready;
            return true;
            _Stop:
            GDefine.Status = EStatus.Stop;
            return false;
        }
        private static bool DoRefCheck(TLine Line, double X, double Y, int RefID, int RefNo, out double ox_mm, out double oy_mm, out double s, ref Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> FoundImage)
        {
            string EMsg = "DoRefCheck";
            GDefine.Status = EStatus.Busy;

            TaskVision.LightingOn(TaskVision.LightRGB[RefID]);

            ox_mm = 0;
            oy_mm = 0;
            s = 0;

            try
            {
                #region Z Up
                if (!TaskDisp.TaskMoveGZFocus(Line.IPara[21])) return false;
                #endregion

                if (!TaskGantry.MoveGX2Y2DefPos(true)) return false;

                #region Move to XY
                double StartV = Line.DPara[10];
                if (StartV == 0) StartV = TaskGantry.GXAxis.Para.StartV;
                double DriveV = Line.DPara[11];
                if (DriveV == 0) DriveV = TaskGantry.GXAxis.Para.FastV;
                double Accel = Line.DPara[12];
                if (Accel == 0) Accel = TaskGantry.GXAxis.Para.Accel;
                if (!TaskGantry.SetMotionParamGXY(StartV, DriveV, Accel)) goto _Stop;
                if (!TaskGantry.MoveAbsGXY(X, Y, true)) goto _Stop;
                #endregion

                #region Settle Time
                int SettleTime = Line.IPara[4];
                int t = GDefine.GetTickCount() + SettleTime;
                while (GDefine.GetTickCount() <= t) { Thread.Sleep(1); }
                #endregion

                int Threshold = (int)Line.DPara[5];

                double ox = 0;
                double oy = 0;
                if (!TaskVision.MatchReference(Line.IPara[1], RefID, RefNo, Threshold, out ox, out oy, out s, ref FoundImage)) goto _Stop;

                ox_mm = ox * TaskVision.DistPerPixelX[Line.IPara[1]];
                oy_mm = oy * TaskVision.DistPerPixelY[Line.IPara[1]];
            }
            catch (Exception Ex)
            {
                GDefine.Status = EStatus.ErrorInit;
                EMsg = EMsg + (char)13 + Ex.ToString();
                throw new Exception(EMsg);
            }
            GDefine.Status = EStatus.Ready;
            return true;
        _Stop:
            GDefine.Status = EStatus.Stop;
            return false;
        }
        public static bool DoRefEdge(TLine Line, int refNo, double X, double Y, ref PointF patLoc, ref PointF ofst, ref float amplitude)
        {
            string EMsg = Line.Cmd.ToString();
            GDefine.Status = EStatus.Busy;

            int id = Line.ID;

            TaskVision.LightingOn(TaskVision.LightRGB[id]);

            if (!TaskDisp.TaskMoveGZFocus(Line.IPara[21])) return false;
            if (!TaskGantry.MoveGX2Y2DefPos(true)) return false;

            #region Move to XY
            double StartV = Line.DPara[10];
            if (StartV == 0) StartV = TaskGantry.GXAxis.Para.StartV;
            double DriveV = Line.DPara[11];
            if (DriveV == 0) DriveV = TaskGantry.GXAxis.Para.FastV;
            double Accel = Line.DPara[12];
            if (Accel == 0) Accel = TaskGantry.GXAxis.Para.Accel;
            if (!TaskGantry.SetMotionParamGXY(StartV, DriveV, Accel)) goto _Stop;
            if (!TaskGantry.MoveAbsGXY(X, Y, true)) goto _Stop;
            #endregion

            Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> img = null;
            try
            {
                int i_Retry = 0;
            _Retry:

                #region Settle Time
                int SettleTime = Line.IPara[4];
                int t = GDefine.GetTickCount() + SettleTime;
                while (GDefine.GetTickCount() <= t) { Thread.Sleep(1); }
                #endregion

                if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2)
                {
                    TaskVision.flirCamera2[0].Snap();
                    img = TaskVision.flirCamera2[0].m_ImageEmgu.m_Image.Clone();
                    TaskVision.flirCamera2[0].GrabCont();
                }
                else
                if (GDefine.CameraType[0] == GDefine.ECameraType.MVCGenTL)
                {
                    TaskVision.genTLCamera[0].GrabOneImage();
                    img = TaskVision.genTLCamera[0].mImage.Clone();
                    if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[0].StartGrab();
                }
                else
                    throw new Exception("Camera Type not Supported.");

                List<PointF> pointX = new List<PointF>();
                List<PointF> pointY = new List<PointF>();
                PointF patOfst = new PointF(0, 0);

                Rectangle[] rects = new Rectangle[2] { TaskVision.RefTemplate[id, refNo].SearchRoi, TaskVision.RefTemplate[id, refNo + 2].SearchRoi };

                TFVision.EArea area = refNo == 0 ? (TFVision.EArea)Line.IPara[14] : (TFVision.EArea)Line.IPara[15];
                TFVision.EDirPair dirPair = refNo == 0 ? (TFVision.EDirPair)Line.IPara[10] : (TFVision.EDirPair)Line.IPara[11];
                TFVision.ETransPair transPair = refNo == 0 ? (TFVision.ETransPair)Line.IPara[12] : (TFVision.ETransPair)Line.IPara[13]; TFVision.EDirection dir1 = TFVision.EDirection.PLUS;
                TFVision.EDirection dir2 = TFVision.EDirection.PLUS;
                TFVision.ETransition trans1 = TFVision.ETransition.BW;
                TFVision.ETransition trans2 = TFVision.ETransition.WB;
                switch (dirPair)
                {
                    case TFVision.EDirPair.XRight_YDown:
                        dir1 = TFVision.EDirection.PLUS;
                        dir2 = TFVision.EDirection.PLUS;
                        break;
                    case TFVision.EDirPair.XRight_YUp:
                        dir1 = TFVision.EDirection.PLUS;
                        dir2 = TFVision.EDirection.MINUS;
                        break;
                    case TFVision.EDirPair.XLeft_YDown:
                        dir1 = TFVision.EDirection.MINUS;
                        dir2 = TFVision.EDirection.PLUS;
                        break;
                    case TFVision.EDirPair.XLeft_YUp:
                        dir1 = TFVision.EDirection.MINUS;
                        dir2 = TFVision.EDirection.MINUS;
                        break;
                }

                switch (transPair)
                {
                    case TFVision.ETransPair.Auto:
                        trans1 = TFVision.ETransition.AUTO;
                        trans2 = TFVision.ETransition.AUTO;
                        break;
                    case TFVision.ETransPair.BW:
                        trans1 = TFVision.ETransition.BW;
                        trans2 = TFVision.ETransition.BW;
                        break;
                    case TFVision.ETransPair.WB:
                        trans1 = TFVision.ETransition.WB;
                        trans2 = TFVision.ETransition.WB;
                        break;
                    case TFVision.ETransPair.XBW_YWB:
                        trans1 = TFVision.ETransition.BW;
                        trans2 = TFVision.ETransition.WB;
                        break;
                    case TFVision.ETransPair.XWB_YBW:
                        trans1 = TFVision.ETransition.WB;
                        trans2 = TFVision.ETransition.BW;
                        break;
                }


                if (!TFVision.PatEdgeCorner(img, TaskVision.RefTemplate[id, refNo].Image, rects, ref pointX, ref pointY, ref patLoc, ref patOfst, ref amplitude,
                    area, dir1, dir2, trans1, trans2)) return false;

                float n_ox = 0;
                float n_oy = 0;
                n_ox = (float)(patOfst.X * TaskVision.DistPerPixelX[0]);
                n_oy = -(float)(patOfst.Y * TaskVision.DistPerPixelY[0]);
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XZ_YTABLE)
                {
                    n_oy = -n_oy;
                }
                ofst.X += n_ox;
                ofst.Y += n_oy;

                if (Line.DPara[6] > 0)
                {
                    if ((Math.Abs(n_ox) > Line.DPara[6]) || (Math.Abs(n_oy) > Line.DPara[6]))
                    {
                        i_Retry++;

                        if (i_Retry < 3)
                        {
                            double nX = TaskGantry.GXPos();
                            double nY = TaskGantry.GYPos();
                            nX = nX + n_ox;
                            nY = nY + n_oy;
                            if (!TaskGantry.MoveAbsGXY(nX, nY, true)) goto _Stop;
                            goto _Retry;
                        }
                    }
                }
            }
            catch (Exception Ex)
            {
                GDefine.Status = EStatus.ErrorInit;
                EMsg = EMsg + (char)13 + Ex.ToString();
                throw new Exception(EMsg);
            }
            finally
            {
                if (img != null) img.Dispose();
            }
            GDefine.Status = EStatus.Ready;
            return true;
        _Stop:
            GDefine.Status = EStatus.Stop;
            return false;
        }
        public static bool DoRefCircle(TLine Line, int refNo, double X, double Y, ref PointF patLoc, ref PointF ofst, ref int found, ref float roundness)
        {
            string EMsg = Line.Cmd.ToString();
            GDefine.Status = EStatus.Busy;

            int id = Line.ID;

            TaskVision.LightingOn(TaskVision.LightRGB[id]);

            if (!TaskDisp.TaskMoveGZFocus(Line.IPara[21])) return false;
            if (!TaskGantry.MoveGX2Y2DefPos(true)) return false;

            #region Move to XY
            double StartV = Line.DPara[10];
            if (StartV == 0) StartV = TaskGantry.GXAxis.Para.StartV;
            double DriveV = Line.DPara[11];
            if (DriveV == 0) DriveV = TaskGantry.GXAxis.Para.FastV;
            double Accel = Line.DPara[12];
            if (Accel == 0) Accel = TaskGantry.GXAxis.Para.Accel;
            if (!TaskGantry.SetMotionParamGXY(StartV, DriveV, Accel)) goto _Stop;
            if (!TaskGantry.MoveAbsGXY(X, Y, true)) goto _Stop;
            #endregion

            Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> img = null;
            try
            {
                int i_Retry = 0;
            _Retry:

                #region Settle Time
                int SettleTime = Line.IPara[4];
                int t = GDefine.GetTickCount() + SettleTime;
                while (GDefine.GetTickCount() <= t) { Thread.Sleep(1); }
                #endregion

                if (GDefine.CameraType[0] == GDefine.ECameraType.Spinnaker2)
                {
                    TaskVision.flirCamera2[0].Snap();
                    img = TaskVision.flirCamera2[0].m_ImageEmgu.m_Image.Clone();
                    TaskVision.flirCamera2[0].GrabCont();
                }
                else
                if (GDefine.CameraType[0] == GDefine.ECameraType.MVCGenTL)
                {
                    TaskVision.genTLCamera[0].GrabOneImage();
                    img = TaskVision.genTLCamera[0].mImage.Clone();
                    if (TaskVision.frmMVCGenTLCamera.Visible) TaskVision.genTLCamera[0].StartGrab();
                }
                else
                    throw new Exception("Camera Type not Supported.");

                Rectangle[] rects = new Rectangle[2] { TaskVision.RefTemplate[id, refNo].SearchRoi, TaskVision.RefTemplate[id, refNo + 2].SearchRoi };

                TFVision.EDetContrast detContrast = refNo == 0 ? (TFVision.EDetContrast)Line.IPara[16] : (TFVision.EDetContrast)Line.IPara[17];
                int threshold = (int)Line.DPara[5];
                float padRadius = 0;

                PointF patOfst = new PointF(0, 0);
                found = TFVision.PatCircle(img, TaskVision.RefTemplate[id, refNo].Image, threshold, rects, detContrast, ref patLoc, ref padRadius, ref patOfst, ref roundness);
                if (found == 0) return true;

                float n_ox = 0;
                float n_oy = 0;
                n_ox = (float)(patOfst.X * TaskVision.DistPerPixelX[0]);
                n_oy = -(float)(patOfst.Y * TaskVision.DistPerPixelY[0]);
                if (GDefine.GantryConfig == GDefine.EGantryConfig.XZ_YTABLE)
                {
                    n_oy = -n_oy;
                }
                ofst.X += n_ox;
                ofst.Y += n_oy;

                if (Line.DPara[6] > 0)
                {
                    if ((Math.Abs(n_ox) > Line.DPara[6]) || (Math.Abs(n_oy) > Line.DPara[6]))
                    {
                        i_Retry++;

                        if (i_Retry < 3)
                        {
                            double nX = TaskGantry.GXPos();
                            double nY = TaskGantry.GYPos();
                            nX = nX + n_ox;
                            nY = nY + n_oy;
                            if (!TaskGantry.MoveAbsGXY(nX, nY, true)) goto _Stop;
                            goto _Retry;
                        }
                    }
                }
            }
            catch (Exception Ex)
            {
                GDefine.Status = EStatus.ErrorInit;
                EMsg = EMsg + (char)13 + Ex.ToString();
                throw new Exception(EMsg);
            }
            finally
            {
                if (img != null) img.Dispose();
            }
            GDefine.Status = EStatus.Ready;
            return true;
        _Stop:
            GDefine.Status = EStatus.Stop;
            return false;
        }

        public enum ERealTimeOp { Add, Minus };
        public static void RealTimeOffset(ERealTimeOp Op, ref double X, ref double Y)
        {
            if (TaskDisp.Option_EnableRealTimeFineTune)
            {
                int UIndex = DispProg.RunTime.UIndex;
                if (Op == ERealTimeOp.Add)
                {
                    X += DispProg.rt_LayoutRelPos[UIndex].X;
                    Y += DispProg.rt_LayoutRelPos[UIndex].Y;
                }
                else
                {
                    X -= DispProg.rt_LayoutRelPos[UIndex].X;
                    Y -= DispProg.rt_LayoutRelPos[UIndex].Y;
                }
            }
        }
        public static void MasterAlign()
        {
            TLine CmdLine = new TLine();
            CmdLine.Cmd = ECmd.NONE;

            //identidy Layout command
            for (int i = 0; i < Script[0].CmdList.Count; i++)
            {
                if (Script[0].CmdList.Line[i].Cmd == ECmd.LAYOUT)
                {
                    CmdLine = new TLine(Script[0].CmdList.Line[i]);
                    break;
                }
            }
            //return if no Layout command
            if (CmdLine.Cmd == ECmd.NONE) return;

            rt_LayoutID = CmdLine.ID;
            frm_DispCore_Map.LayoutNo = rt_LayoutID;
            rt_Layouts[rt_LayoutID] = new TLayout(CmdLine);
            CurrMapMask(Map.PreMap[rt_LayoutID].Bin);

            rt_Start.X = rt_Layouts[rt_LayoutID].StartX;
            rt_Start.Y = rt_Layouts[rt_LayoutID].StartY;
            RunTime.UIndex = 0;
            RunTime.UIndex2 = 0;
            rt_Layouts[rt_LayoutID].ComputePos(ref rt_LayoutRelPos);


            CmdLine.Cmd = ECmd.NONE;

            //identify DoRef command
            for (int i = 0; i < Script[0].CmdList.Count; i++)
            {
                if (Script[0].CmdList.Line[i].Cmd == ECmd.DO_REF)
                {
                    CmdLine = new TLine(Script[0].CmdList.Line[i]);
                    break;
                }
                if (Script[0].CmdList.Line[i].Cmd == ECmd.DO_VISION)
                {
                    CmdLine = new TLine(Script[0].CmdList.Line[i]);
                    break;
                }
            }

            //return if not DoRef command
            if (CmdLine.Cmd == ECmd.NONE) return;

            double dx1 = Origin(rt_StationNo).X + /*d_Ref_Rel_X + */CmdLine.X[0];
            double dy1 = Origin(rt_StationNo).Y + /*d_Ref_Rel_Y + */CmdLine.Y[0];

            double tdx1 = dx1;
            double tdy1 = dy1;

            double v_ox1 = 0;
            double v_oy1 = 0;
            double v_s1 = 0;

            if (CmdLine.Cmd == ECmd.DO_REF)
            {
                Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> gray_FoundDoRef1 = null;
                if (!DoRef(CmdLine, dx1, dy1, CmdLine.ID, (int)EVisionRef.No1, out v_ox1, out v_oy1, out v_s1, ref gray_FoundDoRef1)) return;
                v_ox1 = v_ox1 * TaskVision.DistPerPixelX[CmdLine.IPara[1]];
                v_oy1 = v_oy1 * TaskVision.DistPerPixelY[CmdLine.IPara[1]];
                bool OK1 = (Math.Abs(v_ox1) <= CmdLine.DPara[1]) && (Math.Abs(v_oy1) <= CmdLine.DPara[1]) && (Math.Abs(v_s1) >= CmdLine.DPara[0]);

                FoundDoRef1 = gray_FoundDoRef1.Convert<Emgu.CV.Structure.Bgr, byte>();
                FoundDoRef1_X = v_ox1;
                FoundDoRef1_Y = v_oy1;
                FoundDoRef1_S = v_s1;
                FoundDoRef1_OK = OK1;

                double ndx1 = dx1 + v_ox1;
                double ndy1 = dy1 + v_oy1;
            }

            if (CmdLine.Cmd == ECmd.DO_VISION)
            {
                double v_oa = 0;
                bool v_OK = false;

                Emgu.CV.Image<Emgu.CV.Structure.Gray, byte> Image = null;
                string data = "";
                TaskVision.ExecVision((int)EVisionRef.No1, CmdLine.ID, ref v_ox1, ref v_oy1, ref v_oa, ref v_s1, ref v_OK, ref data, ref Image);

                try
                {
                    if (GDefine.CameraType[CmdLine.ID] == GDefine.ECameraType.PtGrey)
                    {
                        TaskVision.PtGrey_CamLive(CmdLine.ID);
                    }
                }
                catch { }
            }

            DispProg.OriginBase[(int)DispProg.rt_StationNo].X += v_ox1;
            DispProg.OriginBase[(int)DispProg.rt_StationNo].Y += v_oy1;

            if (!TaskGantry.SetMotionParamGXYX2Y2()) return;
            TPos2 GXY = new TPos2(DispProg.Origin(DispProg.rt_StationNo).X, DispProg.Origin(DispProg.rt_StationNo).Y);
            TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
            GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + TaskDisp.Head2_DefDistX;

            if (!TaskDisp.GotoXYPos(GXY, GX2Y2)) return;
        }

        public static List<int> ExecutedLines = new List<int>();
        public static DialogResult WeightCalAsyncShowDialog(bool b_Head1, bool b_Head2)
        {
            frm_DispCore_WeightCal frm = new frm_DispCore_WeightCal();
            frm.CalMode = frm_DispCore_WeightCal.ECalMode.Auto;
            if (b_Head1) frm.AddHead(TaskWeight.EHeadNo.One);
            if (b_Head2) frm.AddHead(TaskWeight.EHeadNo.Two);

            DialogResult dr = frm.ShowDialog();
            //frm.BringToFront();
            //frm.TopMost = true;
            return dr;
            //DialogResult dr = await frm.ShowDialogAsync();
        }

        internal static bool DoHeight(TLine Line, int Points, List<double> X, List<double> Y, List<double> Z, out bool OK)
        //return z=f(x,y), where xy is camera position
        {
            string EMsg = "DoHeight";
            GDefine.Status = EStatus.Busy;

            int SettleTime = Line.IPara[4];

            OK = false;

            try
            {
                if (!TaskDisp.TaskMoveGZZ2Up()) return false;
                if (!TaskGantry.MoveGX2Y2DefPos(true)) return false;

                #region Set XY Move Para
                double StartV = Line.DPara[10];
                if (StartV == 0) StartV = TaskGantry.GXAxis.Para.StartV;
                double DriveV = Line.DPara[11];
                if (DriveV == 0) DriveV = TaskGantry.GXAxis.Para.FastV;
                double Accel = Line.DPara[12];
                if (Accel == 0) Accel = TaskGantry.GXAxis.Para.Accel;
                #endregion

                for (int i = 0; i < Points; i++)
                {
                    //move xy
                    if (i == 0)
                    {
                        TPos2 GXY = new TPos2(X[i], Y[i]);
                        GXY.X = GXY.X + TaskDisp.Laser_Ofst.X;
                        GXY.Y = GXY.Y + TaskDisp.Laser_Ofst.Y;
                        TPos2 GX2Y2 = new TPos2(TaskDisp.Head2_DefPos.X, TaskDisp.Head2_DefPos.Y);
                        GX2Y2.X = GX2Y2.X - TaskDisp.Head2_DefDistX + TaskDisp.Head2_DefDistX;

                        if (!TaskGantry.SetMotionParamGXY(StartV, DriveV, Accel)) goto _Stop;
                        if (!TaskGantry.MoveAbsGXY(GXY.X, GXY.Y, true)) goto _Stop;
                    }
                    else
                    {
                        //move xy
                        if (!TaskGantry.SetMotionParamGXY(StartV, DriveV, Accel)) goto _Stop;
                        if (!TaskGantry.MoveAbsGXY(X[i] + TaskDisp.Laser_Ofst.X, Y[i] + TaskDisp.Laser_Ofst.Y)) goto _Stop;
                    }
                    Thread.Sleep(1);

                    //settle time
                    int t = GDefine.GetTickCount() + SettleTime;
                    while (GDefine.GetTickCount() <= t) { Thread.Sleep(1); }

                    //get value
                    double v = 0;
                    double d = 0;
                    OK = TaskLaser.GetHeight(ref d);
                    if (!OK) goto _Stop;

                    v = d;
                    Z[i] = (v - TaskDisp.Laser_RefPosZ);
                }
            }
            catch (Exception Ex)
            {
                GDefine.Status = EStatus.ErrorInit;
                EMsg = EMsg + (char)13 + Ex.Message.ToString();
                throw new Exception(EMsg);
            }
            GDefine.Status = EStatus.Ready;
            return true;
        _Stop:
            GDefine.Status = EStatus.Stop;
            return false;
        }


        internal enum EHeightSetReturn { OK, NG, Stop, Skip};
        internal static EHeightSetReturn HeightSet(TLine cmdLine, THeightData heightData, PointD pointXY)
        {
            heightData.OK = false;

            TaskVision.LightingOff();

            double[] ofstX = new double[] { 0.01, 0.01, -0.01, -0.01 };
            double[] ofstY = new double[] { 0.01, -0.01, 0.01, -0.01 };
            List<double> X = ofstX.Select(x => pointXY.X + x).ToList();
            List<double> Y = ofstY.Select(y => pointXY.Y + y).ToList();
            List<double> zHeightValue = Enumerable.Range(0, ofstX.Length).Select(z => (double)z * 0).ToList();

            bool doOK = false;
            if (!DoHeight(cmdLine, zHeightValue.Count, X, Y, zHeightValue, out doOK)) return EHeightSetReturn.Stop;

            heightData.A = 0;
            heightData.B = 0;
            heightData.C = zHeightValue.Average();

            #region Add Laser Log
            string s_HeightData = $"HeightSet Ave {zHeightValue.Average():f5}, Range {zHeightValue.Max() - zHeightValue.Min():f5}, Data " + 
                string.Join(",", zHeightValue.Select(z => z.ToString("f5")).ToArray());
            Log.Laser.WriteByMonthDay("UnitNo " + RunTime.UIndex.ToString() + " " + s_HeightData);
            #endregion

            if (!doOK) return EHeightSetReturn.Stop;

            double d_RefHeight = TaskDisp.Laser_CalValue == 0 ? cmdLine.DPara[5]: TaskDisp.Laser_CalValue - TaskDisp.Laser_RefPosZ + cmdLine.DPara[5];
            double d_RefHeightErrorTol = cmdLine.DPara[6];
            if (d_RefHeightErrorTol > 0)
            {
                foreach (double d in zHeightValue)
                {
                    if ((d <= d_RefHeight - d_RefHeightErrorTol) || (d >= d_RefHeight + d_RefHeightErrorTol))
                    {
                        Msg MsgBox = new Msg();
                        EMsgRes MsgRes = MsgBox.Show(ErrCode.LASER_OUT_OF_REF_HEIGHT_TOL, $"Ref Height = {d_RefHeight:f4} Current Height = {d:f4}", EMcState.Warning, EMsgBtn.smbStop_Cancel, false);

                        switch (MsgRes)
                        {
                            case EMsgRes.smrCancel:
                                heightData.OK = false;
                                return EHeightSetReturn.Skip;
                            default://Stop
                                return EHeightSetReturn.Stop;
                        }
                    }
                }
            }

            double d_RefHeightSkipTol = cmdLine.DPara[7];
            if (d_RefHeightSkipTol > 0)
            {
                foreach (double d in zHeightValue)
                {
                    if ((d <= d_RefHeight - d_RefHeightSkipTol) || (d >= d_RefHeight + d_RefHeightSkipTol))
                    {
                        heightData.OK = false;
                        return EHeightSetReturn.Skip;
                    }
                }
            }

            double dHeightRangeTol = cmdLine.DPara[0];
            double dHeightRange = zHeightValue.Max() - zHeightValue.Min();
            if (dHeightRange > dHeightRangeTol)
            {
                Msg MsgBox = new Msg();
                EMsgRes MsgRes = MsgBox.Show($"Laser Height Z Diff exceed spec. \nMeasured(mm) {dHeightRange:f3}\nSpec(mm) {dHeightRangeTol:f3}", EMcState.Warning, EMsgBtn.smbStop_Cancel, false);

                switch (MsgRes)
                {
                    case EMsgRes.smrCancel:
                        heightData.OK = false;
                        return EHeightSetReturn.Skip;
                    default://Stop
                        return EHeightSetReturn.Stop;
                }
            }

            heightData.OK = doOK;
            return EHeightSetReturn.OK;
        }

        internal class TProcessCamera
        {
            internal static bool StartVideoLog()
            {
                if (!DispProg.Options_EnableProcessCamera) return true;

                var sw = System.Diagnostics.Stopwatch.StartNew();
                while (true)
                {
                    bool ready = false;
                    if (!TFVideoLogger.TaskIsReady(ref ready)) return false;
                    if (ready) break;

                    if (!DispProg.Options_WaitCameraReady) return true;

                    if (DispProg.Options_WaitCameraReady) Thread.Sleep(10);

                    if (sw.ElapsedMilliseconds > 10000)
                    {
                        Msg MsgBox = new Msg();
                        MsgBox.Show(ErrCode.DISP_RECORDER_NO_RESPONSE_ERR);
                        return false;
                    }
                }

                string lot = LotInfo2.LotNumber;
                string id = DispProg.rt_Read_IDs[0, 0];

                string fName = lot.Length > 0 ? lot + "_" : "";
                fName += id.Length > 0 ? $"{id}_" : $"{DateTime.Now:yyyyMMddHHmmss}_{Stats.BoardCount}";

                string folder = $"c:\\Process\\Video\\{DateTime.Now:yyyyMM}\\";
                if (lot.Length > 0)
                {
                    folder += $"{lot}\\";
                    Directory.CreateDirectory(folder);
                }
                if (id.Length > 0)
                {
                    folder += $"{id}\\";
                    Directory.CreateDirectory(folder);
                }

                string cmd = $"CAMALL,SHORT{Options_VideoLogDuration}," +
                    $"{folder}{fName}_C{RunTime.Head_CR[0].X}_R{RunTime.Head_CR[0].Y}," +
                    $"{folder}{fName}_C{RunTime.Head_CR[1].X}_R{RunTime.Head_CR[1].Y}";

                return TFVideoLogger.TaskWritePort(cmd);
            }
            internal static bool StopVideoLog()
            {
                if (!DispProg.Options_EnableProcessCamera) return true;

                return TFVideoLogger.TaskWritePort("StopRecord");
            }
            internal static bool ImageSnap()
            {
                if (!DispProg.Options_EnableProcessCamera) return true;

                var sw = System.Diagnostics.Stopwatch.StartNew();
                while (true)
                {
                    bool ready = false;
                    if (!TFVideoLogger.TaskIsReady(ref ready)) return false;
                    if (ready) break;

                    if (!DispProg.Options_WaitCameraReady) return true;

                    if (DispProg.Options_WaitCameraReady) Thread.Sleep(10);

                    if (sw.ElapsedMilliseconds > 10000)
                    {
                        Msg MsgBox = new Msg();
                        MsgBox.Show(ErrCode.DISP_RECORDER_NO_RESPONSE_ERR);
                        return false;
                    }
                }

                string lot = LotInfo2.LotNumber;
                string id = DispProg.rt_Read_IDs[0, 0];

                string fName = lot.Length > 0 ? lot + "_" : "";
                fName += id.Length > 0 ? $"{id}_" : $"{DateTime.Now:yyyyMMddHHmmss}_{Stats.BoardCount}";

                string folder = $"c:\\Process\\Image\\{DateTime.Now:yyyyMM}\\";
                if (lot.Length > 0)
                {
                    folder += $"{lot}\\";
                    Directory.CreateDirectory(folder);
                }
                if (id.Length > 0)
                {
                    folder += $"{id}\\";
                    Directory.CreateDirectory(folder);
                }

                string cmd = $"CAMALL,SNAP," +
                    $"{folder}{fName}_C{RunTime.Head_CR[0].X}_R{RunTime.Head_CR[0].Y}," +
                    $"{folder}{fName}_C{RunTime.Head_CR[1].X}_R{RunTime.Head_CR[1].Y}";

                return TFVideoLogger.TaskWritePort(cmd);
            }
        }
    }

    internal enum EDispProgCondExec
    {
        None, Always, Follow, StartOfBoard, EndOfBoard,
        EveryNthBoard, EveryNthUnit, EveryNthShot, Board_ContinueUnit, Board_ContinueShot,
        Board_EveryNthUnit, Board_EveryNthShot,
        PPFilling, 
        Disp_Counter1, Disp_Counter2, Disp_Counter3,
        FirstBoard,
    };
    internal enum EDispProgCondOperand
    {
        Or, And
    }
    internal class TCondition
    {
        public int ID = -1;
        public EDispProgCondExec Cond = EDispProgCondExec.None;
        public double Count = 0;
        public EDispProgCondOperand Op = EDispProgCondOperand.Or;

        public TCondition()
        {
        }
        public TCondition(int ID, EDispProgCondExec Cond, double Count, EDispProgCondOperand Op)
        {
            this.ID = ID;
            this.Cond = Cond;
            this.Count = Count;
            this.Op = Op;
        }
        public bool IsTrue
        {
            get
            {
                switch (Cond)
                {
                    case EDispProgCondExec.None: return false;
                    case EDispProgCondExec.Always: return true;
                    case EDispProgCondExec.StartOfBoard:
                        if (Stats.Board.UnitCount[0] == 0) return true;
                        break;
                    case EDispProgCondExec.Follow:
                        return (DispProg.ExecutedLines.Count > 0 && DispProg.ExecutedLines.Contains(ID - 1));
                    case EDispProgCondExec.FirstBoard:
                        if (Stats.BoardCount == 0) return true;
                        break;
                    case EDispProgCondExec.EveryNthBoard:
                        if (Stats.BoardCount > 0 && Stats.BoardCount % Count == 0) return true;
                        break;
                    case EDispProgCondExec.EveryNthUnit:
                        if (Stats.UnitCount[0] > 0 && Stats.UnitCount[0] % Count == 0) return true;
                        break;
                    case EDispProgCondExec.EveryNthShot:
                        if (Stats.DispCount[0] > 0 && Stats.DispCount[0] % Count == 0) return true;
                        break;
                    case EDispProgCondExec.Board_ContinueUnit:
                        if (Stats.ContinueBoard.UnitCount[0] <= Count) return true;
                        break;
                    case EDispProgCondExec.Board_ContinueShot:
                        if (Stats.ContinueBoard.DispCount[0] <= Count) return true;
                        break;
                    case EDispProgCondExec.Board_EveryNthUnit:
                        if (Stats.Board.UnitCount[0] > 0 && Stats.Board.UnitCount[0] % Count == 0) return true;
                        break;
                    case EDispProgCondExec.Board_EveryNthShot:
                        if (Stats.Board.DispCount[0] > 0 && Stats.Board.DispCount[0] % Count == 0) return true;
                        break;
                    case EDispProgCondExec.PPFilling:
                        return TaskDisp.IsFilling();
                    case EDispProgCondExec.Disp_Counter1:
                        if (Stats.Board.DispCounter[0] >= Count)
                        {
                            Stats.Board.DispCounter[0] = 0;
                            return true;
                        }
                        break;
                    case EDispProgCondExec.Disp_Counter2:
                        if (Stats.Board.DispCounter[1] >= Count)
                        {
                            Stats.Board.DispCounter[1] = 0;
                            return true;
                        }
                        break;
                    case EDispProgCondExec.Disp_Counter3:
                        if (Stats.Board.DispCounter[2] >= Count)
                        {
                            Stats.Board.DispCounter[2] = 0;
                            return true;
                        }
                        break;
                    default:
                        throw new Exception("Condition is not supported.");
                }
                return false;
            }
        }
    }
    internal class TConditions
    {
        public const int MAX_COND = 2;
        public TCondition[] Cond = new TCondition[MAX_COND] { new TCondition(), new TCondition() };
        public TConditions(int ID, DispProg.TLine CmdLine)
        {
            for (int i = 0; i < MAX_COND; i++)
            {
                int idx = i * 5;
                this.Cond[i] = new TCondition(ID, (EDispProgCondExec)CmdLine.Cond[idx + 0], CmdLine.Cond[idx + 1], (EDispProgCondOperand)CmdLine.Cond[idx + 2]);
            }
        }
        public bool IsTrue
        {
            get
            {
                bool Result = false;
                for (int i = 0; i < MAX_COND; i++)
                {
                    if (i == 0)
                    {
                        Result = Cond[i].IsTrue;
                    }
                    else
                    {
                        switch (Cond[i - 1].Op)
                        {
                            case EDispProgCondOperand.Or:
                                Result = Result || Cond[i].IsTrue; break;
                            case EDispProgCondOperand.And:
                                Result = Result && Cond[i].IsTrue; break;
                        }
                    }
                }
                return Result;
            }
        }
        public string[] Strings
        {
            get
            {
                string[] S = new string[2] { "", "" };

                for (int i = 0; i < MAX_COND; i++)
                {
                    string s = "";
                    if (Cond[i].Cond > EDispProgCondExec.None)
                    {
                        s = "Cond" + i.ToString() + ": " + Cond[i].Cond.ToString() + " Value " + Cond[i].Count.ToString();
                    }
                    if (i < MAX_COND - 1 && Cond[i + 1].Cond > EDispProgCondExec.None)
                    {
                        if (i != MAX_COND - 1) s = s + " (" + Cond[i].Op + ")";
                    }
                    S[i] = s;
                }

                return S;
            }
        }
    }

    internal class TBiasKernel
    {
        public int R = 0;
        public int C = 0;
        public double[,] X = new double[TLayout.MAX_RC, TLayout.MAX_RC];
        public double[,] Y = new double[TLayout.MAX_RC, TLayout.MAX_RC];
        public double[,] Z = new double[TLayout.MAX_RC, TLayout.MAX_RC];

        public TBiasKernel()
        {
            Init();
        }
        public void Init()
        {
            for (int i = 0; i < TLayout.MAX_RC; i++)
                for (int j = 0; j < TLayout.MAX_RC; j++)
                {
                    X[i, j] = 0;
                    Y[i, j] = 0;
                    Z[i, j] = 0;
                }
        }
        public void Clear()
        {
            Init();
        }
        enum ELineType { Header, XMap, YMap, ZMap };
        public bool Load(string Filename)
        {
            Init();

            if (!File.Exists(Filename)) return false;

            try
            {
                FileStream F = new FileStream(Filename, FileMode.Open, FileAccess.ReadWrite, FileShare.Write);
                StreamReader R = new StreamReader(F);

                string FileLine = R.ReadToEnd();
                R.Close();

                string[] Lines = FileLine.Split(new char[] { (char)10 }, StringSplitOptions.RemoveEmptyEntries);

                ELineType LineType = ELineType.Header;

                for (int Line = 0; Line < Lines.Count(); Line++)
                {
                    string[] s = Lines[Line].Split(new char[] { (char)9 }, StringSplitOptions.RemoveEmptyEntries);

                    if (s[0].Contains("RC"))
                    {
                        int.TryParse(s[1], out this.R);
                        int.TryParse(s[2], out this.C);
                        continue;
                    }

                    if (s[0].Contains("X Map"))
                    {
                        LineType = ELineType.XMap;
                        continue;
                    }

                    if (s[0].Contains("Y Map"))
                    {
                        LineType = ELineType.YMap;
                        continue;
                    }

                    if (s[0].Contains("Z Map"))
                    {
                        LineType = ELineType.ZMap;
                        continue;
                    }

                    if (LineType == ELineType.XMap || LineType == ELineType.YMap || LineType == ELineType.ZMap)
                    {
                        int iR = 0;
                        int iC = 0;
                        double dValue = 0;

                        int.TryParse(s[0], out iR);

                        for (int c = 1; c <= this.C; c++)
                        {
                            iC = c - 1;

                            double.TryParse(s[c], out dValue);

                            if (LineType == ELineType.XMap) X[iC, iR] = dValue;
                            if (LineType == ELineType.YMap) Y[iC, iR] = dValue;
                            if (LineType == ELineType.ZMap) Z[iC, iR] = dValue;
                        }
                    }
                }
            }
            catch
            {
                MessageBox.Show("Bias Kernal Load Exception Error.");
            }

            return true;
        }
        public void Save(string Filename, int iTotalRow, int iTotalCol)
        {
            try
            {
                FileStream F = new FileStream(Filename, FileMode.Create, FileAccess.Write, FileShare.Write);
                StreamWriter W = new StreamWriter(F);

                W.WriteLine("RC" + (char)9 + iTotalRow + (char)9 + iTotalCol);

                string S = "X Map" + (char)9;
                for (int c = 0; c < iTotalCol; c++)
                    S = S + c.ToString() + (char)9;
                W.WriteLine(S);

                for (int r = 0; r < iTotalRow; r++)
                {
                    S = r.ToString() + (char)9;
                    for (int c = 0; c < iTotalCol; c++)
                        S = S + X[r, c] + (char)9;
                    W.WriteLine(S);
                }

                S = "Y Map" + (char)9;
                for (int c = 0; c < iTotalCol; c++)
                    S = S + c.ToString() + (char)9;
                W.WriteLine(S);

                for (int r = 0; r < iTotalRow; r++)
                {
                    S = r.ToString() + (char)9;
                    for (int c = 0; c < iTotalCol; c++)
                        S = S + Y[r, c] + (char)9;
                    W.WriteLine(S);
                }

                S = "Z Map" + (char)9;
                for (int c = 0; c < iTotalCol; c++)
                    S = S + c.ToString() + (char)9;
                W.WriteLine(S);

                for (int r = 0; r < iTotalRow; r++)
                {
                    S = r.ToString() + (char)9;
                    for (int c = 0; c < iTotalCol; c++)
                        S = S + Z[r, c] + (char)9;
                    W.WriteLine(S);
                }

                W.Close();
            }
            catch
            {
                MessageBox.Show("Bias Kernal Save Exception Error.");
            }
        }
    }
}
